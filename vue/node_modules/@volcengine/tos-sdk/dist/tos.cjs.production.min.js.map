{"version":3,"file":"tos.cjs.production.min.js","sources":["../src/TosServerError.ts","../src/TosClientError.ts","../src/CancelError.ts","../src/nodejs/fs-promises.ts","../src/log.ts","../src/utils.ts","../src/methods/object/multipart/createMultipartUpload.ts","../src/methods/object/multipart/listParts.ts","../src/mime-types.ts","../src/nodejs/EmitReadStream.ts","../src/universal/crc.ts","../src/nodejs/crc.node.ts","../src/nodejs/rate-limiter.ts","../src/universal/rate-limiter.ts","../src/nodejs/buffer2Stream.ts","../src/nodejs/CrcReadStream.ts","../src/methods/object/sharedTypes.ts","../src/methods/object/utils.ts","../src/interface.ts","../src/axios.ts","../src/universal/crypto.browser.ts","../src/nodejs/crypto.nodejs.ts","../src/universal/crypto.ts","../src/methods/object/multipart/uploadPart.ts","../src/methods/object/multipart/completeMultipartUpload.ts","../src/nodejs/EmptyReadStream.ts","../src/methods/object/multipart/uploadFile.ts","../src/TosExportEnum.ts","../src/methods/object/multipart/resumableCopyObject.ts","../src/methods/object/headObject.ts","../src/methods/object/multipart/uploadPartCopy.ts","../src/methods/object/copyObject.ts","../src/methods/object/getObject.ts","../src/methods/object/downloadFile.ts","../src/signatureV4.ts","../src/nodejs/TosAgent.ts","../src/methods/base.ts","../src/methods/object/listObjects.ts","../src/methods/object/listObjectsType2.ts","../src/ShareLinkClient.ts","../src/methods/bucket/base.ts","../src/methods/bucket/acl.ts","../src/methods/bucket/httpsConfig.ts","../src/methods/object/putObject.ts","../src/methods/object/fetch.ts","../src/methods/object/getPreSignedUrl.ts","../src/methods/object/deleteObject.ts","../src/methods/object/renameObject.ts","../src/methods/object/deleteMultiObjects.ts","../src/methods/object/acl/index.ts","../src/methods/object/multipart/abortMultipartUpload.ts","../src/methods/object/multipart/listMultipartUploads.ts","../src/methods/object/appendObject.ts","../src/methods/object/setObjectMeta.ts","../src/methods/object/calculatePostSignature.ts","../src/handleEmptyServerError.ts","../src/methods/bucket/policy.ts","../src/methods/bucket/versioning.ts","../src/methods/object/preSignedPolicyURL.ts","../src/methods/bucket/getBucketLocation.ts","../src/methods/bucket/cors.ts","../src/methods/bucket/lifecycle.ts","../src/methods/bucket/encryption.ts","../src/methods/bucket/mirrorback.ts","../src/methods/object/tagging.ts","../src/methods/bucket/replication.ts","../src/methods/bucket/website.ts","../src/methods/bucket/notification.ts","../src/methods/bucket/customDomain.ts","../src/methods/bucket/realTimeLog.ts","../src/methods/bucket/inventory.ts","../src/methods/qosPolicy/index.ts","../src/methods/batch/index.ts","../src/methods/bucket/tag.ts","../src/methods/bucket/payByTraffic.ts","../src/methods/bucket/img.ts","../src/methods/bucket/intelligenttiering.ts","../src/methods/bucket/rename.ts","../src/methods/object/restoreObject.ts","../src/methods/storageLens/index.ts","../src/methods/bucket/notificationType2.ts","../src/methods/object/putSymlink.ts","../src/methods/object/getSymlink.ts","../src/methods/bucket/acceleration.ts","../src/methods/bucket/accessMonitor.ts","../src/methods/mrap/index.tsx","../src/methods/accesspoint/index.tsx","../src/methods/accelerator/index.tsx","../src/methods/mrap/mirror.tsx","../src/methods/bucket/media.ts","../src/methods/bucket/trash.ts","../src/methods/bucket/lock.ts","../src/methods/object/retention.ts","../src/methods/bucket/cdnNotification.ts","../src/methods/bucket/workflow.ts","../src/methods/fileCompress/index.ts","../src/methods/fileUncompress/index.ts","../src/methods/bucket/logging.ts","../src/methods/mrap/policy.tsx","../src/methods/bucket/audit.ts","../src/methods/bucket/listJob.ts","../src/methods/bucket/audioConvert.ts","../src/methods/object/getObjectAITag.ts","../src/methods/bucket/requestPayment.ts","../src/InnerClient.ts","../src/browser-index.ts"],"sourcesContent":["import { AxiosResponse } from 'axios';\nimport { Headers } from './interface';\n\nexport interface TosServerErrorData {\n  Code: string;\n  HostId: string;\n  Message: string;\n  RequestId: string;\n  EC?: string;\n}\n\nexport class TosServerError extends Error {\n  /**\n   * is original from backend, equals `data.Code`\n   */\n  public code: string;\n\n  /**\n   * the body when backend errors\n   */\n  public data: TosServerErrorData;\n  /**\n   * status code\n   */\n  public statusCode: number;\n  /**\n   * response headers\n   */\n  public headers: Headers;\n\n  /**\n   * identifies the errored request, equals to headers['x-tos-request-id'].\n   * If you has any question about the request, please send the requestId and id2 to TOS worker.\n   */\n  public requestId: string;\n\n  /**\n   * identifies the errored request, equals to headers['x-tos-id-2'].\n   * If you has any question about the request, please send the requestId and id2 to TOS worker.\n   */\n  public id2: string;\n\n  constructor(response: AxiosResponse<TosServerErrorData>) {\n    const { data } = response;\n    super(data.Message);\n\n    // https://www.dannyguo.com/blog/how-to-fix-instanceof-not-working-for-custom-errors-in-typescript/\n    Object.setPrototypeOf(this, TosServerError.prototype);\n\n    this.data = data;\n    this.code = data.Code;\n    this.statusCode = response.status;\n    this.headers = response.headers;\n    this.requestId = response.headers['x-tos-request-id'];\n    this.id2 = response.headers['x-tos-id-2'];\n  }\n}\n\nexport default TosServerError;\n\nexport enum TosServerCode {\n  NoSuchBucket = 'NoSuchBucket',\n  NoSuchKey = 'NoSuchKey',\n  AccessDenied = 'AccessDenied',\n  MalformedAcl = 'MalformedAclError',\n  UnexpectedContent = 'UnexpectedContent',\n  InvalidRequest = 'InvalidRequest',\n  MissingSecurityHeader = 'MissingSecurityHeader',\n  InvalidArgument = 'InvalidArgument',\n  EntityTooSmall = 'EntityTooSmall',\n  InvalidBucketName = 'InvalidBucketName',\n  BucketNotEmpty = 'BucketNotEmpty',\n  TooManyBuckets = 'TooManyBuckets',\n  BucketAlreadyExists = 'BucketAlreadyExists',\n  MalformedBody = 'MalformedBody',\n  NoSuchLifecycleConfiguration = 'NoSuchLifecycleConfiguration',\n  ReplicationConfigurationNotFound = 'ReplicationConfigurationNotFoundError',\n  InvalidLocationConstraint = 'InvalidLocationConstraint',\n  AuthorizationQueryParametersError = 'AuthorizationQueryParametersError',\n  RequestTimeTooSkewed = 'RequestTimeTooSkewed',\n  SignatureDoesNotMatch = 'SignatureDoesNotMatch',\n  RequestedRangeNotSatisfiable = 'Requested Range Not Satisfiable',\n  PreconditionFailed = 'PreconditionFailed',\n  BadDigest = 'BadDigest',\n  InvalidDigest = 'InvalidDigest',\n  EntityTooLarge = 'EntityTooLarge',\n  UnImplemented = 'UnImplemented',\n  MethodNotAllowed = 'MethodNotAllowed',\n  InvalidAccessKeyId = 'InvalidAccessKeyId',\n  InvalidSecurityToken = 'InvalidSecurityToken',\n  ContentSHA256Mismatch = 'ContentSHA256Mismatch',\n  ExceedQPSLimit = 'ExceedQPSLimit',\n  ExceedRateLimit = 'ExceedRateLimit',\n  NoSuchCORSConfiguration = 'NoSuchCORSConfiguration',\n  NoSuchMirrorConfiguration = 'NoSuchMirrorConfiguration',\n  NoSuchWebsiteConfiguration = 'NoSuchWebsiteConfiguration',\n  MissingRequestBody = 'MissingRequestBodyError',\n  BucketAlreadyOwnedByYou = 'BucketAlreadyOwnedByYou',\n  NoSuchBucketPolicy = 'NoSuchBucketPolicy',\n  PolicyTooLarge = 'PolicyTooLarge',\n  MalformedPolicy = 'MalformedPolicy',\n  InvalidKey = 'InvalidKey',\n  MirrorFailed = 'MirrorFailed',\n  Timeout = 'Timeout',\n  OffsetNotMatched = 'OffsetNotMatched',\n  NotAppendable = 'NotAppendable',\n  ContextCanceled = 'ContextCanceled',\n  InternalError = 'InternalError',\n  TooManyRequests = 'TooManyRequests',\n  TimeOut = 'TimeOut',\n  ConcurrencyUpdateObjectLimit = 'ConcurrencyUpdateObjectLimit',\n  DuplicateUpload = 'DuplicateUpload',\n  DuplicateObject = 'DuplicateObject',\n  InvalidVersionId = 'InvalidVersionId',\n  StorageClassNotMatch = 'StorageClassNotMatch',\n  UploadStatusNotUploading = 'UploadStatusNotUploading',\n  PartSizeNotMatch = 'PartSizeNotMatch',\n  NoUploadPart = 'NoUploadPart',\n  PartsLenInvalid = 'PartsLenInvalid',\n  PartsIdxSmall = 'PartsIdxSmall',\n  PartSizeSmall = 'PartSizeSmall',\n  PrefixNotNextKeyPrefix = 'PrefixNotNextKeyPrefix',\n  InvalidPart = 'InvalidPart',\n  InvalidPartOffset = 'InvalidPartOffset',\n  MismatchObject = 'MismatchObject',\n  UploadStatusMismatch = 'UploadStatusMismatch',\n  CompletingStatusNoExpiration = 'CompletingStatusNoExpiration',\n  Found = 'Found',\n  InvalidRedirectLocation = 'InvalidRedirectLocation',\n}\n","export class TosClientError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // https://www.dannyguo.com/blog/how-to-fix-instanceof-not-working-for-custom-errors-in-typescript/\n    Object.setPrototypeOf(this, TosClientError.prototype);\n  }\n}\n\nexport default TosClientError;\n","export class CancelError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // https://www.dannyguo.com/blog/how-to-fix-instanceof-not-working-for-custom-errors-in-typescript/\n    Object.setPrototypeOf(this, CancelError.prototype);\n  }\n}\n","/**\n * since fs/promises exist after nodejs@14, so we make own fs/promises\n */\nimport fs from 'fs';\nimport fsPromises from 'fs/promises';\nimport { promisify } from 'util';\n\nexport const createWriteStream = fs.createWriteStream;\nexport const createReadStream = fs.createReadStream;\nexport const open = fsPromises.open;\nexport const close = promisify(fs.close);\nexport const rename = promisify(fs.rename);\nexport const stat = promisify(fs.stat);\nexport const mkdir = promisify(fs.mkdir);\nexport const writeFile = promisify(fs.writeFile);\nexport const write = promisify(fs.write);\nexport const appendFile = promisify(fs.appendFile);\n// fs.rm was added v14.14.0, so use fs.unlink\nexport const rm = promisify(fs.unlink);\nexport const readFile = promisify(fs.readFile);\n\nexport const safeMkdirRecursive = async (dirName: fs.PathLike) => {\n  try {\n    await fsPromises.access(dirName);\n  } catch (e) {\n    await fsPromises.mkdir(dirName, { recursive: true });\n  }\n};\n","import createDebug from 'debug';\n\nexport const TOS = createDebug('TOS');\n","import { Readable } from 'stream';\nimport {\n  CamelCasedPropertiesDeep,\n  KebabCasedPropertiesDeep,\n  PascalCasedPropertiesDeep,\n} from 'type-fest';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\nimport { CancelError } from './CancelError';\nimport TosClientError from './TosClientError';\nimport { Headers } from './interface';\nimport { TOSConstructorOptions, TosResponse } from './methods/base';\nimport qs from 'qs';\nimport TosServerError from './TosServerError';\nimport { CRCCls } from './universal/crc';\nimport * as fsp from './nodejs/fs-promises';\nimport { ReadStream, WriteStream } from 'fs';\nimport * as log from './log';\n\n// obj[key] must be a array\nexport const makeArrayProp = (obj: unknown) => (key: string) => {\n  if (obj == null || typeof obj !== 'object') {\n    return;\n  }\n\n  const value = get(obj, key);\n  if (!Array.isArray(value)) {\n    set(obj, key, value == null ? [] : [value]);\n  }\n};\n\nconst makeConvertProp = (convertMethod: (prop: string) => string) => {\n  const finalMethod = <T = unknown>(target: T): T => {\n    if (Array.isArray(target)) {\n      return target.map((it) => finalMethod(it)) as unknown as T;\n    }\n\n    if (typeof target === 'string') {\n      return convertMethod(target) as unknown as T;\n    }\n\n    if (typeof target === 'object' && target != null) {\n      type Obj = Record<string, unknown>;\n      const ret = Object.keys(target).reduce((acc: Obj, key: string) => {\n        const nextKey = finalMethod(key);\n        acc[nextKey] = (target as Obj)[key];\n        return acc;\n      }, {});\n      return ret as unknown as T;\n    }\n\n    return target;\n  };\n\n  return finalMethod;\n};\n\nexport const covertCamelCase2Kebab = makeConvertProp((camelCase: string) => {\n  return camelCase.replace(/[A-Z]/g, '-$&').toLowerCase();\n}) as <T = unknown>(target: T) => KebabCasedPropertiesDeep<T>;\n\nexport const convertUpperCamelCase2Normal = makeConvertProp(\n  (upperCamelCase: string) => {\n    return upperCamelCase[0].toLocaleLowerCase() + upperCamelCase.slice(1);\n  }\n) as <T = unknown>(target: T) => CamelCasedPropertiesDeep<T>;\n\nexport const convertNormalCamelCase2Upper = makeConvertProp(\n  (normalCamelCase: string) => {\n    return normalCamelCase[0].toUpperCase() + normalCamelCase.slice(1);\n  }\n) as <T = unknown>(target: T) => PascalCasedPropertiesDeep<T>;\n\nexport const getSortedQueryString = (query: Record<string, any>) => {\n  const searchParts: string[] = [];\n  Object.keys(query)\n    .sort()\n    .forEach((key) => {\n      searchParts.push(\n        `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`\n      );\n    });\n  return searchParts.join('&');\n};\n\nexport const normalizeHeadersKey = <T extends Headers>(\n  headers: T | undefined\n): T => {\n  const headers1: Headers = headers || {};\n  const headers2: Headers = {};\n  Object.keys(headers1).forEach((key: string) => {\n    if (headers1[key] != null) {\n      headers2[key] = headers1[key];\n    }\n  });\n\n  const headers3: Headers = {};\n  Object.keys(headers2).forEach((key: string) => {\n    const newKey = key.toLowerCase();\n    headers3[newKey] = headers2[key];\n  });\n\n  return headers3 as T;\n};\n\nexport const encodeHeadersValue = (headers: Headers) => {\n  const header2: Headers = {};\n  Object.entries(headers).forEach(([key, value]) => {\n    header2[key] = `${value}`\n      // reference:\n      //  https://stackoverflow.com/questions/38345372/why-is-length-2\n      .match(/./gu)!\n      .map((ch: string) => {\n        if (ch.length > 1 || ch.charCodeAt(0) >= 128) {\n          return encodeURIComponent(ch);\n        }\n        return ch;\n      })\n      .join('');\n  });\n  return header2;\n};\n\n// TODO: getRegion from endpoint, maybe user passes it is better.\nexport const getRegion = (endpoint: string) => {\n  const region = endpoint.match(/-(\\w+).volces.com/);\n  if (!region) {\n    return 'cn-beijing';\n  }\n  return `cn-${region[1]}`;\n};\n\nexport const getEndpoint = (region: string) => {\n  return `tos-${region}.volces.com`;\n};\n\nexport const normalizeProxy = (proxy: TOSConstructorOptions['proxy']) => {\n  if (typeof proxy === 'string') {\n    proxy = {\n      url: proxy,\n    };\n  }\n\n  if (\n    proxy &&\n    proxy?.needProxyParams == null &&\n    process.env.TARGET_ENVIRONMENT === 'browser'\n  ) {\n    proxy.needProxyParams = true;\n  }\n\n  return proxy;\n};\n\nexport async function safeAwait<T>(\n  p: T\n): Promise<[null, Awaited<T>] | [any, null]> {\n  try {\n    const v = await p;\n    return [null, v];\n  } catch (err) {\n    return [err, null];\n  }\n}\n\nexport function safeSync<T>(func: () => T): [any, null] | [null, T] {\n  try {\n    const ret = func();\n    return [null, ret];\n  } catch (err) {\n    return [err, null];\n  }\n}\n\nexport function isBlob(obj: unknown): obj is Blob {\n  return typeof Blob !== 'undefined' && obj instanceof Blob;\n}\n\nexport function isBuffer(obj: unknown): obj is Buffer {\n  return typeof Buffer !== 'undefined' && obj instanceof Buffer;\n}\n\nexport function isReadable(obj: unknown): obj is NodeJS.ReadableStream {\n  if (process.env.TARGET_ENVIRONMENT !== 'node') {\n    return false;\n  }\n\n  return obj instanceof Readable;\n}\n\nexport function isValidNumber(v: number): v is number {\n  return !!v || v == 0;\n}\n\nexport function obj2QueryStr(v?: Record<string, unknown>) {\n  if (!v) {\n    return '';\n  }\n  return Object.keys(v)\n    .map((key) => {\n      const vStr = `${v[key]}`;\n      return `${encodeURIComponent(key)}=${encodeURIComponent(vStr)}`;\n    })\n    .join('&');\n}\n\nexport function isCancelError(err: any) {\n  return err instanceof CancelError;\n}\n\nexport const DEFAULT_PART_SIZE = 20 * 1024 * 1024; // 20 MB\n\nexport const getGMTDateStr = (v: Date) => {\n  return v.toUTCString();\n};\nconst gmtDateOrStr = (v: Date | string) => {\n  if (typeof v === 'string') {\n    return v;\n  }\n  return v.toUTCString();\n};\n\nexport const requestHeadersMap: Record<\n  string,\n  string | [string, (v: any) => string] | ((v: any) => Record<string, string>)\n> = {\n  projectName: 'x-tos-project-name',\n  encodingType: 'encoding-type',\n  cacheControl: 'cache-control',\n  contentDisposition: 'content-disposition',\n  contentLength: 'content-length',\n  contentMD5: 'content-md5',\n  contentSHA256: 'x-tos-content-sha256',\n  contentEncoding: 'content-encoding',\n  contentLanguage: 'content-language',\n  contentType: 'content-type',\n  expires: ['expires', getGMTDateStr],\n  range: 'range',\n\n  ifMatch: 'if-match',\n  ifModifiedSince: ['if-modified-since', gmtDateOrStr],\n  ifNoneMatch: 'if-none-match',\n  ifUnmodifiedSince: ['if-unmodified-since', gmtDateOrStr],\n\n  acl: 'x-tos-acl',\n  grantFullControl: 'x-tos-grant-full-control',\n  grantRead: 'x-tos-grant-read',\n  grantReadAcp: 'x-tos-grant-read-acp',\n  grantWrite: 'x-tos-grant-write',\n  grantWriteAcp: 'x-tos-grant-write-acp',\n\n  serverSideEncryption: 'x-tos-server-side-encryption',\n  serverSideDataEncryption: 'x-tos-server-side-data-encryption',\n  ssecAlgorithm: 'x-tos-server-side-encryption-customer-algorithm',\n  ssecKey: 'x-tos-server-side-encryption-customer-key',\n  ssecKeyMD5: 'x-tos-server-side-encryption-customer-key-md5',\n\n  copySourceRange: 'x-tos-copy-source-range',\n  copySourceIfMatch: 'x-tos-copy-source-if-match',\n  copySourceIfModifiedSince: [\n    'x-tos-copy-source-if-modified-since',\n    gmtDateOrStr,\n  ],\n  copySourceIfNoneMatch: 'x-tos-copy-source-if-none-match',\n  copySourceIfUnmodifiedSince: 'x-tos-copy-source-if-unmodified-since',\n  copySourceSSECAlgorithm:\n    'x-tos-copy-source-server-side-encryption-customer-algorithm',\n  copySourceSSECKey: 'x-tos-copy-source-server-side-encryption-customer-key',\n  copySourceSSECKeyMD5:\n    'x-tos-copy-source-server-side-encryption-customer-key-MD5',\n\n  metadataDirective: 'x-tos-metadata-directive',\n  meta: (v: any) => {\n    return Object.keys(v).reduce((prev, key) => {\n      prev[`x-tos-meta-${key}`] = `${v[key]}`;\n      return prev;\n    }, {} as Record<string, string>);\n  },\n  websiteRedirectLocation: 'x-tos-website-redirect-location',\n  storageClass: 'x-tos-storage-class',\n  azRedundancy: 'x-tos-az-redundancy',\n  trafficLimit: 'x-tos-traffic-limit',\n  callback: 'x-tos-callback',\n  callbackVar: 'x-tos-callback-var',\n  allowSameActionOverlap: ['x-tos-allow-same-action-overlap', (v) => String(v)],\n  symLinkTargetKey: 'x-tos-symlink-target',\n  symLinkTargetBucket: 'x-tos-symlink-bucket',\n  forbidOverwrite: 'x-tos-forbid-overwrite',\n  bucketType: 'x-tos-bucket-type',\n  recursiveMkdir: 'x-tos-recursive-mkdir',\n};\n// type RequestHeadersMapKeys = keyof typeof requestHeadersMap;\n\nexport const requestQueryMap: Record<\n  string,\n  string | [string, (v: any) => string] | ((v: any) => Record<string, string>)\n> = {\n  versionId: 'versionId',\n  process: 'x-tos-process',\n  saveBucket: 'x-tos-save-bucket',\n  saveObject: 'x-tos-save-object',\n\n  responseCacheControl: 'response-cache-control',\n  responseContentDisposition: 'response-content-disposition',\n  responseContentEncoding: 'response-content-encoding',\n  responseContentLanguage: 'response-content-language',\n  responseContentType: 'response-content-type',\n  responseExpires: ['response-expires', (v: Date) => v.toUTCString()],\n};\n\nexport function fillRequestHeaders<T extends { headers?: Headers }>(\n  v: T,\n  // keys: (keyof T & RequestHeadersMapKeys)[]\n  keys: (keyof T & string)[]\n) {\n  if (!keys.length) {\n    return;\n  }\n\n  const headers = v.headers || {};\n  v.headers = headers;\n\n  function setOneHeader(k: string, v: string) {\n    if (headers[k] == null) {\n      headers[k] = v;\n    }\n  }\n\n  keys.forEach((k) => {\n    const confV = requestHeadersMap[k];\n    if (!confV) {\n      // maybe warning\n      throw new TosClientError(\n        `\\`${k}\\` isn't in keys of \\`requestHeadersMap\\``\n      );\n    }\n\n    const oriValue = v[k];\n    if (oriValue == null) {\n      return;\n    }\n\n    const oriValueStr = `${oriValue}`;\n    if (typeof confV === 'string') {\n      return setOneHeader(confV, oriValueStr);\n    }\n\n    if (Array.isArray(confV)) {\n      const newKey = confV[0];\n      const newValue = confV[1](oriValue);\n      return setOneHeader(newKey, newValue);\n    }\n\n    const obj = confV(oriValue);\n    Object.entries(obj).forEach(([k, v]) => {\n      setOneHeader(k, v);\n    });\n  });\n}\n\nexport function fillRequestQuery<T>(\n  v: T,\n  query: Record<string, unknown>,\n  keys: (keyof T & string)[]\n) {\n  if (!keys.length) {\n    return;\n  }\n\n  function setOneKey(k: string, v: string) {\n    if (query[k] == null) {\n      query[k] = v;\n    }\n  }\n\n  keys.forEach((k) => {\n    const confV = requestQueryMap[k];\n    if (!confV) {\n      // maybe warning\n      throw new TosClientError(`\\`${k}\\` isn't in keys of \\`requestQueryMap\\``);\n    }\n\n    const oriValue = v[k];\n    if (oriValue == null) {\n      return;\n    }\n\n    const oriValueStr = `${oriValue}`;\n    if (typeof confV === 'string') {\n      return setOneKey(confV, oriValueStr);\n    }\n\n    if (Array.isArray(confV)) {\n      const newKey = confV[0];\n      const newValue = confV[1](oriValue);\n      return setOneKey(newKey, newValue);\n    }\n\n    const obj = confV(oriValue);\n    Object.entries(obj).forEach(([k, v]) => {\n      setOneKey(k, v);\n    });\n  });\n}\n\nexport const paramsSerializer = (params: Record<string, string>) => {\n  return qs.stringify(params);\n};\n\nexport function getNormalDataFromError<T>(\n  data: T,\n  err: TosServerError\n): TosResponse<T> {\n  return {\n    data,\n    statusCode: err.statusCode,\n    headers: err.headers,\n    requestId: err.requestId,\n    id2: err.id2,\n  };\n}\nexport const streamToBuf = async (\n  stream: NodeJS.ReadableStream\n): Promise<Buffer> => {\n  let buf = Buffer.from([]);\n  return new Promise((resolve, reject) => {\n    stream.on('data', (data) => {\n      buf = Buffer.concat([buf, data]);\n    });\n    stream.on('end', () => {\n      resolve(buf);\n    });\n    stream.on('error', (err) => {\n      reject(err);\n    });\n  });\n};\n\nexport function checkCRC64WithHeaders(crc: CRCCls | string, headers: Headers) {\n  const serverCRC64 = headers['x-tos-hash-crc64ecma'];\n  if (serverCRC64 == null) {\n    if (process.env.TARGET_ENVIRONMENT === 'browser') {\n      console.warn(\n        \"No x-tos-hash-crc64ecma in response's headers, please see https://www.volcengine.com/docs/6349/127737 to add `x-tos-hash-crc64ecma` to Expose-Headers field.\"\n      );\n    } else {\n    }\n    return;\n  }\n\n  const crcStr = typeof crc === 'string' ? crc : crc.getCrc64();\n  if (crcStr !== serverCRC64) {\n    throw new TosClientError(\n      `validate file crc64 failed. Expect crc64 ${serverCRC64}, actual crc64 ${crcStr}. Please try again.`\n    );\n  }\n}\n\nexport const bindStreamErrorHandler = (\n  stream:\n    | NodeJS.ReadableStream\n    | ReadStream\n    | NodeJS.WritableStream\n    | WriteStream,\n  prefix?: string\n) =>\n  stream.on('error', (err: any) => {\n    log.TOS('bindStreamErrorHandler: ', `${prefix || ''} stream error:`, err);\n  });\n\nexport enum HttpHeader {\n  LastModified = 'last-modified',\n  ContentLength = 'content-length',\n  AcceptEncoding = 'accept-encoding',\n  ContentEncoding = 'content-encoding',\n  ContentMD5 = 'content-md5',\n  TosRawContentLength = 'x-tos-raw-content-length',\n  TosTrailer = 'x-tos-trailer',\n  TosHashCrc64ecma = 'x-tos-hash-crc64ecma',\n  TosContentSha256 = 'x-tos-content-sha256',\n  TosDecodedContentLength = 'x-tos-decoded-content-length',\n  TosEc = 'x-tos-ec',\n  TosRequestId = 'x-tos-request-id',\n}\n\n/**\n * make async tasks serial\n * @param makeTask\n * @returns\n */\nexport const makeSerialAsyncTask = (makeTask: () => Promise<void>) => {\n  let lastTask = Promise.resolve();\n  return async () => {\n    lastTask = lastTask.then(() => makeTask());\n    return lastTask;\n  };\n};\n\nexport const safeParseCheckpointFile = async (filePath: string) => {\n  try {\n    return JSON.parse(await fsp.readFile(filePath, 'utf-8'));\n  } catch (err) {\n    console.warn(\"checkpoint's content is not a valid JSON\");\n    return undefined;\n  }\n};\n\nexport const makeRetryStreamAutoClose = (\n  makeStream: () => NodeJS.ReadableStream | ReadStream\n) => {\n  let lastStream: ReadStream | NodeJS.ReadableStream | null = null;\n  const makeRetryStream = () => {\n    if (lastStream) {\n      bindStreamErrorHandler(lastStream, 'retry new stream');\n\n      tryDestroy(\n        lastStream,\n        new Error('retry new stream by makeRetryStreamAutoClose')\n      );\n    }\n\n    lastStream = makeStream();\n    return lastStream;\n  };\n\n  return {\n    getLastStream: () => lastStream,\n    make: makeRetryStream,\n  };\n};\n\nexport const tryDestroy = (\n  stream:\n    | NodeJS.ReadableStream\n    | ReadStream\n    | NodeJS.WritableStream\n    | WriteStream\n    | null\n    | undefined,\n  err: any\n) => {\n  if (stream && 'destroy' in stream && typeof stream.destroy === 'function') {\n    if ('destroyed' in stream && !stream.destroyed) {\n      stream.destroy(err);\n    }\n  }\n};\nexport const pipeStreamWithErrorHandle = <\n  Src extends NodeJS.ReadableStream | ReadStream,\n  Dest extends NodeJS.WritableStream | WriteStream\n>(\n  src: Src,\n  dest: Dest,\n  label: string\n): Dest => {\n  bindStreamErrorHandler(dest, label);\n  src.on('error', (err) => tryDestroy(dest, err));\n  dest.on('error', (err) => tryDestroy(src, err));\n  return src.pipe(dest) as Dest;\n};\n\nexport const isValidBucketName = (bucket: string, isCustomDomain?: boolean) => {\n  if (isCustomDomain) {\n    return;\n  }\n\n  if (bucket) {\n    if (bucket.length < 3 || bucket.length > 63) {\n      throw new TosClientError(\n        'invalid bucket name, the length must be [3, 63]'\n      );\n    }\n    if (!/^([a-z]|-|\\d)+$/.test(bucket)) {\n      throw new TosClientError(\n        'invalid bucket name, the character set is illegal'\n      );\n    }\n    if (/^-/.test(bucket) || /-$/.test(bucket)) {\n      throw new TosClientError(\n        `invalid bucket name, the bucket name can be neither starting with '-' nor ending with '-'`\n      );\n    }\n  }\n\n}","import TOSBase from '../../base';\nimport { fillRequestHeaders, normalizeHeadersKey } from '../../../utils';\nimport { Acl } from '../../../interface';\nimport { StorageClassType } from '../../../TosExportEnum';\n\nexport interface CreateMultipartUploadInput {\n  bucket?: string;\n  key: string;\n\n  encodingType?: string;\n  cacheControl?: string;\n  contentDisposition?: string;\n  contentEncoding?: string;\n  contentLanguage?: string;\n  contentType?: string;\n  expires?: Date;\n\n  acl?: Acl;\n  grantFullControl?: string;\n  grantRead?: string;\n  grantReadAcp?: string;\n  grantWriteAcp?: string;\n\n  ssecAlgorithm?: string;\n  ssecKey?: string;\n  ssecKeyMD5?: string;\n\n  serverSideEncryption?: string;\n  /** @private unstable */\n  serverSideDataEncryption?: string;\n\n  meta?: Record<string, string>;\n  websiteRedirectLocation?: string;\n  storageClass?: StorageClassType;\n  forbidOverwrite?: boolean;\n\n  headers?: {\n    [key: string]: string | undefined;\n    'encoding-type'?: string;\n    'Content-Disposition'?: string;\n    'x-tos-acl'?: Acl;\n    'content-type'?: string;\n    'x-tos-grant-full-control'?: string;\n    'x-tos-grant-read'?: string;\n    'x-tos-grant-read-acp'?: string;\n    'x-tos-grant-write-acp'?: string;\n    'x-tos-server-side-encryption-customer-algorithm'?: string;\n    'x-tos-server-side-encryption-customer-key'?: string;\n    'x-tos-server-side-encryption-customer-key-md5'?: string;\n    'x-tos-website-redirect-location'?: string;\n    'x-tos-storage-class'?: string;\n    'x-tos-server-side-encryption'?: string;\n    ['x-tos-forbid-overwrite']?: string;\n  };\n}\n\nexport interface CreateMultipartUploadOutput {\n  UploadId: string;\n  Bucket: string;\n  Key: string;\n  EncodingType?: string;\n}\n\nexport async function createMultipartUpload(\n  this: TOSBase,\n  input: CreateMultipartUploadInput | string\n) {\n  input = this.normalizeObjectInput(input);\n  const headers = normalizeHeadersKey(input.headers);\n  input.headers = headers;\n  fillRequestHeaders(input, [\n    'encodingType',\n    'cacheControl',\n    'contentDisposition',\n    'contentEncoding',\n    'contentLanguage',\n    'contentType',\n    'expires',\n\n    'acl',\n    'grantFullControl',\n    'grantRead',\n    'grantReadAcp',\n    'grantWriteAcp',\n\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n    'serverSideEncryption',\n    'serverSideDataEncryption',\n\n    'meta',\n    'websiteRedirectLocation',\n    'storageClass',\n    'forbidOverwrite',\n  ]);\n\n  this.setObjectContentTypeHeader(input, headers);\n\n  return this._fetchObject<CreateMultipartUploadOutput>(\n    input,\n    'POST',\n    { uploads: '' },\n    headers,\n    ''\n  );\n}\n","import { covertCamelCase2Kebab, makeArrayProp } from '../../../utils';\nimport TOSBase from '../../base';\n\ninterface ListPartInput {\n  bucket?: string;\n  key: string;\n  uploadId: string;\n  maxParts?: number;\n  partNumberMarker?: number;\n  encodingType?: string;\n}\n\ninterface ListPartOutput {\n  Bucket: string;\n  Key: string;\n  UploadId: string;\n  PartNumberMarker: number;\n  NextPartNumberMarker: number;\n  MaxParts: number;\n  IsTruncated: boolean;\n  StorageClass: string;\n  Owner: { ID: string; DisplayName: string };\n  Parts: {\n    PartNumber: number;\n    LastModified: string;\n    ETag: string;\n    Size: number;\n  }[];\n}\n\n// the part except last one must be >= 5 MB\n// the last part is no size limit\nexport const MIN_PART_SIZE_EXCEPT_LAST_ONE = 5 * 1024 * 1024;\nexport const MAX_PART_NUMBER = 10000;\n\nexport const calculateSafePartSize = (\n  totalSize: number,\n  expectPartSize: number,\n  showWarning = false\n) => {\n  let partSize = expectPartSize;\n  if (expectPartSize < MIN_PART_SIZE_EXCEPT_LAST_ONE) {\n    partSize = MIN_PART_SIZE_EXCEPT_LAST_ONE;\n    if (showWarning) {\n      console.warn(\n        `partSize has been set to ${partSize}, because the partSize you provided is less than the minimal size of multipart`\n      );\n    }\n  }\n  const minSize = Math.ceil(totalSize / MAX_PART_NUMBER);\n  if (expectPartSize < minSize) {\n    partSize = minSize;\n    if (showWarning) {\n      console.warn(\n        `partSize has been set to ${partSize}, because the partSize you provided causes the number of part excesses 10,000`\n      );\n    }\n  }\n\n  return partSize;\n};\n\nexport async function listParts(this: TOSBase, input: ListPartInput) {\n  const { bucket, key, uploadId, ...nextQuery } = input;\n  const ret = await this._fetchObject<ListPartOutput>(\n    input,\n    'GET',\n    {\n      uploadId,\n      ...covertCamelCase2Kebab(nextQuery),\n    },\n    {}\n  );\n  const arrayProp = makeArrayProp(ret.data);\n  arrayProp('Parts');\n\n  return ret;\n}\n","// alias with GoSDK\n// refer https://github.com/volcengine/ve-tos-golang-sdk/blob/main/tos/mime.go\nexport const mimeTypes: Record<string, string | undefined> = {\n  '3gp': 'video/3gpp',\n  '7z': 'application/x-7z-compressed',\n  abw: 'application/x-abiword',\n  ai: 'application/postscript',\n  aif: 'audio/x-aiff',\n  aifc: 'audio/x-aiff',\n  aiff: 'audio/x-aiff',\n  alc: 'chemical/x-alchemy',\n  amr: 'audio/amr',\n  anx: 'application/annodex',\n  apk: 'application/vnd.android.package-archive',\n  appcache: 'text/cache-manifest',\n  art: 'image/x-jg',\n  asc: 'text/plain',\n  asf: 'video/x-ms-asf',\n  aso: 'chemical/x-ncbi-asn1-binary',\n  asx: 'video/x-ms-asf',\n  atom: 'application/atom+xml',\n  atomcat: 'application/atomcat+xml',\n  atomsrv: 'application/atomserv+xml',\n  au: 'audio/basic',\n  avi: 'video/x-msvideo',\n  awb: 'audio/amr-wb',\n  axa: 'audio/annodex',\n  axv: 'video/annodex',\n  b: 'chemical/x-molconn-Z',\n  bak: 'application/x-trash',\n  bat: 'application/x-msdos-program',\n  bcpio: 'application/x-bcpio',\n  bib: 'text/x-bibtex',\n  bin: 'application/octet-stream',\n  bmp: 'image/x-ms-bmp',\n  boo: 'text/x-boo',\n  book: 'application/x-maker',\n  brf: 'text/plain',\n  bsd: 'chemical/x-crossfire',\n  c: 'text/x-csrc',\n  'c++': 'text/x-c++src',\n  c3d: 'chemical/x-chem3d',\n  cab: 'application/x-cab',\n  cac: 'chemical/x-cache',\n  cache: 'chemical/x-cache',\n  cap: 'application/vnd.tcpdump.pcap',\n  cascii: 'chemical/x-cactvs-binary',\n  cat: 'application/vnd.ms-pki.seccat',\n  cbin: 'chemical/x-cactvs-binary',\n  cbr: 'application/x-cbr',\n  cbz: 'application/x-cbz',\n  cc: 'text/x-c++src',\n  cda: 'application/x-cdf',\n  cdf: 'application/x-cdf',\n  cdr: 'image/x-coreldraw',\n  cdt: 'image/x-coreldrawtemplate',\n  cdx: 'chemical/x-cdx',\n  cdy: 'application/vnd.cinderella',\n  cef: 'chemical/x-cxf',\n  cer: 'chemical/x-cerius',\n  chm: 'chemical/x-chemdraw',\n  chrt: 'application/x-kchart',\n  cif: 'chemical/x-cif',\n  class: 'application/java-vm',\n  cls: 'text/x-tex',\n  cmdf: 'chemical/x-cmdf',\n  cml: 'chemical/x-cml',\n  cod: 'application/vnd.rim.cod',\n  com: 'application/x-msdos-program',\n  cpa: 'chemical/x-compass',\n  cpio: 'application/x-cpio',\n  cpp: 'text/x-c++src',\n  cpt: 'application/mac-compactpro',\n  cr2: 'image/x-canon-cr2',\n  crl: 'application/x-pkcs7-crl',\n  crt: 'application/x-x509-ca-cert',\n  crw: 'image/x-canon-crw',\n  csd: 'audio/csound',\n  csf: 'chemical/x-cache-csf',\n  csh: 'application/x-csh',\n  csm: 'chemical/x-csml',\n  csml: 'chemical/x-csml',\n  css: 'text/css',\n  csv: 'text/csv',\n  ctab: 'chemical/x-cactvs-binary',\n  ctx: 'chemical/x-ctx',\n  cu: 'application/cu-seeme',\n  cub: 'chemical/x-gaussian-cube',\n  cxf: 'chemical/x-cxf',\n  cxx: 'text/x-c++src',\n  d: 'text/x-dsrc',\n  davmount: 'application/davmount+xml',\n  dcm: 'application/dicom',\n  dcr: 'application/x-director',\n  ddeb: 'application/vnd.debian.binary-package',\n  dif: 'video/dv',\n  diff: 'text/x-diff',\n  dir: 'application/x-director',\n  djv: 'image/vnd.djvu',\n  djvu: 'image/vnd.djvu',\n  dl: 'video/dl',\n  dll: 'application/x-msdos-program',\n  dmg: 'application/x-apple-diskimage',\n  dms: 'application/x-dms',\n  doc: 'application/msword',\n  docm: 'application/vnd.ms-word.document.macroEnabled.12',\n  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  dot: 'application/msword',\n  dotm: 'application/vnd.ms-word.template.macroEnabled.12',\n  dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n  dv: 'video/dv',\n  dvi: 'application/x-dvi',\n  dx: 'chemical/x-jcamp-dx',\n  dxr: 'application/x-director',\n  emb: 'chemical/x-embl-dl-nucleotide',\n  embl: 'chemical/x-embl-dl-nucleotide',\n  eml: 'message/rfc822',\n  eot: 'application/vnd.ms-fontobject',\n  eps: 'application/postscript',\n  eps2: 'application/postscript',\n  eps3: 'application/postscript',\n  epsf: 'application/postscript',\n  epsi: 'application/postscript',\n  erf: 'image/x-epson-erf',\n  es: 'application/ecmascript',\n  etx: 'text/x-setext',\n  exe: 'application/x-msdos-program',\n  ez: 'application/andrew-inset',\n  fb: 'application/x-maker',\n  fbdoc: 'application/x-maker',\n  fch: 'chemical/x-gaussian-checkpoint',\n  fchk: 'chemical/x-gaussian-checkpoint',\n  fig: 'application/x-xfig',\n  flac: 'audio/flac',\n  fli: 'video/fli',\n  flv: 'video/x-flv',\n  fm: 'application/x-maker',\n  frame: 'application/x-maker',\n  frm: 'application/x-maker',\n  gal: 'chemical/x-gaussian-log',\n  gam: 'chemical/x-gamess-input',\n  gamin: 'chemical/x-gamess-input',\n  gan: 'application/x-ganttproject',\n  gau: 'chemical/x-gaussian-input',\n  gcd: 'text/x-pcs-gcd',\n  gcf: 'application/x-graphing-calculator',\n  gcg: 'chemical/x-gcg8-sequence',\n  gen: 'chemical/x-genbank',\n  gf: 'application/x-tex-gf',\n  gif: 'image/gif',\n  gjc: 'chemical/x-gaussian-input',\n  gjf: 'chemical/x-gaussian-input',\n  gl: 'video/gl',\n  gnumeric: 'application/x-gnumeric',\n  gpt: 'chemical/x-mopac-graph',\n  gsf: 'application/x-font',\n  gsm: 'audio/x-gsm',\n  gtar: 'application/x-gtar',\n  gz: 'application/gzip',\n  h: 'text/x-chdr',\n  'h++': 'text/x-c++hdr',\n  hdf: 'application/x-hdf',\n  hh: 'text/x-c++hdr',\n  hin: 'chemical/x-hin',\n  hpp: 'text/x-c++hdr',\n  hqx: 'application/mac-binhex40',\n  hs: 'text/x-haskell',\n  hta: 'application/hta',\n  htc: 'text/x-component',\n  htm: 'text/html',\n  html: 'text/html',\n  hwp: 'application/x-hwp',\n  hxx: 'text/x-c++hdr',\n  ica: 'application/x-ica',\n  ice: 'x-conference/x-cooltalk',\n  ico: 'image/vnd.microsoft.icon',\n  ics: 'text/calendar',\n  icz: 'text/calendar',\n  ief: 'image/ief',\n  iges: 'model/iges',\n  igs: 'model/iges',\n  iii: 'application/x-iphone',\n  info: 'application/x-info',\n  inp: 'chemical/x-gamess-input',\n  ins: 'application/x-internet-signup',\n  iso: 'application/x-iso9660-image',\n  isp: 'application/x-internet-signup',\n  ist: 'chemical/x-isostar',\n  istr: 'chemical/x-isostar',\n  jad: 'text/vnd.sun.j2me.app-descriptor',\n  jam: 'application/x-jam',\n  jar: 'application/java-archive',\n  java: 'text/x-java',\n  jdx: 'chemical/x-jcamp-dx',\n  jmz: 'application/x-jmol',\n  jng: 'image/x-jng',\n  jnlp: 'application/x-java-jnlp-file',\n  jp2: 'image/jp2',\n  jpe: 'image/jpeg',\n  jpeg: 'image/jpeg',\n  jpf: 'image/jpx',\n  jpg: 'image/jpeg',\n  jpg2: 'image/jp2',\n  jpm: 'image/jpm',\n  jpx: 'image/jpx',\n  js: 'application/javascript',\n  json: 'application/json',\n  kar: 'audio/midi',\n  key: 'application/pgp-keys',\n  kil: 'application/x-killustrator',\n  kin: 'chemical/x-kinemage',\n  kml: 'application/vnd.google-earth.kml+xml',\n  kmz: 'application/vnd.google-earth.kmz',\n  kpr: 'application/x-kpresenter',\n  kpt: 'application/x-kpresenter',\n  ksp: 'application/x-kspread',\n  kwd: 'application/x-kword',\n  kwt: 'application/x-kword',\n  latex: 'application/x-latex',\n  lha: 'application/x-lha',\n  lhs: 'text/x-literate-haskell',\n  lin: 'application/bbolin',\n  lsf: 'video/x-la-asf',\n  lsx: 'video/x-la-asf',\n  ltx: 'text/x-tex',\n  ly: 'text/x-lilypond',\n  lyx: 'application/x-lyx',\n  lzh: 'application/x-lzh',\n  lzx: 'application/x-lzx',\n  m3g: 'application/m3g',\n  m3u: 'audio/x-mpegurl',\n  m3u8: 'application/x-mpegURL',\n  m4a: 'audio/mpeg',\n  maker: 'application/x-maker',\n  man: 'application/x-troff-man',\n  mbox: 'application/mbox',\n  mcif: 'chemical/x-mmcif',\n  mcm: 'chemical/x-macmolecule',\n  mdb: 'application/msaccess',\n  me: 'application/x-troff-me',\n  mesh: 'model/mesh',\n  mid: 'audio/midi',\n  midi: 'audio/midi',\n  mif: 'application/x-mif',\n  mkv: 'video/x-matroska',\n  mm: 'application/x-freemind',\n  mmd: 'chemical/x-macromodel-input',\n  mmf: 'application/vnd.smaf',\n  mml: 'text/mathml',\n  mmod: 'chemical/x-macromodel-input',\n  mng: 'video/x-mng',\n  moc: 'text/x-moc',\n  mol: 'chemical/x-mdl-molfile',\n  mol2: 'chemical/x-mol2',\n  moo: 'chemical/x-mopac-out',\n  mop: 'chemical/x-mopac-input',\n  mopcrt: 'chemical/x-mopac-input',\n  mov: 'video/quicktime',\n  movie: 'video/x-sgi-movie',\n  mp2: 'audio/mpeg',\n  mp3: 'audio/mpeg',\n  mp4: 'video/mp4',\n  mpc: 'chemical/x-mopac-input',\n  mpe: 'video/mpeg',\n  mpeg: 'video/mpeg',\n  mpega: 'audio/mpeg',\n  mpg: 'video/mpeg',\n  mpga: 'audio/mpeg',\n  mph: 'application/x-comsol',\n  mpv: 'video/x-matroska',\n  ms: 'application/x-troff-ms',\n  msh: 'model/mesh',\n  msi: 'application/x-msi',\n  mvb: 'chemical/x-mopac-vib',\n  mxf: 'application/mxf',\n  mxu: 'video/vnd.mpegurl',\n  nb: 'application/mathematica',\n  nbp: 'application/mathematica',\n  nc: 'application/x-netcdf',\n  nef: 'image/x-nikon-nef',\n  nwc: 'application/x-nwc',\n  o: 'application/x-object',\n  oda: 'application/oda',\n  odb: 'application/vnd.oasis.opendocument.database',\n  odc: 'application/vnd.oasis.opendocument.chart',\n  odf: 'application/vnd.oasis.opendocument.formula',\n  odg: 'application/vnd.oasis.opendocument.graphics',\n  odi: 'application/vnd.oasis.opendocument.image',\n  odm: 'application/vnd.oasis.opendocument.text-master',\n  odp: 'application/vnd.oasis.opendocument.presentation',\n  ods: 'application/vnd.oasis.opendocument.spreadsheet',\n  odt: 'application/vnd.oasis.opendocument.text',\n  oga: 'audio/ogg',\n  ogg: 'audio/ogg',\n  ogv: 'video/ogg',\n  ogx: 'application/ogg',\n  old: 'application/x-trash',\n  one: 'application/onenote',\n  onepkg: 'application/onenote',\n  onetmp: 'application/onenote',\n  onetoc2: 'application/onenote',\n  opf: 'application/oebps-package+xml',\n  opus: 'audio/ogg',\n  orc: 'audio/csound',\n  orf: 'image/x-olympus-orf',\n  otf: 'application/font-sfnt',\n  otg: 'application/vnd.oasis.opendocument.graphics-template',\n  oth: 'application/vnd.oasis.opendocument.text-web',\n  otp: 'application/vnd.oasis.opendocument.presentation-template',\n  ots: 'application/vnd.oasis.opendocument.spreadsheet-template',\n  ott: 'application/vnd.oasis.opendocument.text-template',\n  oza: 'application/x-oz-application',\n  p: 'text/x-pascal',\n  p7r: 'application/x-pkcs7-certreqresp',\n  pac: 'application/x-ns-proxy-autoconfig',\n  pas: 'text/x-pascal',\n  pat: 'image/x-coreldrawpattern',\n  patch: 'text/x-diff',\n  pbm: 'image/x-portable-bitmap',\n  pcap: 'application/vnd.tcpdump.pcap',\n  pcf: 'application/x-font-pcf',\n  'pcf.Z': 'application/x-font-pcf',\n  pcx: 'image/pcx',\n  pdb: 'chemical/x-pdb',\n  pdf: 'application/pdf',\n  pfa: 'application/x-font',\n  pfb: 'application/x-font',\n  pfr: 'application/font-tdpfr',\n  pgm: 'image/x-portable-graymap',\n  pgn: 'application/x-chess-pgn',\n  pgp: 'application/pgp-encrypted',\n  php: '#application/x-httpd-php',\n  php3: '#application/x-httpd-php3',\n  php3p: '#application/x-httpd-php3-preprocessed',\n  php4: '#application/x-httpd-php4',\n  php5: '#application/x-httpd-php5',\n  phps: '#application/x-httpd-php-source',\n  pht: '#application/x-httpd-php',\n  phtml: '#application/x-httpd-php',\n  pk: 'application/x-tex-pk',\n  pl: 'text/x-perl',\n  pls: 'audio/x-scpls',\n  pm: 'text/x-perl',\n  png: 'image/png',\n  pnm: 'image/x-portable-anymap',\n  pot: 'text/plain',\n  potm: 'application/vnd.ms-powerpoint.template.macroEnabled.12',\n  potx: 'application/vnd.openxmlformats-officedocument.presentationml.template',\n  ppam: 'application/vnd.ms-powerpoint.addin.macroEnabled.12',\n  ppm: 'image/x-portable-pixmap',\n  pps: 'application/vnd.ms-powerpoint',\n  ppsm: 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',\n  ppsx: 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n  ppt: 'application/vnd.ms-powerpoint',\n  pptm: 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',\n  pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n  prf: 'application/pics-rules',\n  prt: 'chemical/x-ncbi-asn1-ascii',\n  ps: 'application/postscript',\n  psd: 'image/x-photoshop',\n  py: 'text/x-python',\n  pyc: 'application/x-python-code',\n  pyo: 'application/x-python-code',\n  qgs: 'application/x-qgis',\n  qt: 'video/quicktime',\n  qtl: 'application/x-quicktimeplayer',\n  ra: 'audio/x-pn-realaudio',\n  ram: 'audio/x-pn-realaudio',\n  rar: 'application/rar',\n  ras: 'image/x-cmu-raster',\n  rb: 'application/x-ruby',\n  rd: 'chemical/x-mdl-rdfile',\n  rdf: 'application/rdf+xml',\n  rdp: 'application/x-rdp',\n  rgb: 'image/x-rgb',\n  rhtml: '#application/x-httpd-eruby',\n  rm: 'audio/x-pn-realaudio',\n  roff: 'application/x-troff',\n  ros: 'chemical/x-rosdal',\n  rpm: 'application/x-redhat-package-manager',\n  rss: 'application/x-rss+xml',\n  rtf: 'application/rtf',\n  rtx: 'text/richtext',\n  rxn: 'chemical/x-mdl-rxnfile',\n  scala: 'text/x-scala',\n  sce: 'application/x-scilab',\n  sci: 'application/x-scilab',\n  sco: 'audio/csound',\n  scr: 'application/x-silverlight',\n  sct: 'text/scriptlet',\n  sd: 'chemical/x-mdl-sdfile',\n  sd2: 'audio/x-sd2',\n  sda: 'application/vnd.stardivision.draw',\n  sdc: 'application/vnd.stardivision.calc',\n  sdd: 'application/vnd.stardivision.impress',\n  sds: 'application/vnd.stardivision.chart',\n  sdw: 'application/vnd.stardivision.writer',\n  ser: 'application/java-serialized-object',\n  sfd: 'application/vnd.font-fontforge-sfd',\n  sfv: 'text/x-sfv',\n  sgf: 'application/x-go-sgf',\n  sgl: 'application/vnd.stardivision.writer-global',\n  sh: 'application/x-sh',\n  shar: 'application/x-shar',\n  shp: 'application/x-qgis',\n  shtml: 'text/html',\n  shx: 'application/x-qgis',\n  sid: 'audio/prs.sid',\n  sig: 'application/pgp-signature',\n  sik: 'application/x-trash',\n  silo: 'model/mesh',\n  sis: 'application/vnd.symbian.install',\n  sisx: 'x-epoc/x-sisx-app',\n  sit: 'application/x-stuffit',\n  sitx: 'application/x-stuffit',\n  skd: 'application/x-koan',\n  skm: 'application/x-koan',\n  skp: 'application/x-koan',\n  skt: 'application/x-koan',\n  sldm: 'application/vnd.ms-powerpoint.slide.macroEnabled.12',\n  sldx: 'application/vnd.openxmlformats-officedocument.presentationml.slide',\n  smi: 'application/smil+xml',\n  smil: 'application/smil+xml',\n  snd: 'audio/basic',\n  spc: 'chemical/x-galactic-spc',\n  spl: 'application/x-futuresplash',\n  spx: 'audio/ogg',\n  sql: 'application/x-sql',\n  src: 'application/x-wais-source',\n  srt: 'text/plain',\n  stc: 'application/vnd.sun.xml.calc.template',\n  std: 'application/vnd.sun.xml.draw.template',\n  sti: 'application/vnd.sun.xml.impress.template',\n  stw: 'application/vnd.sun.xml.writer.template',\n  sty: 'text/x-tex',\n  sv4cpio: 'application/x-sv4cpio',\n  sv4crc: 'application/x-sv4crc',\n  svg: 'image/svg+xml',\n  svgz: 'image/svg+xml',\n  sw: 'chemical/x-swissprot',\n  swf: 'application/x-shockwave-flash',\n  swfl: 'application/x-shockwave-flash',\n  sxc: 'application/vnd.sun.xml.calc',\n  sxd: 'application/vnd.sun.xml.draw',\n  sxg: 'application/vnd.sun.xml.writer.global',\n  sxi: 'application/vnd.sun.xml.impress',\n  sxm: 'application/vnd.sun.xml.math',\n  sxw: 'application/vnd.sun.xml.writer',\n  t: 'application/x-troff',\n  tar: 'application/x-tar',\n  taz: 'application/x-gtar-compressed',\n  tcl: 'application/x-tcl',\n  tex: 'text/x-tex',\n  texi: 'application/x-texinfo',\n  texinfo: 'application/x-texinfo',\n  text: 'text/plain',\n  tgf: 'chemical/x-mdl-tgf',\n  tgz: 'application/x-gtar-compressed',\n  thmx: 'application/vnd.ms-officetheme',\n  tif: 'image/tiff',\n  tiff: 'image/tiff',\n  tk: 'text/x-tcl',\n  tm: 'text/texmacs',\n  torrent: 'application/x-bittorrent',\n  tr: 'application/x-troff',\n  ts: 'video/MP2T',\n  tsp: 'application/dsptype',\n  tsv: 'text/tab-separated-values',\n  ttf: 'application/font-sfnt',\n  ttl: 'text/turtle',\n  txt: 'text/plain',\n  uls: 'text/iuls',\n  ustar: 'application/x-ustar',\n  val: 'chemical/x-ncbi-asn1-binary',\n  vcard: 'text/vcard',\n  vcd: 'application/x-cdlink',\n  vcf: 'text/vcard',\n  vcs: 'text/x-vcalendar',\n  vmd: 'chemical/x-vmd',\n  vms: 'chemical/x-vamas-iso14976',\n  vrm: 'x-world/x-vrml',\n  vrml: 'model/vrml',\n  vsd: 'application/vnd.visio',\n  vss: 'application/vnd.visio',\n  vst: 'application/vnd.visio',\n  vsw: 'application/vnd.visio',\n  wad: 'application/x-doom',\n  wasm: 'application/wasm',\n  wav: 'audio/wav',\n  wax: 'audio/x-ms-wax',\n  wbmp: 'image/vnd.wap.wbmp',\n  wbxml: 'application/vnd.wap.wbxml',\n  webm: 'video/webm',\n  wk: 'application/x-123',\n  wm: 'video/x-ms-wm',\n  wma: 'audio/x-ms-wma',\n  wmd: 'application/x-ms-wmd',\n  wml: 'text/vnd.wap.wml',\n  wmlc: 'application/vnd.wap.wmlc',\n  wmls: 'text/vnd.wap.wmlscript',\n  wmlsc: 'application/vnd.wap.wmlscriptc',\n  wmv: 'video/x-ms-wmv',\n  wmx: 'video/x-ms-wmx',\n  wmz: 'application/x-ms-wmz',\n  woff: 'application/font-woff',\n  wp5: 'application/vnd.wordperfect5.1',\n  wpd: 'application/vnd.wordperfect',\n  wrl: 'model/vrml',\n  wsc: 'text/scriptlet',\n  wvx: 'video/x-ms-wvx',\n  wz: 'application/x-wingz',\n  x3d: 'model/x3d+xml',\n  x3db: 'model/x3d+binary',\n  x3dv: 'model/x3d+vrml',\n  xbm: 'image/x-xbitmap',\n  xcf: 'application/x-xcf',\n  xcos: 'application/x-scilab-xcos',\n  xht: 'application/xhtml+xml',\n  xhtml: 'application/xhtml+xml',\n  xlam: 'application/vnd.ms-excel.addin.macroEnabled.12',\n  xlb: 'application/vnd.ms-excel',\n  xls: 'application/vnd.ms-excel',\n  xlsb: 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',\n  xlsm: 'application/vnd.ms-excel.sheet.macroEnabled.12',\n  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n  xlt: 'application/vnd.ms-excel',\n  xltm: 'application/vnd.ms-excel.template.macroEnabled.12',\n  xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n  xml: 'application/xml',\n  xpi: 'application/x-xpinstall',\n  xpm: 'image/x-xpixmap',\n  xsd: 'application/xml',\n  xsl: 'application/xslt+xml',\n  xslt: 'application/xslt+xml',\n  xspf: 'application/xspf+xml',\n  xtel: 'chemical/x-xtel',\n  xul: 'application/vnd.mozilla.xul+xml',\n  xwd: 'image/x-xwindowdump',\n  xyz: 'chemical/x-xyz',\n  xz: 'application/x-xz',\n  zip: 'application/zip',\n};\n\nexport default mimeTypes;\n","import { Transform } from 'stream';\nimport { pipeStreamWithErrorHandle } from '../utils';\n\nfunction createReadNCbTransformer(readCb: (n: number) => void) {\n  return new Transform({\n    async transform(chunk, _encoding, callback) {\n      const chunkSize = chunk.length;\n      readCb(chunkSize);\n      this.push(chunk);\n      callback();\n    },\n  });\n}\n\nexport function createReadNReadStream(\n  stream: NodeJS.ReadableStream,\n  readCb: (n: number) => void\n) {\n  const readCbTransformer = createReadNCbTransformer(readCb);\n  return pipeStreamWithErrorHandle(\n    stream,\n    readCbTransformer,\n    'createReadNReadStream'\n  );\n\n  /**\n   * Don't use the below code.\n   *\n   * 1. The readable stream will be flowing mode after adding a 'data' event listener to it.\n   * 2. The stream will be paused after calling `pause()` method.\n   * 3. The stream will not change to flowing mode when adding a 'data' event listener to it.\n   */\n  // stream.on('data', (d) => {\n  //   readCb(d.length);\n  // });\n  // stream.pause();\n}\n","import * as browserCRC from './crc.browser';\nimport * as nodejsCRC from '../nodejs/crc.node';\n\ntype CRCModule = typeof nodejsCRC;\nexport type CRCCls = nodejsCRC.CRC;\nlet crcModule = null as unknown as CRCModule;\n\nif (process.env.TARGET_ENVIRONMENT === 'node') {\n  crcModule = nodejsCRC;\n} else {\n  crcModule = browserCRC as unknown as CRCModule;\n}\n\nconst { CRC, combineCrc64 } = crcModule;\nexport { CRC, combineCrc64 };\n","import TosClientError from '../TosClientError';\nimport { crc64 } from 'tos-crc64-js';\nexport { combineCrc64 } from 'tos-crc64-js';\n\nexport class CRC {\n  private value = '0';\n\n  reset() {\n    this.value = '0';\n  }\n\n  async updateBlob(): Promise<string> {\n    throw new TosClientError('Not implemented in node.js environment.');\n  }\n\n  update(value: Buffer): string {\n    this.value = crc64(value, this.value);\n    return this.value;\n  }\n\n  getCrc64(): string {\n    return this.value;\n  }\n}\n","import { Readable, Transform } from 'stream';\nimport { pipeStreamWithErrorHandle } from '../utils';\nimport { IRateLimiter } from '../interface';\n\nexport interface DefaultRateLimiter {\n  rate: number;\n  capacity: number;\n  currentAmount: number;\n  lastConsumeTime: number;\n}\n\nconst minRate = 1024;\nconst minCapacity = 10 * 1024;\n\n/**\n *\n * @param capacity  minValue 10KB. unit byte\n * @param rate   minValue 1KB. unit byte/s\n * @returns\n */\nexport function createDefaultRateLimiter(\n  capacity: number,\n  rate: number\n): IRateLimiter {\n  const realCapacity = Math.max(minCapacity, capacity);\n  const realRate = Math.max(minRate, rate);\n  const d: DefaultRateLimiter = {\n    rate: realRate,\n    capacity: realCapacity,\n    currentAmount: realCapacity,\n    lastConsumeTime: Date.now(),\n  };\n\n  return {\n    Acquire: async (want) => {\n      if (want > d.capacity) {\n        want = d.capacity;\n      }\n\n      const now = Date.now();\n      const increment = Math.floor(((now - d.lastConsumeTime) / 1000) * d.rate);\n\n      if (increment + d.currentAmount > d.capacity) {\n        d.currentAmount = d.capacity;\n      } else {\n        d.currentAmount += increment;\n      }\n\n      if (want > d.currentAmount) {\n        const timeToWaitSec = (want - d.currentAmount) / d.rate;\n\n        return { ok: false, timeToWait: Math.ceil(timeToWaitSec * 1000) };\n      }\n\n      d.lastConsumeTime = now;\n      d.currentAmount = d.currentAmount - want;\n\n      return {\n        ok: true,\n        timeToWait: 0,\n      };\n    },\n  };\n}\n\nfunction createRateLimiterTransform(rateLimiter: IRateLimiter) {\n  return new Transform({\n    async transform(chunk, _encoding, callback) {\n      try {\n        const chunkSize = chunk.length;\n        let finished = false;\n        while (!finished) {\n          const { ok, timeToWait } = await rateLimiter.Acquire(chunkSize);\n\n          if (!ok) {\n            await wait(timeToWait);\n          }\n          finished = ok;\n        }\n\n        this.push(chunk);\n        callback();\n      } catch (error: any) {\n        callback(error);\n      }\n    },\n  });\n}\n\nexport function createRateLimiterStream(\n  stream: NodeJS.ReadableStream | Readable,\n  rateLimiter: IRateLimiter\n) {\n  const pipeRateLimit = createRateLimiterTransform(rateLimiter);\n\n  return pipeStreamWithErrorHandle(\n    stream,\n    pipeRateLimit,\n    'createRateLimiterStream'\n  );\n}\n\nexport function wait(milliseconds: number) {\n  return new Promise((r) => {\n    setTimeout(() => r(''), milliseconds);\n  });\n}\n","import * as moduleBrowser from './rate-limiter.browser';\nimport * as moduleNode from '../nodejs/rate-limiter';\nimport { IRateLimiter } from '../interface';\n\ninterface RateLimiterModule {\n  createDefaultRateLimiter(capacity: number, rate: number): IRateLimiter;\n  createRateLimiterStream(\n    stream: NodeJS.ReadableStream,\n    rateLimiter: IRateLimiter\n  ): NodeJS.ReadableStream;\n}\n\nlet rateLimiter = null as unknown as RateLimiterModule;\nif (process.env.TARGET_ENVIRONMENT === 'node') {\n  rateLimiter = moduleNode as unknown as RateLimiterModule;\n} else {\n  rateLimiter = moduleBrowser as unknown as RateLimiterModule;\n}\n\nconst { createDefaultRateLimiter, createRateLimiterStream } = rateLimiter;\n\nexport { createDefaultRateLimiter, createRateLimiterStream };\nexport type { IRateLimiter };\n","import { Readable } from 'stream';\n\nexport class Buffer2Stream extends Readable {\n  lastPos = 0;\n\n  constructor(private buf: Buffer) {\n    super();\n  }\n\n  _read(n: number) {\n    const totalSize = this.buf.length;\n    let actualN = Math.min(n, totalSize - this.lastPos);\n\n    if (this.lastPos >= totalSize) {\n      this.push(null);\n      return;\n    }\n\n    this.push(this.buf.slice(this.lastPos, this.lastPos + actualN));\n    this.lastPos += actualN;\n  }\n}\n","import { Transform } from 'stream';\nimport { CRCCls } from '../universal/crc';\nimport { pipeStreamWithErrorHandle } from '../utils';\n\nfunction createReadCbTransformer(readCb: (chunk: Buffer) => void) {\n  return new Transform({\n    async transform(chunk, _encoding, callback) {\n      readCb(chunk);\n      this.push(chunk);\n      callback();\n    },\n  });\n}\n\nexport function createCrcReadStream(\n  stream: NodeJS.ReadableStream,\n  crc: CRCCls\n) {\n  const readCbTransformer = createReadCbTransformer((chunk: Buffer) =>\n    crc.update(chunk)\n  );\n\n  return pipeStreamWithErrorHandle(\n    stream,\n    readCbTransformer,\n    'createCrcReadStream'\n  );\n}\n","import { TierType } from '../../TosExportEnum';\n\nexport interface RestoreInfo {\n  RestoreStatus: RestoreStatus;\n  RestoreParam?: RestoreParam;\n}\n\nexport type RestoreStatus = {\n  OngoingRequest: boolean;\n  ExpiryDate?: string;\n};\n\nexport type RestoreParam = {\n  RequestDate: string;\n  ExpiryDays: number;\n  Tier: TierType;\n};\n\nexport enum TosHeader {\n  HeaderRestore = 'x-tos-restore',\n  HeaderRestoreExpiryDays = 'x-tos-restore-expiry-days',\n  HeaderRestoreRequestDate = 'x-tos-restore-request-date',\n  HeaderRestoreTier = 'x-tos-restore-tier',\n  HeaderProjectName = 'x-tos-project-name',\n  HeaderReplicationStatus = 'x-tos-replication-status',\n}\n\nexport const RestoreOngoingRequestTrueStr = 'ongoing-request=\"true\"';\nexport const RestoreOngoingRequestFalseReg = 'ongoing-request=\"false\"';\n","import TosClientError from '../../TosClientError';\nimport mimeTypes from '../../mime-types';\nimport { Headers, SupportObjectBody } from '../../interface';\nimport { createReadNReadStream } from '../../nodejs/EmitReadStream';\nimport { isBuffer, isBlob, isReadable } from '../../utils';\nimport { CRC, CRCCls } from '../../universal/crc';\nimport {\n  IRateLimiter,\n  createRateLimiterStream,\n} from '../../universal/rate-limiter';\nimport { Buffer2Stream } from '../../nodejs/buffer2Stream';\nimport { createCrcReadStream } from '../../nodejs/CrcReadStream';\nimport {\n  RestoreInfo,\n  RestoreOngoingRequestTrueStr,\n  TosHeader,\n} from './sharedTypes';\nimport { TierType } from '../../TosExportEnum';\n\nexport const getObjectInputKey = (input: string | { key: string }): string => {\n  return typeof input === 'string' ? input : input.key;\n};\n\nexport const DEFAULT_CONTENT_TYPE = 'application/octet-stream';\n\nexport function lookupMimeType(key: string) {\n  const lastDotIndex = key.lastIndexOf('.');\n\n  if (lastDotIndex <= 0) {\n    return undefined;\n  }\n\n  const extName = key.slice(lastDotIndex + 1).toLowerCase();\n\n  return mimeTypes[extName];\n}\n\n// for all object methods\nexport function validateObjectName(input: { key: string } | string) {\n  const key = typeof input === 'string' ? input : input.key;\n  if (key.length < 1) {\n    throw new TosClientError(\n      'invalid object name, the length must be greater than 1'\n    );\n  }\n}\n\nexport function getSize(body: unknown, headers?: Headers) {\n  if (isBuffer(body)) {\n    return body.length;\n  }\n  if (isBlob(body)) {\n    return body.size;\n  }\n  if (headers && headers['content-length']) {\n    const v = +headers['content-length'];\n    if (v >= 0) {\n      return v;\n    }\n  }\n  return null;\n}\n\ninterface GetNewBodyConfigIn<T> {\n  body: T;\n  dataTransferCallback: (n: number) => void;\n  beforeRetry?: () => void;\n  makeRetryStream?: () => NodeJS.ReadableStream | undefined;\n  enableCRC: boolean;\n  rateLimiter?: IRateLimiter;\n}\ninterface GetNewBodyConfigOut<T> {\n  body: T | NodeJS.ReadableStream;\n  beforeRetry?: () => void;\n  makeRetryStream?: () => NodeJS.ReadableStream | undefined;\n  crc?: CRCCls;\n}\n\ninterface GetEmitReadBodyConfigIn<T> {\n  body: T;\n  dataTransferCallback: (n: number) => void;\n  makeRetryStream?: () => NodeJS.ReadableStream | undefined;\n  rateLimiter?: IRateLimiter;\n}\ninterface GetEmitReadBodyConfigOut<T> {\n  body: T | NodeJS.ReadableStream;\n  makeRetryStream?: () => NodeJS.ReadableStream | undefined;\n}\n\nexport function getEmitReadBodyConfig<T extends SupportObjectBody>({\n  body,\n  dataTransferCallback,\n  makeRetryStream,\n  rateLimiter,\n}: GetEmitReadBodyConfigIn<T>): GetEmitReadBodyConfigOut<T> {\n  let newBody: T | NodeJS.ReadableStream = body;\n\n  const getDefaultRet = () => ({\n    body: newBody,\n    makeRetryStream: undefined,\n  });\n\n  if (process.env.TARGET_ENVIRONMENT !== 'node') {\n    return getDefaultRet();\n  }\n\n  if (isBuffer(newBody)) {\n    const bodyBuf = newBody;\n    makeRetryStream = () => new Buffer2Stream(bodyBuf);\n    newBody = new Buffer2Stream(bodyBuf);\n  }\n\n  if (isReadable(newBody)) {\n    if (rateLimiter && isValidRateLimiter(rateLimiter)) {\n      newBody = createRateLimiterStream(newBody, rateLimiter);\n    }\n    newBody = createReadNReadStream(newBody, dataTransferCallback);\n\n    if (makeRetryStream) {\n      const oriMakeRetryStream = makeRetryStream;\n      return {\n        body: newBody,\n        makeRetryStream: () => {\n          let stream = oriMakeRetryStream();\n          if (!stream) {\n            return stream;\n          }\n\n          if (rateLimiter && isValidRateLimiter(rateLimiter)) {\n            stream = createRateLimiterStream(stream, rateLimiter);\n          }\n          stream = createReadNReadStream(stream, dataTransferCallback);\n          return stream;\n        },\n      };\n    }\n  }\n\n  return getDefaultRet();\n}\n\nexport async function getCRCBodyConfig<T extends SupportObjectBody>({\n  body,\n  beforeRetry,\n  makeRetryStream,\n  enableCRC,\n}: GetNewBodyConfigIn<T>): Promise<GetNewBodyConfigOut<T>> {\n  if (process.env.TARGET_ENVIRONMENT === 'browser' || !enableCRC) {\n    return {\n      body,\n      beforeRetry,\n      makeRetryStream,\n    };\n  }\n\n  let newBody: T | NodeJS.ReadableStream = body;\n  const crc = new CRC();\n  if (isReadable(body)) {\n    newBody = createCrcReadStream(body, crc);\n    if (makeRetryStream) {\n      const oriMakeRetryStream = makeRetryStream;\n      makeRetryStream = () => {\n        const stream = oriMakeRetryStream();\n        if (!stream) {\n          return stream;\n        }\n        return createCrcReadStream(stream, crc);\n      };\n    }\n  }\n\n  return {\n    body: newBody,\n    beforeRetry: () => {\n      crc.reset();\n      beforeRetry?.();\n    },\n    makeRetryStream,\n    crc,\n  };\n}\n\nexport async function getNewBodyConfig<T extends SupportObjectBody>(\n  input: GetNewBodyConfigIn<T>\n): Promise<GetNewBodyConfigOut<T>> {\n  const config1 = getEmitReadBodyConfig(input);\n  input = { ...input, ...config1 } as GetNewBodyConfigIn<T>;\n  const config2 = getCRCBodyConfig(input);\n  return config2;\n}\n\nexport function getCopySourceHeaderValue(srcBucket: string, srcKey: string) {\n  return `/${srcBucket}/${encodeURIComponent(srcKey)}`;\n}\n\nexport function isValidRateLimiter(rateLimiter?: IRateLimiter) {\n  if (!rateLimiter?.Acquire || !(rateLimiter?.Acquire instanceof Function)) {\n    throw new TosClientError(`The rateLimiter is not valid function`);\n  }\n  return true;\n}\n\nexport function validateCheckpoint(cp: undefined | string | Object) {\n  if (process.env.TARGET_ENVIRONMENT === 'node' && typeof cp === 'object') {\n    console.warn(\n      `The \\`checkpoint\\` parameter should be passed as a string in node.js environment, representing a file or directory.` +\n        `Passing a checkpoint object to it will be removed in the future.`\n    );\n  }\n}\n\nexport const getRestoreInfoFromHeaders = (headers: Headers) => {\n  if (!headers) return;\n  const headerStoreValue = headers?.[TosHeader.HeaderRestore];\n\n  if (headerStoreValue) {\n    /**\n     * value example:\n     * X-Tos-Restore: ongoing-request=\"false\", expiry-date=\"Fri, 19 Apr 2024 00:00:00 GMT\"\n     */\n    const ExpiryDate =\n      (headerStoreValue ?? '').split('\",')[1]?.split?.('=')?.[1] ?? '';\n    const OngoingRequest =\n      headerStoreValue?.trim() === RestoreOngoingRequestTrueStr ? true : false;\n    const restoreInfo: RestoreInfo = {\n      RestoreStatus: {\n        OngoingRequest,\n        ExpiryDate,\n      },\n    };\n    if (OngoingRequest) {\n      restoreInfo.RestoreParam = {\n        ExpiryDays: headers[TosHeader.HeaderRestoreExpiryDays]\n          ? Number(headers[TosHeader.HeaderRestoreExpiryDays])\n          : 0,\n        RequestDate: headers[TosHeader.HeaderRestoreRequestDate] ?? '',\n        Tier: headers[TosHeader.HeaderRestoreTier] as TierType,\n      };\n    }\n    return restoreInfo;\n  }\n  return;\n};\n","import {\n  ACLType,\n  CannedType,\n  PermissionType,\n  StorageClassType,\n} from './TosExportEnum';\n\nexport type Headers = { [key: string]: string | undefined };\n\nexport interface AclInterface {\n  Owner: { ID: string };\n  Grants: {\n    Grantee: {\n      ID?: string;\n      DisplayName?: string;\n      Type: string;\n      Canned?: CannedType;\n    };\n    Permission: PermissionType;\n  }[];\n  /**\n   * @private unstable property only for bucket ACL\n   */\n  BucketAclDelivered?: boolean;\n  /**\n   * @private unstable property only for object ACL\n   */\n  IsDefault?: boolean;\n}\n\nexport type Acl = ACLType;\nexport type StorageClass = StorageClassType;\n\nexport type ServerSideEncryption = 'AES256';\n\nexport interface DataTransferStatus {\n  /**\n   * has read or wrote bytes\n   */\n  consumedBytes: number;\n\n  /**\n   * totalBytes maybe 0 or -1.\n   * `-1` means unkown totalBytes, for example when starting to download an object\n   */\n  totalBytes: number;\n\n  /**\n   * transferred bytes in this transfer\n   */\n  rwOnceBytes: number;\n\n  type: DataTransferType;\n}\n\nexport enum DataTransferType {\n  Started = 1, // data transfer start\n  Rw = 2, // one transfer\n  Succeed = 3, // data transfer succeed\n  Failed = 4, // data transfer failed\n}\n\nexport type SupportObjectBody =\n  | File\n  | Blob\n  | Buffer\n  | NodeJS.ReadableStream\n  | undefined;\n\nexport type StringKeys<T> = Extract<\n  { [K in keyof T]: T[K] extends string | undefined ? K : never }[keyof T],\n  string\n>;\n\nexport interface IRateLimiter {\n  Acquire: (want: number) => Promise<{\n    ok: boolean;\n    /**\n     * unit: milliseconds\n     */\n    timeToWait: number;\n  }>;\n}","import axios from 'axios';\nimport { Readable } from 'stream';\nimport { safeSync } from './utils';\nimport { SignersV4 } from './signatureV4';\nimport * as log from './log';\n\nexport const retryNamespace = '__retryConfig__';\nexport const retrySignatureNamespace = '__retrySignature__';\n\nexport interface RetryConfig {\n  // \n  makeRetryStream?: () => NodeJS.ReadableStream | undefined;\n\n  beforeRetry?: () => void;\n}\n\ninterface InnerRetryConfig extends RetryConfig {\n  retryCount?: number;\n}\n\ninterface RetrySignature {\n  signOpt: any;\n  sigInst: SignersV4;\n}\n\ndeclare module 'axios' {\n  interface AxiosRequestConfig {\n    __retryConfig__?: RetryConfig;\n    __retrySignature__?: RetrySignature;\n  }\n}\n\nfunction isNetworkError(error: any) {\n  // no response or no requestId, ignore no network(error.code is undefined)\n  return (\n    (!error.response && Boolean(error.code)) ||\n    (error.response && !error.response.headers?.['x-tos-request-id'])\n  );\n}\n\nfunction isCanRetryStatusCode(error: any) {\n  if (!error.response) {\n    return false;\n  }\n\n  const { status } = error.response;\n  if (status === 429 || status === 408 || status >= 500) {\n    return true;\n  }\n  return false;\n}\n\nconst BROWSER_NEED_DELETE_HEADERS = ['content-length', 'user-agent', 'host'];\n\nexport const makeAxiosInst = (maxRetryCount: number) => {\n  const axiosInst = axios.create();\n  // set `axiosInst` default values to avoid being affected by the global default values of axios\n  axiosInst.defaults.auth = undefined;\n  axiosInst.defaults.responseType = 'json';\n  axiosInst.defaults.params = undefined;\n  axiosInst.defaults.headers = {};\n  axiosInst.defaults.withCredentials = false;\n  axiosInst.defaults.maxContentLength = -1;\n  axiosInst.defaults.maxBodyLength = -1;\n  axiosInst.defaults.maxRedirects = 0;\n  axiosInst.defaults.validateStatus = function (status) {\n    return status >= 200 && status < 300; // default\n  };\n  axiosInst.defaults.decompress = false;\n  axiosInst.defaults.transitional = {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false,\n  };\n\n  // delete browser headers\n  if (process.env.TARGET_ENVIRONMENT === 'browser') {\n    axiosInst.interceptors.request.use((config) => {\n      if (!config.headers) {\n        return config;\n      }\n\n      Object.keys(config.headers).forEach((key) => {\n        if (BROWSER_NEED_DELETE_HEADERS.includes(key.toLowerCase())) {\n          delete config.headers[key];\n        }\n      });\n\n      return config;\n    });\n  }\n\n  // headers\n  const ensureHeaders = (v: any) => {\n    v.headers = v.headers || v.header || v?.response?.headers || {};\n    return v;\n  };\n  axiosInst.interceptors.response.use(ensureHeaders, (error) => {\n    ensureHeaders(error);\n    return Promise.reject(error);\n  });\n\n  // decode header. Encode headers' value by encodeHeadersValue method before calling axios\n  function handleResponseHeader(headers: Record<string, string>) {\n    Object.entries(headers).forEach(([key, value]) => {\n      const [err, decodedValue] = safeSync(() => decodeURI(value));\n      if (err || decodedValue == null || decodedValue === value) {\n        return;\n      }\n      let sArr = [];\n      const valueArr = `${value}`.match(/./gu)!;\n      const decodedValueArr = decodedValue.match(/./gu)!;\n      for (let i = 0, j = 0; i < decodedValueArr.length; ) {\n        const ch = decodedValueArr[i];\n        if (ch === valueArr[j]) {\n          sArr.push(ch);\n          ++i;\n          ++j;\n          continue;\n        }\n\n        const encodedCh = encodeURIComponent(ch);\n        if (ch.length > 1 || ch.charCodeAt(0) >= 128) {\n          sArr.push(ch);\n        } else {\n          sArr.push(encodedCh);\n        }\n        ++i;\n        j += encodedCh.length;\n      }\n      headers[key] = sArr.join('');\n    });\n  }\n  axiosInst.interceptors.response.use(\n    (res) => {\n      if (!res.headers) {\n        return res;\n      }\n      handleResponseHeader(res.headers);\n      return res;\n    },\n    async (error) => {\n      if (!axios.isAxiosError(error)) {\n        return Promise.reject(error);\n      }\n\n      const headers = error.response?.headers;\n      if (!headers) {\n        return Promise.reject(error);\n      }\n      handleResponseHeader(headers);\n      return Promise.reject(error);\n    }\n  );\n\n  // retry\n  axiosInst.interceptors.response.use(undefined, async (error) => {\n    const { config } = error;\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    if (!config[retryNamespace]) {\n      config[retryNamespace] = {};\n    }\n    const retryConfig: InnerRetryConfig = config[retryNamespace];\n    const retryCount = retryConfig.retryCount ?? 0;\n\n    let newData = config.data;\n    const canRetryData = (() => {\n      if (process.env.TARGET_ENVIRONMENT === 'node') {\n        if (config.data && config.data instanceof Readable) {\n          const v = retryConfig.makeRetryStream?.();\n          if (!v) {\n            return false;\n          }\n          newData = v;\n        }\n      }\n      return true;\n    })();\n\n    const canRetry =\n      (isNetworkError(error) || isCanRetryStatusCode(error)) &&\n      retryCount < maxRetryCount &&\n      canRetryData;\n\n    if (!canRetry) {\n      return Promise.reject(error);\n    }\n\n    const retrySignature = config[retrySignatureNamespace] as RetrySignature;\n    if (retrySignature) {\n      const { signOpt, sigInst } = retrySignature;\n      const signatureHeaders = sigInst.signatureHeader(signOpt);\n      signatureHeaders.forEach((value, key) => {\n        config.headers[key] = value;\n      });\n    }\n\n    //console.log('config: ', config)\n    log.TOS('retryConfig: ', config);\n    const nextConfig = {\n      ...config,\n      data: newData,\n      [retryNamespace]: {\n        ...retryConfig,\n        retryCount: retryCount + 1,\n      },\n    };\n\n    retryConfig.beforeRetry?.();\n    return axiosInst(nextConfig);\n  });\n\n  return axiosInst;\n};\n","import cryptoHmacSha256 from 'crypto-js/hmac-sha256';\nimport cryptoHashSha256 from 'crypto-js/sha256';\nimport cryptoHashMd5 from 'crypto-js/md5';\nimport cryptoEncBase64 from 'crypto-js/enc-base64';\nimport cryptoEncHex from 'crypto-js/enc-hex';\nimport cryptoEncUtf8 from 'crypto-js/enc-utf8';\nimport TosClientError from '../TosClientError';\nimport { isBuffer } from '../utils';\n\nfunction getEnc(coding: 'utf-8' | 'base64' | 'hex') {\n  switch (coding) {\n    case 'utf-8':\n      return cryptoEncUtf8;\n    case 'base64':\n      return cryptoEncBase64;\n    case 'hex':\n      return cryptoEncHex;\n    default:\n      throw new TosClientError('The coding is not supported');\n  }\n}\n\nfunction decode(v: any, decoding?: 'base64' | 'hex'): string {\n  if (!decoding) {\n    return v;\n  }\n\n  return v.toString(getEnc(decoding));\n}\n\nexport const hmacSha256 = function hmacSha256(\n  key: string,\n  message: string,\n  decoding?: 'base64' | 'hex'\n) {\n  return decode(cryptoHmacSha256(message, key), decoding);\n};\n\nexport const hashSha256 = function hashSha256(\n  message: string,\n  decoding?: 'base64' | 'hex'\n) {\n  return decode(cryptoHashSha256(message), decoding);\n};\n\nexport const hashMd5 = function hashMd5(\n  message: string | Buffer,\n  decoding?: 'base64' | 'hex'\n) {\n  if (isBuffer(message)) {\n    throw new TosClientError('not support buffer in browser environment');\n  }\n\n  return decode(cryptoHashMd5(message), decoding);\n};\n\nexport const parse = function parse(\n  str: string,\n  encoding: 'utf-8' | 'base64' | 'hex'\n) {\n  return getEnc(encoding).parse(str);\n};\n\nexport const stringify = function stringify(\n  str: CryptoJS.lib.WordArray,\n  decoding: 'utf-8' | 'base64' | 'hex'\n) {\n  return getEnc(decoding).stringify(str);\n};\n","import crypto from 'crypto';\n\nfunction digest(v: any, decoding?: 'base64' | 'hex'): string {\n  if (!decoding) {\n    return v.digest();\n  }\n  return v.digest(decoding);\n}\n\nexport const hmacSha256 = function hmacSha256(\n  key: string,\n  message: string,\n  decoding?: 'base64' | 'hex'\n) {\n  return digest(crypto.createHmac('sha256', key).update(message), decoding);\n};\n\nexport const hashSha256 = function hashSha256(\n  message: string,\n  decoding?: 'base64' | 'hex'\n) {\n  return digest(crypto.createHash('sha256').update(message), decoding);\n};\n\nexport const hashMd5 = function hashMd5(\n  message: string | Buffer,\n  decoding?: 'base64' | 'hex'\n) {\n  return digest(crypto.createHash('md5').update(message), decoding);\n};\n\nexport const parse = function parse(\n  str: string,\n  encoding: 'utf-8' | 'base64' | 'hex'\n) {\n  return Buffer.from(str, encoding);\n};\n\nexport const stringify = function stringify(\n  str: Buffer,\n  decoding: 'utf-8' | 'base64' | 'hex'\n) {\n  return str.toString(decoding);\n};\n","import * as cryptoBrowser from './crypto.browser';\nimport * as cryptoNode from '../nodejs/crypto.nodejs';\n\ninterface CryptoModule {\n  hmacSha256: (\n    key: string,\n    message: string,\n    decoding?: 'base64' | 'hex'\n  ) => string;\n  hashSha256: (message: string, decoding?: 'base64' | 'hex') => string;\n  hashMd5: (message: string | Buffer, decoding?: 'base64' | 'hex') => string;\n  parse: (str: string, encoding: 'utf-8' | 'base64' | 'hex') => string;\n  stringify: (str: string, decoding: 'utf-8' | 'base64' | 'hex') => string;\n}\n\nlet crypto = null as unknown as CryptoModule;\nif (process.env.TARGET_ENVIRONMENT === 'node') {\n  crypto = cryptoNode as unknown as CryptoModule;\n} else {\n  crypto = cryptoBrowser as unknown as CryptoModule;\n}\n\nconst { hmacSha256, hashSha256, hashMd5, parse, stringify } = crypto;\n\nexport { hmacSha256, hashSha256, hashMd5, parse, stringify };\n","import { getNewBodyConfig, getSize } from '../utils';\nimport TOSBase from '../../base';\nimport TosClientError from '../../../TosClientError';\nimport { ReadStream, Stats } from 'fs';\nimport * as fsp from '../../../nodejs/fs-promises';\nimport { DataTransferStatus, DataTransferType } from '../../../interface';\nimport {\n  checkCRC64WithHeaders,\n  fillRequestHeaders,\n  isReadable,\n  makeRetryStreamAutoClose,\n  normalizeHeadersKey,\n  safeAwait,\n  tryDestroy,\n} from '../../../utils';\nimport { retryNamespace } from '../../../axios';\nimport { hashMd5 } from '../../../universal/crypto';\nimport { IRateLimiter } from '../../../universal/rate-limiter';\n\nexport interface UploadPartInput {\n  body: Blob | Buffer | NodeJS.ReadableStream;\n  bucket?: string;\n  key: string;\n  partNumber: number;\n  uploadId: string;\n  dataTransferStatusChange?: (status: DataTransferStatus) => void;\n  /**\n   * the simple progress feature\n   * percent is [0, 1].\n   *\n   * since uploadPart is stateless, so if `uploadPart` fail and you retry it,\n   * `percent` will start from 0 again rather than from the previous value.\n   */\n  progress?: (percent: number) => void;\n  /**\n   * unit: bit/s\n   * server side traffic limit\n   **/\n  trafficLimit?: number;\n  /**\n   * only works for nodejs environment\n   */\n  rateLimiter?: IRateLimiter;\n\n  ssecAlgorithm?: string;\n  ssecKey?: string;\n  ssecKeyMD5?: string;\n\n  headers?: {\n    [key: string]: string | undefined;\n    'content-length'?: string;\n    'content-md5'?: string;\n    'x-tos-server-side-encryption-customer-algorithm'?: string;\n    'x-tos-server-side-encryption-customer-key'?: string;\n    'x-tos-server-side-encryption-customer-key-MD5'?: string;\n  };\n}\n\nexport interface UploadPartInputInner extends UploadPartInput {\n  makeRetryStream?: () => NodeJS.ReadableStream | undefined;\n  beforeRetry?: () => void;\n  /**\n   * default: false\n   */\n  enableContentMD5?: boolean;\n}\n\nexport interface UploadPartOutput {\n  partNumber: number;\n  ETag: string;\n  ssecAlgorithm?: string;\n  ssecKeyMD5?: string;\n  hashCrc64ecma: string;\n  serverSideEncryption?: string;\n  serverSideEncryptionKeyId?: string;\n  /** @private unstable */\n  serverSideDataEncryption?: string;\n}\n\nexport async function _uploadPart(this: TOSBase, input: UploadPartInputInner) {\n  const { uploadId, partNumber, body, enableContentMD5 = false } = input;\n  const headers = normalizeHeadersKey(input.headers);\n  input.headers = headers;\n  fillRequestHeaders(input, [\n    'trafficLimit',\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n  ]);\n\n  const size = getSize(body);\n  if (size && headers['content-length'] == null) {\n    headers['content-length'] = size.toFixed(0);\n  }\n  if (enableContentMD5 && headers['content-md5'] == null) {\n    // current only support in nodejs\n    if (\n      process.env.TARGET_ENVIRONMENT === 'node' &&\n      isReadable(body) &&\n      input.makeRetryStream\n    ) {\n      const newStream = input.makeRetryStream();\n      if (newStream) {\n        let allContent = Buffer.from([]);\n        for await (const chunk of newStream) {\n          allContent = Buffer.concat([\n            allContent,\n            typeof chunk === 'string' ? Buffer.from(chunk) : chunk,\n          ]);\n        }\n        const md5 = hashMd5(allContent, 'base64');\n        headers['content-md5'] = md5;\n      }\n    } else {\n      console.warn(`current not support enableMD5Checksum`);\n    }\n  }\n\n  const totalSize = getSize(input.body, headers);\n  const totalSizeValid = totalSize != null;\n  if (!totalSizeValid && (input.dataTransferStatusChange || input.progress)) {\n    console.warn(\n      `Don't get totalSize of uploadPart's body, the \\`dataTransferStatusChange\\` callback will not trigger. You can use \\`uploadPartFromFile\\` instead`\n    );\n  }\n\n  let consumedBytes = 0;\n  const { dataTransferStatusChange, progress } = input;\n  const triggerDataTransfer = (\n    type: DataTransferType,\n    rwOnceBytes: number = 0\n  ) => {\n    // request cancel will make rwOnceBytes < 0 in browser\n    if (!totalSizeValid || rwOnceBytes < 0) {\n      return;\n    }\n    if (!dataTransferStatusChange && !progress) {\n      return;\n    }\n    consumedBytes += rwOnceBytes;\n\n    dataTransferStatusChange?.({\n      type,\n      rwOnceBytes,\n      consumedBytes,\n      totalBytes: totalSize,\n    });\n\n    const progressValue = (() => {\n      if (totalSize === 0) {\n        if (type === DataTransferType.Succeed) {\n          return 1;\n        }\n        return 0;\n      }\n      return consumedBytes / totalSize;\n    })();\n    if (progressValue === 1) {\n      if (type === DataTransferType.Succeed) {\n        progress?.(progressValue);\n      } else {\n        // not exec progress\n      }\n    } else {\n      progress?.(progressValue);\n    }\n  };\n  const bodyConfig = await getNewBodyConfig({\n    body: input.body,\n    dataTransferCallback: (n) => triggerDataTransfer(DataTransferType.Rw, n),\n    beforeRetry: input.beforeRetry,\n    makeRetryStream: input.makeRetryStream,\n    enableCRC: this.opts.enableCRC,\n    rateLimiter: input.rateLimiter,\n  });\n\n  triggerDataTransfer(DataTransferType.Started);\n  const task = async () => {\n    const res = await this._fetchObject<UploadPartOutput>(\n      input,\n      'PUT',\n      { partNumber, uploadId },\n      headers,\n      bodyConfig.body,\n      {\n        handleResponse: (res) => ({\n          partNumber,\n          ETag: res.headers.etag,\n          serverSideEncryption: res.headers['x-tos-server-side-encryption'],\n          serverSideDataEncryption:\n            res.headers['x-tos-server-side-data-encryption'],\n          serverSideEncryptionKeyId:\n            res.headers['x-tos-server-side-encryption-kms-key-id'],\n          ssecAlgorithm:\n            res.headers['x-tos-server-side-encryption-customer-algorithm'],\n          ssecKeyMD5:\n            res.headers['x-tos-server-side-encryption-customer-key-MD5'],\n          hashCrc64ecma: res.headers['x-tos-hash-crc64ecma'],\n        }),\n        axiosOpts: {\n          [retryNamespace]: {\n            beforeRetry: () => {\n              consumedBytes = 0;\n              bodyConfig.beforeRetry?.();\n            },\n            makeRetryStream: bodyConfig.makeRetryStream,\n          },\n          onUploadProgress: (event) => {\n            triggerDataTransfer(\n              DataTransferType.Rw,\n              event.loaded - consumedBytes\n            );\n          },\n        },\n      }\n    );\n    if (this.opts.enableCRC && bodyConfig.crc) {\n      checkCRC64WithHeaders(bodyConfig.crc, res.headers);\n    }\n    return res;\n  };\n  const [err, res] = await safeAwait(task());\n\n  // FAQ: no etag\n  if (process.env.TARGET_ENVIRONMENT === 'browser') {\n    if (res && !res.data.ETag) {\n      throw new TosClientError(\n        \"No ETag in uploadPart's response headers, please see https://www.volcengine.com/docs/6349/127737 to fix CORS problem\"\n      );\n    }\n  }\n\n  if (err || !res) {\n    triggerDataTransfer(DataTransferType.Failed);\n    throw err;\n  }\n\n  triggerDataTransfer(DataTransferType.Succeed);\n  return res;\n}\n\nexport async function uploadPart(this: TOSBase, input: UploadPartInput) {\n  return _uploadPart.call(this, input);\n}\n\ninterface UploadPartFromFileInput extends Omit<UploadPartInput, 'body'> {\n  filePath: string;\n  /**\n   * default: 0\n   */\n  offset?: number;\n\n  /**\n   * default: file size\n   */\n  partSize?: number;\n}\nexport async function uploadPartFromFile(\n  this: TOSBase,\n  input: UploadPartFromFileInput\n) {\n  if (process.env.TARGET_ENVIRONMENT !== 'node') {\n    throw new TosClientError(\n      \"uploadPartFromFile doesn't support in browser environment\"\n    );\n  }\n\n  const stats: Stats = await fsp.stat(input.filePath);\n  const start = input.offset ?? 0;\n  const end = Math.min(stats.size, start + (input.partSize ?? stats.size));\n  const makeRetryStream = makeRetryStreamAutoClose(() =>\n    fsp.createReadStream(input.filePath, {\n      start,\n      end: end - 1,\n    })\n  );\n\n  try {\n    return await _uploadPart.call(this, {\n      ...input,\n      body: makeRetryStream.make(),\n      headers: {\n        ...(input.headers || {}),\n        ['content-length']: `${end - start}`,\n      },\n      makeRetryStream: makeRetryStream.make,\n    });\n  } catch (err) {\n    tryDestroy(makeRetryStream.getLastStream(), err);\n    throw err;\n  }\n}\n","import TosClientError from '../../../TosClientError';\nimport { fillRequestHeaders } from '../../../utils';\nimport TOSBase from '../../base';\n\nexport interface CompleteMultipartUploadInput {\n  bucket?: string;\n  key: string;\n  uploadId: string;\n  parts: {\n    eTag: string;\n    partNumber: number;\n  }[];\n  /**\n   * when true `parts` param need to be empty array\n   */\n  completeAll?: boolean;\n\n  callback?: string;\n  callbackVar?: string;\n  forbidOverwrite?: boolean;\n\n  headers?: {\n    ['x-tos-forbid-overwrite']?: string;\n  };\n}\n\nexport type UploadedPart = {\n  PartNumber: number;\n  ETag: string;\n};\n\nexport interface CompleteMultipartUploadOutput {\n  Bucket: string;\n  Key: string;\n  ETag: string;\n  Location: string;\n  VersionID?: string;\n  HashCrc64ecma?: string;\n  /** the field has a value when completeAll is true\n   * when specify callback, the field will not has a value\n   */\n  CompletedParts?: UploadedPart[];\n  CallbackResult?: string;\n}\n\nexport async function completeMultipartUpload(\n  this: TOSBase,\n  input: CompleteMultipartUploadInput\n) {\n  input.headers = input.headers ?? {};\n  fillRequestHeaders(input, ['callback', 'callbackVar', 'forbidOverwrite']);\n\n  const handleResponse = (response: {\n    headers: { [x: string]: any };\n    data: CompleteMultipartUploadOutput;\n  }) => {\n    const bucket = input.bucket || this.opts.bucket || '';\n    const headers = response.headers;\n    const result: CompleteMultipartUploadOutput = {\n      ...{\n        VersionID: headers['x-tos-version-id'],\n        ETag: headers['etag'],\n        Bucket: bucket,\n        Location: headers['location'],\n        HashCrc64ecma: headers['x-tos-hash-crc64ecma'],\n        Key: input.key,\n      },\n      ...response.data,\n    };\n    if (input.callback) {\n      result.CallbackResult = `${JSON.stringify(response.data)}`;\n    }\n    return result;\n  };\n  if (input.completeAll) {\n    if (input.parts?.length > 0) {\n      throw new TosClientError(\n        `Should not specify both 'completeAll' and 'parts' params.`\n      );\n    }\n    return this._fetchObject<CompleteMultipartUploadOutput>(\n      input,\n      'POST',\n      {\n        uploadId: input.uploadId,\n      },\n      {\n        ...input.headers,\n        'x-tos-complete-all': 'yes',\n      },\n      undefined,\n      {\n        handleResponse,\n      }\n    );\n  }\n\n  return this._fetchObject<CompleteMultipartUploadOutput>(\n    input,\n    'POST',\n    {\n      uploadId: input.uploadId,\n    },\n    {\n      ...input.headers,\n    },\n    {\n      Parts: input.parts.map((it) => ({\n        ETag: it.eTag,\n        PartNumber: it.partNumber,\n      })),\n    },\n    {\n      handleResponse,\n    }\n  );\n}\n","import { Readable } from 'stream';\n\nexport class EmptyReadStream extends Readable {\n  _read(): void {\n    this.push(null);\n  }\n}\n","import TOSBase, { TosResponse } from '../../base';\nimport {\n  createMultipartUpload,\n  CreateMultipartUploadInput,\n} from './createMultipartUpload';\n\nimport { calculateSafePartSize } from './listParts';\nimport { Stats } from 'fs';\nimport { UploadPartOutput, _uploadPart } from './uploadPart';\nimport TosServerError from '../../../TosServerError';\nimport {\n  completeMultipartUpload,\n  CompleteMultipartUploadOutput,\n} from './completeMultipartUpload';\nimport { CancelToken } from 'axios';\nimport * as fsp from '../../../nodejs/fs-promises';\nimport path from 'path';\nimport TosClientError from '../../../TosClientError';\nimport { DataTransferStatus, DataTransferType } from '../../../interface';\nimport {\n  safeAwait,\n  isBlob,\n  isBuffer,\n  DEFAULT_PART_SIZE,\n  normalizeHeadersKey,\n  fillRequestHeaders,\n  makeSerialAsyncTask,\n  safeParseCheckpointFile,\n  makeRetryStreamAutoClose,\n  tryDestroy,\n} from '../../../utils';\nimport { EmptyReadStream } from '../../../nodejs/EmptyReadStream';\nimport { CancelError } from '../../../CancelError';\nimport { hashMd5 } from '../../../universal/crypto';\nimport { IRateLimiter } from '../../../interface';\nimport { validateCheckpoint } from '../utils';\nimport { combineCrc64 } from '../../../universal/crc';\nimport * as log from '../../../log';\n\nexport interface UploadFileInput extends CreateMultipartUploadInput {\n  /**\n   * if the type of `file` is string,\n   * `file` represents the file path that will be uploaded\n   */\n  file: string | File | Blob | Buffer;\n\n  /**\n   * default is 20 MB\n   *\n   * unit: B\n   */\n  partSize?: number;\n\n  /**\n   * the number of request to parallel upload partdefault value is 1\n   */\n  taskNum?: number;\n\n  // TODO: default file name is not aligned.\n  /**\n   * if checkpoint is a string and point to a exist file,\n   * the checkpoint record will recover from this file.\n   *\n   * if checkpoint is a string and point to a directory,\n   * the checkpoint will be auto generated,\n   * and its name is `{bucketName}_{objectName}.{uploadId}`.\n   */\n  checkpoint?: string | CheckpointRecord;\n\n  dataTransferStatusChange?: (status: DataTransferStatus) => void;\n\n  /**\n   * the feature of pause and continue uploading\n   */\n  uploadEventChange?: (event: UploadEvent) => void;\n\n  /**\n   * the simple progress feature\n   * percent is [0, 1]\n   */\n  progress?: (percent: number, checkpoint: CheckpointRecord) => void;\n\n  /**\n   * cancel this upload progress\n   */\n  cancelToken?: CancelToken;\n\n  /**\n   * enable md5 checksum to uploadPart method\n   *\n   * default: false\n   */\n  enableContentMD5?: boolean;\n\n  /**\n   * unit: bit/s\n   * server side traffic limit\n   **/\n  trafficLimit?: number;\n\n  /**\n   * only works for nodejs environment\n   */\n  rateLimiter?: IRateLimiter;\n}\n\nexport interface UploadFileOutput extends CompleteMultipartUploadOutput {}\n\nexport enum UploadEventType {\n  CreateMultipartUploadSucceed = 1,\n  CreateMultipartUploadFailed = 2,\n  UploadPartSucceed = 3,\n  UploadPartFailed = 4,\n  UploadPartAborted = 5,\n  CompleteMultipartUploadSucceed = 6,\n  CompleteMultipartUploadFailed = 7,\n}\n\nexport interface UploadPartInfo {\n  partNumber: number;\n  partSize: number;\n  offset: number;\n\n  // has value when upload part succeed\n  etag?: string;\n\n  // not support\n  // hashCrc64ecma?: number;\n}\n\nexport interface UploadEvent {\n  type: UploadEventType;\n\n  /**\n   * has value when event is failed or aborted\n   */\n  err?: Error;\n\n  bucket: string;\n  key: string;\n  uploadId: string;\n  checkpointFile?: string;\n  uploadPartInfo?: UploadPartInfo;\n}\n\nexport interface CheckpointRecord {\n  bucket: string;\n  key: string;\n  part_size: number;\n  upload_id: string;\n  parts_info?: CheckpointRecordPart[];\n  // Information about the file to be uploaded\n  file_info?: {\n    last_modified: number;\n    file_size: number;\n  };\n\n  // TODO: Not support the fields below\n  // ssec_algorithm?: string;\n  // ssec_key_md5?: string;\n  // encoding_type?: string;\n}\n\ninterface CheckpointRecordPart {\n  part_number: number;\n  part_size: number;\n  offset: number;\n  etag: string;\n  hash_crc64ecma: string;\n  is_completed: boolean;\n}\n\ninterface CheckpointRichInfo {\n  filePath?: string | undefined;\n\n  filePathIsPlaceholder?: boolean;\n\n  record?: CheckpointRecord;\n}\n\ninterface Task {\n  partSize: number;\n  offset: number;\n  partNumber: number;\n}\n\nconst CHECKPOINT_FILE_NAME_PLACEHOLDER = '@@checkpoint-file-placeholder@@';\nconst FILE_PARAM_CHECK_MSG = '`file` must be string, Buffer, File or Blob';\nconst ABORT_ERROR_STATUS_CODE = [403, 404, 405];\n\nexport async function uploadFile(\n  this: TOSBase,\n  input: UploadFileInput\n): Promise<TosResponse<UploadFileOutput>> {\n  const { cancelToken, enableContentMD5 = false } = input;\n  const headers = normalizeHeadersKey(input.headers);\n  input.headers = headers;\n  fillRequestHeaders(input, [\n    'encodingType',\n    'cacheControl',\n    'contentDisposition',\n    'contentEncoding',\n    'contentLanguage',\n    'contentType',\n    'expires',\n\n    'acl',\n    'grantFullControl',\n    'grantRead',\n    'grantReadAcp',\n    'grantWriteAcp',\n\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n    'serverSideEncryption',\n    'serverSideDataEncryption',\n    'meta',\n    'websiteRedirectLocation',\n    'storageClass',\n  ]);\n\n  const isCancel = () => cancelToken && !!cancelToken.reason;\n  validateCheckpoint(input.checkpoint);\n\n  const fileStats: Stats | null = await (async () => {\n    if (\n      process.env.TARGET_ENVIRONMENT === 'node' &&\n      typeof input.file === 'string'\n    ) {\n      return fsp.stat(input.file);\n    }\n    return null;\n  })();\n\n  const fileSize = await (async () => {\n    const { file } = input;\n    if (fileStats) {\n      return fileStats.size;\n    }\n    if (isBuffer(file)) {\n      return file.length;\n    }\n    if (isBlob(file)) {\n      return file.size;\n    }\n    throw new TosClientError(FILE_PARAM_CHECK_MSG);\n  })();\n\n  const checkpointRichInfo = await (async (): Promise<CheckpointRichInfo> => {\n    if (process.env.TARGET_ENVIRONMENT === 'node') {\n      if (typeof input.checkpoint === 'string') {\n        const { checkpoint } = input;\n        // file doesn't exist when stat is null\n        let checkpointStat: Stats | null = null;\n        try {\n          checkpointStat = await fsp.stat(checkpoint);\n        } catch (_err) {\n          // TODO: remove any\n          const err = _err as any;\n          if (err.code === 'ENOENT') {\n            // file doesn't exist\n          } else {\n            throw err;\n          }\n        }\n\n        const isDirectory = (() => {\n          if (checkpointStat) {\n            return checkpointStat.isDirectory();\n          }\n          return checkpoint.endsWith('/');\n        })();\n\n        // TODO: this is not a right decision\n        // filePath will generated by uploadId, use placeholder temporarily\n        const filePath = isDirectory\n          ? path.resolve(checkpoint, CHECKPOINT_FILE_NAME_PLACEHOLDER)\n          : // ensure relative path require\n            path.resolve(checkpoint);\n        const dirPath = path.dirname(filePath);\n        // ensure directory exist\n        await fsp.safeMkdirRecursive(dirPath);\n\n        if (isDirectory) {\n          return {\n            filePath,\n            filePathIsPlaceholder: true,\n          };\n        }\n\n        try {\n          const record = checkpointStat\n            ? await safeParseCheckpointFile(filePath)\n            : undefined;\n          return {\n            filePath,\n            filePathIsPlaceholder: false,\n            // filePath is json file\n            // TODO: validate json schema\n            record,\n          };\n        } catch (error) {\n          console.warn(\n            'the checkpoint file is invalid JSON format. please check checkpoint file'\n          );\n          throw error;\n        }\n      }\n    }\n\n    if (typeof input.checkpoint === 'object') {\n      return {\n        record: input.checkpoint,\n      };\n    }\n\n    return {};\n  })();\n\n  // check if file info is matched\n  await (async () => {\n    if (fileStats && checkpointRichInfo.record?.file_info) {\n      const { last_modified, file_size } = checkpointRichInfo.record?.file_info;\n      if (fileStats.mtimeMs !== last_modified || fileStats.size !== file_size) {\n        console.warn(\n          `The file has been modified since ${new Date(\n            last_modified\n          )}, so the checkpoint file is invalid, and specified file will be uploaded again.`\n        );\n        delete checkpointRichInfo.record;\n      }\n    }\n  })();\n\n  const partSize = calculateSafePartSize(\n    fileSize,\n    input.partSize || checkpointRichInfo.record?.part_size || DEFAULT_PART_SIZE,\n    true\n  );\n\n  // check partSize is matched\n  if (\n    checkpointRichInfo.record &&\n    checkpointRichInfo.record.part_size !== partSize\n  ) {\n    console.warn(\n      'The partSize param does not equal the partSize in checkpoint file, ' +\n        'so the checkpoint file is invalid, and specified file will be uploaded again.'\n    );\n    delete checkpointRichInfo.record;\n  }\n\n  let bucket = input.bucket || this.opts.bucket || '';\n  const key = input.key;\n  let uploadId = '';\n  let tasks: Task[] = [];\n  const allTasks: Task[] = getAllTasks(fileSize, partSize);\n  const initConsumedBytes = (checkpointRichInfo.record?.parts_info || [])\n    .filter((it) => it.is_completed)\n    .reduce((prev, it) => prev + it.part_size, 0);\n  let consumedBytesForProgress = initConsumedBytes;\n\n  // recorded tasks\n  const recordedTasks = checkpointRichInfo.record?.parts_info || [];\n  const recordedTaskMap: Map<number, CheckpointRecordPart> = new Map();\n  recordedTasks.forEach((it) => recordedTaskMap.set(it.part_number, it));\n\n  const getCheckpointContent = () => {\n    const checkpointContent: CheckpointRecord = {\n      bucket,\n      key,\n      part_size: partSize,\n      upload_id: uploadId,\n      parts_info: recordedTasks,\n    };\n    if (fileStats) {\n      checkpointContent.file_info = {\n        last_modified: fileStats.mtimeMs,\n        file_size: fileStats.size,\n      };\n    }\n    return checkpointContent;\n  };\n  const triggerUploadEvent = (\n    e: Omit<UploadEvent, 'bucket' | 'uploadId' | 'key' | 'checkpointFile'>\n  ) => {\n    if (!input.uploadEventChange) {\n      return;\n    }\n\n    const event: UploadEvent = {\n      bucket,\n      uploadId,\n      key,\n      ...e,\n    };\n    if (checkpointRichInfo.filePath) {\n      event.checkpointFile = checkpointRichInfo.filePath;\n    }\n\n    input.uploadEventChange(event);\n  };\n  enum TriggerProgressEventType {\n    start = 1,\n    uploadPartSucceed = 2,\n    completeMultipartUploadSucceed = 3,\n  }\n  const triggerProgressEvent = (type: TriggerProgressEventType) => {\n    if (!input.progress) {\n      return;\n    }\n\n    const percent = (() => {\n      if (type === TriggerProgressEventType.start && fileSize === 0) {\n        return 0;\n      }\n      return !fileSize ? 1 : consumedBytesForProgress / fileSize;\n    })();\n\n    if (\n      consumedBytesForProgress === fileSize &&\n      type === TriggerProgressEventType.uploadPartSucceed\n    ) {\n      // 100%  complete  100% \n    } else {\n      input.progress(percent, getCheckpointContent());\n    }\n  };\n  let consumedBytes = initConsumedBytes;\n  const { dataTransferStatusChange } = input;\n  const triggerDataTransfer = (\n    type: DataTransferType,\n    rwOnceBytes: number = 0\n  ) => {\n    if (!dataTransferStatusChange) {\n      return;\n    }\n    consumedBytes += rwOnceBytes;\n\n    dataTransferStatusChange?.({\n      type,\n      rwOnceBytes,\n      consumedBytes,\n      totalBytes: fileSize,\n    });\n  };\n  const writeCheckpointFile = makeSerialAsyncTask(async () => {\n    if (\n      process.env.TARGET_ENVIRONMENT === 'node' &&\n      checkpointRichInfo.filePath\n    ) {\n      const content = JSON.stringify(getCheckpointContent(), null, 2);\n      const dirPath = path.dirname(checkpointRichInfo.filePath); // ensure directory exist\n      await fsp.safeMkdirRecursive(dirPath);\n      await fsp.writeFile(checkpointRichInfo.filePath, content, 'utf-8');\n    }\n  });\n  const rmCheckpointFile = async () => {\n    if (\n      process.env.TARGET_ENVIRONMENT === 'node' &&\n      checkpointRichInfo.filePath\n    ) {\n      await fsp.rm(checkpointRichInfo.filePath).catch((err: any) => {\n        // eat err\n        console.warn(\n          'remove checkpoint file failure, you can remove it by hand.\\n',\n          `checkpoint file path: ${checkpointRichInfo.filePath}\\n`,\n          err.message\n        );\n      });\n    }\n  };\n\n  /**\n   *\n   * @param task one part task\n   * @param uploadPartRes upload part failed if `uploadPartRes` is Error\n   */\n  const updateAfterUploadPart = async (\n    task: Task,\n    uploadPartRes:\n      | {\n          res: UploadPartOutput;\n          err?: null;\n        }\n      | {\n          err: Error;\n        }\n  ) => {\n    let existRecordTask = recordedTaskMap.get(task.partNumber);\n    if (!existRecordTask) {\n      existRecordTask = {\n        part_number: task.partNumber,\n        offset: task.offset,\n        part_size: task.partSize,\n        is_completed: false,\n        etag: '',\n        hash_crc64ecma: '',\n      };\n      recordedTasks.push(existRecordTask);\n      recordedTaskMap.set(existRecordTask.part_number, existRecordTask);\n    }\n\n    if (!uploadPartRes.err) {\n      existRecordTask.is_completed = true;\n      existRecordTask.etag = uploadPartRes.res.ETag;\n      existRecordTask.hash_crc64ecma = uploadPartRes.res.hashCrc64ecma;\n    }\n\n    await writeCheckpointFile();\n    const uploadPartInfo: UploadPartInfo = {\n      partNumber: existRecordTask.part_number,\n      partSize: existRecordTask.part_size,\n      offset: existRecordTask.offset,\n    };\n\n    if (uploadPartRes.err) {\n      const err = uploadPartRes.err;\n      let type: UploadEventType = UploadEventType.UploadPartFailed;\n\n      if (err instanceof TosServerError) {\n        if (ABORT_ERROR_STATUS_CODE.includes(err.statusCode)) {\n          type = UploadEventType.UploadPartAborted;\n        }\n      }\n\n      triggerUploadEvent({\n        type,\n        err,\n        uploadPartInfo,\n      });\n      return;\n    }\n\n    uploadPartInfo.etag = uploadPartRes.res.ETag;\n    consumedBytesForProgress += uploadPartInfo.partSize;\n\n    triggerUploadEvent({\n      type: UploadEventType.UploadPartSucceed,\n      uploadPartInfo,\n    });\n    triggerProgressEvent(TriggerProgressEventType.uploadPartSucceed);\n  };\n\n  if (checkpointRichInfo.record) {\n    bucket = checkpointRichInfo.record.bucket;\n    uploadId = checkpointRichInfo.record.upload_id;\n\n    // checkpoint info exists, so need to calculate remain tasks\n    const uploadedPartSet: Set<number> = new Set(\n      (checkpointRichInfo.record.parts_info || [])\n        .filter((it) => it.is_completed)\n        .map((it) => it.part_number)\n    );\n    tasks = allTasks.filter((it) => !uploadedPartSet.has(it.partNumber));\n  } else {\n    // createMultipartUpload will check bucket\n    try {\n      const { data: multipartRes } = await createMultipartUpload.call(\n        this,\n        input\n      );\n      if (isCancel()) {\n        throw new CancelError('cancel uploadFile');\n      }\n\n      bucket = multipartRes.Bucket;\n      uploadId = multipartRes.UploadId;\n      if (checkpointRichInfo.filePathIsPlaceholder) {\n        checkpointRichInfo.filePath = checkpointRichInfo.filePath?.replace(\n          `${CHECKPOINT_FILE_NAME_PLACEHOLDER}`,\n          getDefaultCheckpointFilePath(bucket, key)\n        );\n      }\n\n      triggerUploadEvent({\n        type: UploadEventType.CreateMultipartUploadSucceed,\n      });\n    } catch (_err) {\n      const err = _err as Error;\n      triggerUploadEvent({\n        type: UploadEventType.CreateMultipartUploadFailed,\n        err,\n      });\n      throw err;\n    }\n\n    tasks = allTasks;\n  }\n\n  triggerProgressEvent(TriggerProgressEventType.start);\n  const handleTasks = async () => {\n    let firstErr: Error | null = null;\n    const isCancelOrFirstError = () => isCancel() || !!firstErr;\n    let index = 0;\n\n    // TODO: how to test parallel does work, measure time is not right\n    await Promise.all(\n      Array.from({ length: input.taskNum || 1 }).map(async () => {\n        let makeRetryStream: ReturnType<typeof getMakeRetryStream> = undefined;\n        let consumedBytesThisTask = 0;\n        let curTask: Task | null = null;\n        let curErr: any = null;\n\n        try {\n          while (true) {\n            const currentIndex = index++;\n            if (currentIndex >= tasks.length) {\n              return;\n            }\n\n            curTask = tasks[currentIndex];\n            makeRetryStream = getMakeRetryStream(input.file, curTask);\n            function getBody(file: UploadFileInput['file'], task: Task) {\n              const { offset: start, partSize } = task;\n              const end = start + partSize;\n\n              if (makeRetryStream) {\n                return makeRetryStream.make();\n              }\n\n              if (isBlob(file)) {\n                return file.slice(start, end);\n              }\n              if (isBuffer(file)) {\n                return file.slice(start, end);\n              }\n              throw new TosClientError(FILE_PARAM_CHECK_MSG);\n            }\n\n            const { data: uploadPartRes } = await _uploadPart.call(this, {\n              bucket,\n              key,\n              uploadId,\n              body: getBody(input.file, curTask),\n              enableContentMD5,\n              makeRetryStream: makeRetryStream?.make,\n              beforeRetry: () => {\n                consumedBytes -= consumedBytesThisTask;\n                consumedBytesThisTask = 0;\n              },\n              partNumber: curTask.partNumber,\n              headers: {\n                ['content-length']: `${curTask.partSize}`,\n                ['x-tos-server-side-encryption-customer-algorithm']:\n                  headers['x-tos-server-side-encryption-customer-algorithm'],\n                ['x-tos-server-side-encryption-customer-key']:\n                  headers['x-tos-server-side-encryption-customer-key'],\n                ['x-tos-server-side-encryption-customer-key-md5']:\n                  headers['x-tos-server-side-encryption-customer-key-md5'],\n              },\n              dataTransferStatusChange(status) {\n                if (status.type !== DataTransferType.Rw) {\n                  return;\n                }\n                if (isCancelOrFirstError()) {\n                  return;\n                }\n                consumedBytesThisTask += status.rwOnceBytes;\n                triggerDataTransfer(status.type, status.rwOnceBytes);\n              },\n              trafficLimit: input.trafficLimit,\n              rateLimiter: input.rateLimiter,\n            });\n\n            if (isCancel()) {\n              throw new CancelError('cancel uploadFile');\n            }\n            if (firstErr) {\n              // this error is only internal\n              throw new CancelError(\n                'cancel uploadFile by internal error(`firstErr`)'\n              );\n            }\n\n            await updateAfterUploadPart(curTask, { res: uploadPartRes });\n          }\n        } catch (_err) {\n          curErr = _err as any;\n          if (!firstErr) {\n            firstErr = curErr;\n          }\n        }\n\n        try {\n          if (curErr) {\n            if (curTask) {\n              await updateAfterUploadPart(curTask, { err: curErr });\n            }\n          } else {\n            tryDestroy(makeRetryStream?.getLastStream(), curErr);\n            consumedBytes -= consumedBytesThisTask;\n            consumedBytesThisTask = 0;\n          }\n        } catch (err) {\n          log.TOS(\n            'error while clearing resources of `uploadFile` task, err:',\n            err\n          );\n        }\n      })\n    );\n\n    if (firstErr) {\n      throw firstErr;\n    }\n\n    const parts = (getCheckpointContent().parts_info || []).map((it) => ({\n      eTag: it.etag,\n      partNumber: it.part_number,\n    }));\n\n    const [err, res] = await safeAwait(\n      completeMultipartUpload.call(this, {\n        bucket,\n        key,\n        uploadId,\n        parts,\n      })\n    );\n\n    if (err || !res) {\n      triggerUploadEvent({\n        type: UploadEventType.CompleteMultipartUploadFailed,\n      });\n      throw err;\n    }\n\n    triggerUploadEvent({\n      type: UploadEventType.CompleteMultipartUploadSucceed,\n    });\n    triggerProgressEvent(\n      TriggerProgressEventType.completeMultipartUploadSucceed\n    );\n    await rmCheckpointFile();\n\n    if (\n      this.opts.enableCRC &&\n      res.data.HashCrc64ecma &&\n      combineCRCInParts(getCheckpointContent()) !== res.data.HashCrc64ecma\n    ) {\n      throw new TosClientError('crc of entire file mismatch.');\n    }\n\n    return res;\n  };\n\n  triggerDataTransfer(DataTransferType.Started);\n  const [err, res] = await safeAwait(handleTasks());\n  if (err || !res) {\n    triggerDataTransfer(DataTransferType.Failed);\n    throw err;\n  }\n  triggerDataTransfer(DataTransferType.Succeed);\n  return res;\n}\n\nexport default uploadFile;\n\n/**\n *  totalSize  0 Part Server  read request body failed\n */\nfunction getAllTasks(totalSize: number, partSize: number) {\n  const tasks: Task[] = [];\n  for (let i = 0; ; ++i) {\n    const offset = i * partSize;\n    const currPartSize = Math.min(partSize, totalSize - offset);\n\n    tasks.push({\n      offset,\n      partSize: currPartSize,\n      partNumber: i + 1,\n    });\n\n    if ((i + 1) * partSize >= totalSize) {\n      break;\n    }\n  }\n\n  return tasks;\n}\n\nfunction getMakeRetryStream(file: UploadFileInput['file'], task: Task) {\n  const { offset: start, partSize } = task;\n  const end = start + partSize;\n\n  if (process.env.TARGET_ENVIRONMENT === 'node' && typeof file === 'string') {\n    return makeRetryStreamAutoClose(() => {\n      if (!partSize) {\n        return new EmptyReadStream();\n      }\n      return fsp.createReadStream(file, {\n        start,\n        end: end - 1,\n      });\n    });\n  }\n\n  return undefined;\n}\n\nfunction getDefaultCheckpointFilePath(bucket: string, key: string) {\n  const originPath = `${key}.${hashMd5(`${bucket}.${key}`, 'hex')}.upload`;\n  const normalizePath = originPath.replace(/[\\\\/]/g, '');\n  return normalizePath;\n}\n\nfunction combineCRCInParts(cp: CheckpointRecord) {\n  const size = cp.file_info?.file_size || 0;\n  let res = '0';\n  const sortedPartsInfo =\n    cp.parts_info?.sort?.((a, b) => a.part_number - b.part_number) ?? [];\n  for (const part of sortedPartsInfo) {\n    res = combineCrc64(\n      res,\n      part.hash_crc64ecma,\n      Math.min(part.part_size, size - part.offset)\n    );\n  }\n  return res;\n}\n","export enum ACLType {\n  ACLPrivate = 'private',\n  ACLPublicRead = 'public-read',\n  ACLPublicReadWrite = 'public-read-write',\n  ACLAuthenticatedRead = 'authenticated-read',\n  ACLBucketOwnerRead = 'bucket-owner-read',\n  ACLBucketOwnerFullControl = 'bucket-owner-full-control',\n  // only works for object ACL\n  ACLBucketOwnerEntrusted = 'bucket-owner-entrusted',\n  /**\n   * @private unstable value for object ACL\n   */\n  ACLDefault = 'default',\n}\n\nexport enum StorageClassType {\n  // storage-class will inherit from bucket if uploading object without `x-tos-storage-class` header\n  StorageClassStandard = 'STANDARD',\n  StorageClassIa = 'IA',\n  StorageClassArchiveFr = 'ARCHIVE_FR',\n  StorageClassColdArchive = 'COLD_ARCHIVE',\n  StorageClassIntelligentTiering = 'INTELLIGENT_TIERING',\n  StorageClassArchive = 'ARCHIVE',\n}\n\nexport enum MetadataDirectiveType {\n  MetadataDirectiveCopy = 'COPY',\n  MetadataDirectiveReplace = 'REPLACE',\n}\n\nexport enum AzRedundancyType {\n  AzRedundancySingleAz = 'single-az',\n  AzRedundancyMultiAz = 'multi-az',\n}\n\nexport enum PermissionType {\n  PermissionRead = 'READ',\n  PermissionWrite = 'WRITE',\n  PermissionReadAcp = 'READ_ACP',\n  PermissionWriteAcp = 'WRITE_ACP',\n  PermissionFullControl = 'FULL_CONTROL',\n  /**\n   * @private unstable value for ACL\n   */\n  PermissionReadNONLIST = 'READ_NON_LIST',\n}\n\nexport enum GranteeType {\n  GranteeGroup = 'Group',\n  GranteeUser = 'CanonicalUser',\n}\n\nexport enum CannedType {\n  CannedAllUsers = 'AllUsers',\n  CannedAuthenticatedUsers = 'AuthenticatedUsers',\n}\n\nexport enum HttpMethodType {\n  HttpMethodGet = 'GET',\n  HttpMethodPut = 'PUT',\n  HttpMethodPost = 'POST',\n  HttpMethodDelete = 'DELETE',\n  HttpMethodHead = 'HEAD',\n}\n\nexport enum StorageClassInheritDirectiveType {\n  StorageClassInheritDirectiveDestinationBucket = 'DESTINATION_BUCKET',\n  StorageClassInheritDirectiveSourceObject = 'SOURCE_OBJECT',\n}\n\nexport enum ReplicationStatusType {\n  Complete = 'COMPLETE',\n  Pending = 'PENDING',\n  Failed = 'FAILED',\n  Replica = 'REPLICA',\n}\n\nexport enum LifecycleStatusType {\n  Enabled = 'Enabled',\n  Disabled = 'Disabled',\n}\n\nexport enum RedirectType {\n  Mirror = 'Mirror',\n  Async = 'Async',\n}\n\nexport enum StatusType {\n  Enabled = 'Enabled',\n  Disabled = 'Disabled',\n}\n\nexport enum TierType {\n  TierStandard = 'Standard',\n  TierExpedited = 'Expedited',\n  TierBulk = 'Bulk',\n}\n\nexport enum VersioningStatusType {\n  Enabled = 'Enabled',\n  Suspended = 'Suspended',\n  NotSet = '',\n\n  /**\n   * @deprecated use `Enabled` instead\n   */\n  Enable = 'Enabled',\n  /**\n   * @deprecated use `NotSet` instead\n   */\n  Disable = '',\n}\n\n/**\n * @private unstable\n */\nexport enum AccessPointStatusType {\n  Ready = 'READY',\n  Creating = 'CREATING',\n  Created = 'CREATED',\n  Deleting = 'DELETING',\n}\n\n/**\n * @private unstable\n */\nexport enum TransferAccelerationStatusType {\n  Activating = 'AccelerationActivating',\n  Activated = 'AccelerationActivated',\n  Terminated = 'AccelerationTerminated',\n}\n\n/**\n * @private unstable\n */\nexport enum MRAPMirrorBackRedirectPolicyType {\n  ClosestFirst = 'Closest-First',\n  LatestFirst = 'Latest-First',\n}\n\n/**\n * @private unstable\n */\nexport enum WorkflowExecutionStateType {\n  Success = 'Success',\n  Running = 'Running',\n  Submitted = 'Submitted',\n  Failed = 'Failed',\n}\n\n/** @private unstable */\nexport enum FileCompressFlatten {\n  /** Preserve directory structure */\n  KeepStructure = 0,\n  /** Flatten all directory structures */\n  FlattenAll = 1,\n  /** Create directory based on Prefix (Prefix mode only) */\n  PrefixAsDirectory = 2,\n  /** Only package contents under Prefix (Prefix mode only) */\n  PrefixContentsOnly = 3,\n}\n\n/**\n * @private unstable\n */\nexport enum FileUncompressPrefixReplaced {\n  /** No extra prefix added */\n  NoExtraPrefix = 0,\n  /** Use the archive name as the prefix */\n  WithArchiveName = 1,\n  /** Preserve the full archive path */\n  FullArchivePath = 2,\n}\n\n/**\n * @private unstable\n */\nexport enum AccessPointStatus {\n  Enable = 'enable',\n  Disable = 'disable',\n  Creating = 'creating',\n  Deleting = 'deleting',\n}\n\n/**\n * @private unstable\n */\nexport enum AcceleratorPrefetchJobStatus {\n  Null = 'NULL',\n  Idle = 'IDLE',\n  Running = 'RUNNING',\n  Stopping = 'STOPPING',\n  Complete = 'COMPLETE',\n}\n\n/**\n * @private unstable\n */\nexport enum AuditJobStateType {\n  Submitted = 'Submitted',\n  Running = 'Running',\n  Success = 'Success',\n  Failed = 'Failed',\n  Paused = 'Paused',\n  Canceled = 'Canceled',\n}\n\n/**\n * @private unstable\n */\nexport enum AuditScanType {\n  Manifest = 'Manifest',\n  Scan = 'Scan',\n}\n","import TOSBase, { TosResponse } from '../../base';\nimport {\n  createMultipartUpload,\n  CreateMultipartUploadInput,\n} from './createMultipartUpload';\n\nimport { calculateSafePartSize } from './listParts';\nimport { Stats } from 'fs';\nimport { UploadPartOutput, _uploadPart } from './uploadPart';\nimport TosServerError from '../../../TosServerError';\nimport {\n  completeMultipartUpload,\n  CompleteMultipartUploadOutput,\n} from './completeMultipartUpload';\nimport { CancelToken } from 'axios';\nimport * as fsp from '../../../nodejs/fs-promises';\nimport path from 'path';\nimport {\n  makeSerialAsyncTask,\n  safeAwait,\n  safeParseCheckpointFile,\n} from '../../../utils';\nimport { CancelError } from '../../../CancelError';\nimport headObject from '../headObject';\nimport { uploadPartCopy, UploadPartCopyOutput } from './uploadPartCopy';\nimport { Headers } from '../../../interface';\nimport copyObject from '../copyObject';\nimport { getCopySourceHeaderValue, validateCheckpoint } from '../utils';\nimport cloneDeep from 'lodash/cloneDeep';\nimport TosClientError from '../../../TosClientError';\n\nexport interface ResumableCopyObjectInput extends CreateMultipartUploadInput {\n  srcBucket: string;\n  srcKey: string;\n  srcVersionId?: string;\n\n  /**\n   * default is 20 MB\n   */\n  partSize?: number;\n\n  /**\n   * the number of request to parallel upload partdefault value is 1\n   */\n  taskNum?: number;\n\n  /**\n   * if checkpoint is a string and point to a exist file,\n   * the checkpoint record will recover from this file.\n   *\n   * if checkpoint is a string and point to a directory,\n   * the checkpoint will be auto generated,\n   * and its name is\n   * `{srcBucketName}.{srcObjectName}.{srcVersionId}.{bucketName}.{objectName}.copy`.\n   */\n  checkpoint?: string | ResumableCopyCheckpointRecord;\n\n  /**\n   * the callback of copy event\n   */\n  copyEventListener?: (event: ResumableCopyEvent) => void;\n\n  /**\n   * the simple progress feature\n   * percent is [0, 1]\n   */\n  progress?: (\n    percent: number,\n    checkpoint: ResumableCopyCheckpointRecord\n  ) => void;\n\n  /**\n   * is axios CancelToken\n   */\n  cancelToken?: CancelToken;\n\n  /**\n   * unit: bit/s\n   * server side traffic limit\n   **/\n  trafficLimit?: number;\n}\n\nexport interface UploadFileOutput extends CompleteMultipartUploadOutput {}\n\nexport enum ResumableCopyEventType {\n  CreateMultipartUploadSucceed = 1,\n  CreateMultipartUploadFailed = 2,\n  UploadPartCopySucceed = 3,\n  UploadPartCopyFailed = 4,\n  UploadPartCopyAborted = 5,\n  CompleteMultipartUploadSucceed = 6,\n  CompleteMultipartUploadFailed = 7,\n}\n\nexport interface CopyPartInfo {\n  partNumber: number;\n  copySourceRangeStart: number;\n  copySourceRangeEnd: number;\n\n  // has value when upload part succeed\n  etag?: string;\n}\n\nexport interface ResumableCopyEvent {\n  type: ResumableCopyEventType;\n\n  /**\n   * has value when event is failed or aborted\n   */\n  err?: Error;\n\n  bucket: string;\n  key: string;\n  uploadId?: string;\n  checkpointFile?: string;\n  copyPartInfo?: CopyPartInfo;\n}\n\nexport interface ResumableCopyCheckpointRecord {\n  bucket: string;\n  key: string;\n  part_size: number;\n  upload_id: string;\n  parts_info?: ResumableCopyCheckpointRecordPart[];\n  // Information about the file to be uploaded\n  copy_source_object_info: {\n    etag: string;\n    hash_crc64ecma: string;\n    last_modified: string;\n    object_size: number;\n  };\n  // TODO: more information\n}\n\ninterface ResumableCopyCheckpointRecordPart {\n  part_number: number;\n  copy_source_range_start: number;\n  copy_source_range_end: number;\n  etag: string;\n  is_completed: boolean;\n}\n\ninterface CheckpointRichInfo {\n  filePath?: string | undefined;\n\n  filePathIsPlaceholder?: boolean;\n\n  record?: ResumableCopyCheckpointRecord;\n}\n\ninterface Task {\n  partSize: number;\n  offset: number;\n  partNumber: number;\n}\n\nconst CHECKPOINT_FILE_NAME_PLACEHOLDER = '@@checkpoint-file-placeholder@@';\nconst ABORT_ERROR_STATUS_CODE = [403, 404, 405];\nexport const DEFAULT_PART_SIZE = 20 * 1024 * 1024; // 20 MB\n\nexport async function resumableCopyObject(\n  this: TOSBase,\n  input: ResumableCopyObjectInput\n): Promise<TosResponse<UploadFileOutput>> {\n  const { cancelToken } = input;\n  const isCancel = () => cancelToken && !!cancelToken.reason;\n  validateCheckpoint(input.checkpoint);\n\n  const { data: objectStats } = await headObject.call(this, {\n    bucket: input.srcBucket,\n    key: input.srcKey,\n    versionId: input.srcVersionId,\n  });\n  const etag = objectStats['etag'];\n  const objectSize = +objectStats['content-length'];\n\n  const checkpointRichInfo = await (async (): Promise<CheckpointRichInfo> => {\n    if (process.env.TARGET_ENVIRONMENT === 'node') {\n      if (typeof input.checkpoint === 'string') {\n        const { checkpoint } = input;\n        // file doesn't exist when stat is null\n        let checkpointStat: Stats | null = null;\n        try {\n          checkpointStat = await fsp.stat(checkpoint);\n        } catch (_err) {\n          // TODO: remove any\n          const err = _err as any;\n          if (err.code === 'ENOENT') {\n            // file doesn't exist\n          } else {\n            throw err;\n          }\n        }\n\n        const isDirectory = (() => {\n          if (checkpointStat) {\n            return checkpointStat.isDirectory();\n          }\n          return checkpoint.endsWith('/');\n        })();\n\n        // filePath will generated by uploadId, use placeholder temporarily\n        const filePath = isDirectory\n          ? path.resolve(checkpoint, CHECKPOINT_FILE_NAME_PLACEHOLDER)\n          : path.resolve(checkpoint);\n        const dirPath = path.dirname(filePath);\n        // ensure directory exist\n        await fsp.safeMkdirRecursive(dirPath);\n\n        if (isDirectory) {\n          return {\n            filePath,\n            filePathIsPlaceholder: true,\n          };\n        }\n\n        return {\n          filePath,\n          filePathIsPlaceholder: false,\n          // filePath is json file\n          // TODO: validate json schema\n          record: checkpointStat\n            ? await safeParseCheckpointFile(filePath)\n            : undefined,\n        };\n      }\n    }\n\n    if (typeof input.checkpoint === 'object') {\n      return {\n        record: input.checkpoint,\n      };\n    }\n\n    return {};\n  })();\n\n  // check if file info is matched\n  await (async () => {\n    if (checkpointRichInfo.record?.copy_source_object_info) {\n      const { last_modified, object_size } =\n        checkpointRichInfo.record?.copy_source_object_info;\n      if (\n        // TODO: `last-modified` aligns to number\n        objectStats['last-modified'] !== last_modified ||\n        +objectStats['content-length'] !== object_size\n      ) {\n        console.warn(\n          `The file has been modified since ${new Date(\n            last_modified\n          )}, so the checkpoint file is invalid, and specified file will be uploaded again.`\n        );\n        delete checkpointRichInfo.record;\n      }\n    }\n  })();\n\n  const partSize = calculateSafePartSize(\n    objectSize,\n    input.partSize || checkpointRichInfo.record?.part_size || DEFAULT_PART_SIZE,\n    true\n  );\n\n  // check partSize is matched\n  if (\n    checkpointRichInfo.record &&\n    checkpointRichInfo.record.part_size !== partSize\n  ) {\n    console.warn(\n      'The partSize param does not equal the partSize in checkpoint file, ' +\n        'so the checkpoint file is invalid, and specified file will be uploaded again.'\n    );\n    delete checkpointRichInfo.record;\n  }\n\n  let bucket = input.bucket || this.opts.bucket || '';\n  const key = input.key;\n  let uploadId = '';\n  let tasks: Task[] = [];\n  const allTasks: Task[] = getAllTasks(objectSize, partSize);\n  const initConsumedBytes = (checkpointRichInfo.record?.parts_info || [])\n    .filter((it) => it.is_completed)\n    .reduce(\n      (prev, it) =>\n        prev + it.copy_source_range_end - it.copy_source_range_start + 1,\n      0\n    );\n  let consumedBytesForProgress = initConsumedBytes;\n\n  // recorded tasks\n  const recordedTasks = checkpointRichInfo.record?.parts_info || [];\n  const recordedTaskMap: Map<number, ResumableCopyCheckpointRecordPart> =\n    new Map();\n  recordedTasks.forEach((it) => recordedTaskMap.set(it.part_number, it));\n\n  const getCheckpointContent = () => {\n    const checkpointContent: ResumableCopyCheckpointRecord = {\n      bucket,\n      key,\n      part_size: partSize,\n      upload_id: uploadId,\n      parts_info: recordedTasks,\n      copy_source_object_info: {\n        last_modified: objectStats['last-modified'],\n        etag: objectStats.etag,\n        hash_crc64ecma: objectStats['x-tos-hash-crc64ecma'] || '',\n        object_size: +objectStats['content-length'],\n      },\n    };\n    return checkpointContent;\n  };\n  const triggerUploadEvent = (\n    e: Omit<\n      ResumableCopyEvent,\n      'bucket' | 'uploadId' | 'key' | 'checkpointFile'\n    >\n  ) => {\n    if (!input.copyEventListener) {\n      return;\n    }\n\n    const event: ResumableCopyEvent = {\n      bucket,\n      uploadId,\n      key,\n      ...e,\n    };\n    if (checkpointRichInfo.filePath) {\n      event.checkpointFile = checkpointRichInfo.filePath;\n    }\n\n    input.copyEventListener(event);\n  };\n  enum TriggerProgressEventType {\n    start = 1,\n    uploadPartSucceed = 2,\n    completeMultipartUploadSucceed = 3,\n  }\n  const triggerProgressEvent = (type: TriggerProgressEventType) => {\n    if (!input.progress) {\n      return;\n    }\n\n    const percent = (() => {\n      if (type === TriggerProgressEventType.start && objectSize === 0) {\n        return 0;\n      }\n      return !objectSize ? 1 : consumedBytesForProgress / objectSize;\n    })();\n\n    if (\n      consumedBytesForProgress === objectSize &&\n      type === TriggerProgressEventType.uploadPartSucceed\n    ) {\n      // 100%  complete  100% \n    } else {\n      input.progress(percent, getCheckpointContent());\n    }\n  };\n\n  const writeCheckpointFile = makeSerialAsyncTask(async () => {\n    if (\n      process.env.TARGET_ENVIRONMENT === 'node' &&\n      checkpointRichInfo.filePath\n    ) {\n      const content = JSON.stringify(getCheckpointContent(), null, 2);\n      const dirPath = path.dirname(checkpointRichInfo.filePath); // ensure directory exist\n      await fsp.safeMkdirRecursive(dirPath);\n      await fsp.writeFile(checkpointRichInfo.filePath, content, 'utf-8');\n    }\n  });\n  const rmCheckpointFile = async () => {\n    if (\n      process.env.TARGET_ENVIRONMENT === 'node' &&\n      checkpointRichInfo.filePath\n    ) {\n      await fsp.rm(checkpointRichInfo.filePath).catch((err: any) => {\n        // eat err\n        console.warn(\n          'remove checkpoint file failure, you can remove it by hand.\\n',\n          `checkpoint file path: ${checkpointRichInfo.filePath}\\n`,\n          err.message\n        );\n      });\n    }\n  };\n\n  /**\n   *\n   * @param task one part task\n   * @param uploadPartRes upload part failed if `uploadPartRes` is Error\n   */\n  const updateAfterUploadPart = async (\n    task: Task,\n    uploadPartRes:\n      | {\n          res: UploadPartCopyOutput;\n          err?: null;\n        }\n      | {\n          err: Error;\n        }\n  ) => {\n    let existRecordTask = recordedTaskMap.get(task.partNumber);\n    const rangeStart = task.offset;\n    const rangeEnd = Math.min(task.offset + partSize - 1, objectSize - 1);\n    if (!existRecordTask) {\n      existRecordTask = {\n        part_number: task.partNumber,\n        copy_source_range_start: rangeStart,\n        copy_source_range_end: rangeEnd,\n        is_completed: false,\n        etag: '',\n      };\n      recordedTasks.push(existRecordTask);\n      recordedTaskMap.set(existRecordTask.part_number, existRecordTask);\n    }\n\n    if (!uploadPartRes.err) {\n      existRecordTask.is_completed = true;\n      existRecordTask.etag = uploadPartRes.res.ETag;\n    }\n\n    await writeCheckpointFile();\n    const copyPartInfo: CopyPartInfo = {\n      partNumber: existRecordTask.part_number,\n      copySourceRangeEnd: existRecordTask.copy_source_range_end,\n      copySourceRangeStart: existRecordTask.copy_source_range_start,\n    };\n\n    if (uploadPartRes.err) {\n      const err = uploadPartRes.err;\n      let type: ResumableCopyEventType =\n        ResumableCopyEventType.UploadPartCopyFailed;\n\n      if (err instanceof TosServerError) {\n        if (ABORT_ERROR_STATUS_CODE.includes(err.statusCode)) {\n          type = ResumableCopyEventType.UploadPartCopyAborted;\n        }\n      }\n\n      triggerUploadEvent({\n        type,\n        err,\n        copyPartInfo,\n      });\n      return;\n    }\n\n    copyPartInfo.etag = uploadPartRes.res.ETag;\n    consumedBytesForProgress +=\n      copyPartInfo.copySourceRangeEnd - copyPartInfo.copySourceRangeStart + 1;\n\n    triggerUploadEvent({\n      type: ResumableCopyEventType.UploadPartCopySucceed,\n      copyPartInfo,\n    });\n    triggerProgressEvent(TriggerProgressEventType.uploadPartSucceed);\n  };\n\n  if (checkpointRichInfo.record) {\n    bucket = checkpointRichInfo.record.bucket;\n    uploadId = checkpointRichInfo.record.upload_id;\n\n    // checkpoint info exists, so need to calculate remain tasks\n    const uploadedPartSet: Set<number> = new Set(\n      (checkpointRichInfo.record.parts_info || [])\n        .filter((it) => it.is_completed)\n        .map((it) => it.part_number)\n    );\n    tasks = allTasks.filter((it) => !uploadedPartSet.has(it.partNumber));\n  } else {\n    // createMultipartUpload will check bucket\n    try {\n      const { data: multipartRes } = await createMultipartUpload.call(\n        this,\n        cloneDeep(input)\n      );\n      if (isCancel()) {\n        throw new CancelError('cancel uploadFile');\n      }\n\n      bucket = multipartRes.Bucket;\n      uploadId = multipartRes.UploadId;\n      if (checkpointRichInfo.filePathIsPlaceholder) {\n        checkpointRichInfo.filePath = checkpointRichInfo.filePath?.replace(\n          `${CHECKPOINT_FILE_NAME_PLACEHOLDER}`,\n          getDefaultCheckpointFilePath({\n            ...input,\n            bucket,\n          })\n        );\n      }\n\n      triggerUploadEvent({\n        type: ResumableCopyEventType.CreateMultipartUploadSucceed,\n      });\n    } catch (_err) {\n      const err = _err as Error;\n      triggerUploadEvent({\n        type: ResumableCopyEventType.CreateMultipartUploadFailed,\n        err,\n      });\n      throw err;\n    }\n\n    tasks = allTasks;\n  }\n\n  const handleTasks = async () => {\n    let firstErr: Error | null = null;\n    let index = 0;\n\n    // TODO: how to test parallel does work, measure time is not right\n    await Promise.all(\n      Array.from({ length: input.taskNum || 1 }).map(async () => {\n        while (true) {\n          const currentIndex = index++;\n          if (currentIndex >= tasks.length) {\n            return;\n          }\n\n          const curTask = tasks[currentIndex];\n          try {\n            let copySource = getCopySourceHeaderValue(\n              input.srcBucket,\n              input.srcKey\n            );\n            if (input.srcVersionId) {\n              copySource += `?versionId=${input.srcVersionId}`;\n            }\n            const copyRange = `bytes=${curTask.offset}-${\n              curTask.offset + curTask.partSize - 1\n            }`;\n            const headers: Headers = {\n              ...input.headers,\n              ['x-tos-copy-source']: copySource,\n              ['x-tos-copy-source-if-match']: etag,\n              ['x-tos-copy-source-range']: copyRange,\n            };\n\n            if (!curTask.partSize) {\n              delete headers['x-tos-copy-source-range'];\n            }\n            const { data: uploadPartRes } = await uploadPartCopy.call(this, {\n              bucket,\n              key,\n              uploadId,\n              partNumber: curTask.partNumber,\n              headers,\n              trafficLimit: input.trafficLimit,\n            });\n\n            if (isCancel()) {\n              throw new CancelError('cancel resumableCopyObject');\n            }\n\n            await updateAfterUploadPart(curTask, { res: uploadPartRes });\n          } catch (_err) {\n            const err = _err as any;\n\n            if (isCancelError(err)) {\n              throw err;\n            }\n\n            if (isCancel()) {\n              throw new CancelError('cancel resumableCopyObject');\n            }\n\n            if (!firstErr) {\n              firstErr = err;\n            }\n            await updateAfterUploadPart(curTask, { err });\n          }\n        }\n      })\n    );\n\n    if (firstErr) {\n      throw firstErr;\n    }\n\n    const parts = (getCheckpointContent().parts_info || []).map((it) => ({\n      eTag: it.etag,\n      partNumber: it.part_number,\n    }));\n\n    const [err, res] = await safeAwait(\n      completeMultipartUpload.call(this, {\n        bucket,\n        key,\n        uploadId,\n        parts,\n      })\n    );\n\n    if (err || !res) {\n      triggerUploadEvent({\n        type: ResumableCopyEventType.CompleteMultipartUploadFailed,\n      });\n      throw err;\n    }\n\n    triggerUploadEvent({\n      type: ResumableCopyEventType.CompleteMultipartUploadSucceed,\n    });\n    triggerProgressEvent(\n      TriggerProgressEventType.completeMultipartUploadSucceed\n    );\n\n    const sourceCRC64 =\n      getCheckpointContent().copy_source_object_info.hash_crc64ecma;\n    const actualCrc64 = res.data.HashCrc64ecma;\n    if (\n      this.opts.enableCRC &&\n      sourceCRC64 &&\n      actualCrc64 &&\n      sourceCRC64 !== actualCrc64\n    ) {\n      throw new TosClientError(\n        `validate file crc64 failed. Expect crc64 ${sourceCRC64}, actual crc64 ${actualCrc64}. Please try again.`\n      );\n    }\n\n    await rmCheckpointFile();\n\n    return res;\n  };\n\n  const handleEmptyObj = async (): Promise<TosResponse<UploadFileOutput>> => {\n    let copySource = getCopySourceHeaderValue(input.srcBucket, input.srcKey);\n    if (input.srcVersionId) {\n      copySource += `?versionId=${input.srcVersionId}`;\n    }\n    const headers: Headers = {\n      ...input.headers,\n      ['x-tos-copy-source']: copySource,\n      ['x-tos-copy-source-if-match']: etag,\n    };\n\n    const [err, res] = await safeAwait(\n      copyObject.call(this, {\n        bucket: input.bucket,\n        key: input.key,\n        headers,\n        trafficLimit: input.trafficLimit,\n      })\n    );\n    if (err || !res) {\n      triggerUploadEvent({\n        type: ResumableCopyEventType.UploadPartCopyFailed,\n      });\n      throw err;\n    }\n\n    triggerProgressEvent(\n      TriggerProgressEventType.completeMultipartUploadSucceed\n    );\n    triggerUploadEvent({\n      type: ResumableCopyEventType.UploadPartCopySucceed,\n      copyPartInfo: {\n        partNumber: 0,\n        copySourceRangeStart: 0,\n        copySourceRangeEnd: 0,\n      },\n    });\n    triggerUploadEvent({\n      type: ResumableCopyEventType.CompleteMultipartUploadSucceed,\n    });\n\n    return {\n      ...res,\n      data: {\n        ETag: res.headers['etag'] || '',\n        Bucket: bucket,\n        Key: key,\n        Location: `http${this.opts.secure ? 's' : ''}://${bucket}.${\n          this.opts.endpoint\n        }/${key}`,\n        VersionID: res.headers['x-tos-version-id'],\n        HashCrc64ecma: res.headers['x-tos-hash-crc64ecma'],\n      },\n    };\n  };\n\n  triggerProgressEvent(TriggerProgressEventType.start);\n  return objectSize === 0 ? handleEmptyObj() : handleTasks();\n}\n\nexport function isCancelError(err: any) {\n  return err instanceof CancelError;\n}\n\nexport default resumableCopyObject;\n\n/**\n *  totalSize  0 Part Server  read request body failed\n */\nfunction getAllTasks(totalSize: number, partSize: number) {\n  const tasks: Task[] = [];\n  for (let i = 0; ; ++i) {\n    const offset = i * partSize;\n    const currPartSize = Math.min(partSize, totalSize - offset);\n\n    tasks.push({\n      offset,\n      partSize: currPartSize,\n      partNumber: i + 1,\n    });\n\n    if ((i + 1) * partSize >= totalSize) {\n      break;\n    }\n  }\n\n  return tasks;\n}\n\nfunction getDefaultCheckpointFilePath(\n  opts: Pick<\n    ResumableCopyObjectInput,\n    'srcBucket' | 'srcKey' | 'srcVersionId' | 'key'\n  > & {\n    bucket: string;\n  }\n) {\n  const originPath = [\n    opts.srcBucket,\n    opts.srcKey,\n    opts.srcVersionId,\n    opts.bucket,\n    opts.key,\n    'copy',\n  ]\n    .filter(Boolean)\n    .join('.');\n\n  const normalizePath = originPath.replace(/[\\\\/]/g, '');\n  return normalizePath;\n}\n","import { StorageClass } from '../../interface';\nimport { fillRequestHeaders, normalizeHeadersKey } from '../../utils';\nimport TOSBase from '../base';\nimport { ReplicationStatusType } from '../../TosExportEnum';\nimport { RestoreInfo, TosHeader } from './sharedTypes';\nimport { getRestoreInfoFromHeaders } from './utils';\n\nexport interface HeadObjectInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n\n  ifMatch?: string;\n  ifModifiedSince?: string;\n  ifNoneMatch?: string;\n  ifUnmodifiedSince?: string;\n\n  ssecAlgorithm?: string;\n  ssecKey?: string;\n  ssecKeyMD5?: string;\n\n  headers?: {\n    [key: string]: string | undefined;\n    'If-Match'?: string;\n    'If-Modified-Since'?: string;\n    'If-None-Match'?: string;\n    'If-Unmodified-Since'?: string;\n    'x-tos-server-side-encryption-customer-algorithm'?: string;\n    'x-tos-server-side-encryption-customer-key'?: string;\n    'x-tos-server-side-encryption-customer-key-md5'?: string;\n  };\n}\n\nexport interface HeadObjectOutput {\n  [key: string]: string | undefined | object;\n  'content-length': string;\n  'last-modified': string;\n  'content-md5': string;\n  etag: string;\n  'x-tos-object-type'?: 'Appendable' | 'Symlink';\n  'x-tos-delete-marker'?: string;\n  'x-tos-server-side-encryption-customer-algorithm'?: string;\n  'x-tos-server-side-encryption-customer-key-md5'?: string;\n  'x-tos-version-id'?: string;\n  'x-tos-website-redirect-location'?: string;\n  'x-tos-hash-crc64ecma'?: string;\n  'x-tos-storage-class': StorageClass;\n  'x-tos-server-side-encryption'?: string;\n  'x-tos-replication-status'?: ReplicationStatusType;\n  'x-tos-symlink-target-size'?: string;\n  RestoreInfo?: RestoreInfo;\n  ReplicationStatus?: ReplicationStatusType;\n}\n\nexport async function headObject(\n  this: TOSBase,\n  input: HeadObjectInput | string\n) {\n  const normalizedInput = typeof input === 'string' ? { key: input } : input;\n  const headers = normalizeHeadersKey(normalizedInput.headers);\n  normalizedInput.headers = headers;\n\n  const query: Record<string, any> = {};\n  if (normalizedInput.versionId) {\n    query.versionId = normalizedInput.versionId;\n  }\n\n  fillRequestHeaders(normalizedInput, [\n    'ifMatch',\n    'ifModifiedSince',\n    'ifNoneMatch',\n    'ifUnmodifiedSince',\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n  ]);\n\n  return this._fetchObject<HeadObjectOutput>(\n    input,\n    'HEAD',\n    query,\n    normalizedInput?.headers || {},\n    undefined,\n    {\n      handleResponse: (res) => {\n        const result = {\n          ...res.headers,\n          ReplicationStatus: res.headers[TosHeader.HeaderReplicationStatus],\n        };\n        const info = getRestoreInfoFromHeaders(res.headers);\n\n        if (info) {\n          result.RestoreInfo = info;\n        }\n        return result;\n      },\n    }\n  );\n}\n\nexport default headObject;\n","import {\n  fillRequestHeaders,\n  safeAwait,\n  normalizeHeadersKey,\n  requestHeadersMap,\n} from '../../../utils';\nimport TOSBase from '../../base';\nimport { getCopySourceHeaderValue } from '../utils';\n\nexport interface UploadPartCopyInput {\n  bucket?: string;\n  key: string;\n  partNumber: number;\n  uploadId: string;\n\n  srcBucket?: string;\n  srcKey?: string;\n  srcVersionID?: string;\n  copySourceRange?: string;\n  copySourceRangeStart?: number;\n  copySourceRangeEnd?: number;\n  copySourceSSECAlgorithm?: string;\n  copySourceSSECKey?: string;\n  copySourceSSECKeyMD5?: string;\n  ssecAlgorithm?: string;\n  ssecKey?: string;\n  ssecKeyMD5?: string;\n  /**\n   * unit: bit/s\n   * server side traffic limit\n   **/\n  trafficLimit?: number;\n  headers?: {\n    [key: string]: string | undefined;\n    'x-tos-copy-source'?: string;\n    'x-tos-copy-source-range'?: string;\n    'x-tos-copy-source-if-match'?: string;\n    'x-tos-copy-source-if-modified-since'?: string;\n    'x-tos-copy-source-if-none-match'?: string;\n    'x-tos-copy-source-if-unmodified-since'?: string;\n    'x-tos-copy-source-server-side-encryption-customer-algorithm'?: string;\n    'x-tos-copy-source-server-side-encryption-customer-key'?: string;\n    'x-tos-copy-source-server-side-encryption-customer-key-MD5'?: string;\n  };\n}\n\nexport interface UploadPartCopyOutput {\n  ETag: string;\n  LastModified: string;\n  SSECAlgorithm: string;\n  SSECKeyMD5: string;\n}\n\nexport async function uploadPartCopy(\n  this: TOSBase,\n  input: UploadPartCopyInput\n) {\n  const { uploadId, partNumber } = input;\n  const headers = normalizeHeadersKey(input.headers);\n  input.headers = headers;\n  fillRequestHeaders(input, [\n    'copySourceRange',\n    'copySourceSSECAlgorithm',\n    'copySourceSSECKey',\n    'copySourceSSECKeyMD5',\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n    'trafficLimit',\n  ]);\n  if (input.srcBucket && input.srcKey) {\n    let copySource = getCopySourceHeaderValue(input.srcBucket, input.srcKey);\n    if (input.srcVersionID) {\n      copySource += `?versionId=${input.srcVersionID}`;\n    }\n    headers['x-tos-copy-source'] = headers['x-tos-copy-source'] ?? copySource;\n  }\n\n  if (\n    input.copySourceRange == null &&\n    (input.copySourceRangeStart != null || input.copySourceRangeEnd != null)\n  ) {\n    const start =\n      input.copySourceRangeStart != null ? `${input.copySourceRangeStart}` : '';\n    const end =\n      input.copySourceRangeEnd != null ? `${input.copySourceRangeEnd}` : '';\n    const copyRange = `bytes=${start}-${end}`;\n    headers['x-tos-copy-source-range'] =\n      headers['x-tos-copy-source-range'] ?? copyRange;\n  }\n\n  const [err, res] = await safeAwait(\n    this._fetchObject<UploadPartCopyOutput>(\n      input,\n      'PUT',\n      { partNumber, uploadId },\n      headers,\n      undefined,\n      {\n        handleResponse(response) {\n          return {\n            ...response.data,\n            SSECAlgorithm:\n              response.headers[requestHeadersMap['ssecAlgorithm'] as string],\n            SSECKeyMD5:\n              response.headers[requestHeadersMap['ssecKeyMD5'] as string],\n          };\n        },\n      }\n    )\n  );\n\n  if (err || !res || !res.data.ETag) {\n    // TODO: throw TosServerErr\n    throw err;\n  }\n\n  return res;\n}\n","import {\n  safeAwait,\n  normalizeHeadersKey,\n  fillRequestHeaders,\n} from '../../utils';\nimport { StorageClass, ServerSideEncryption, Acl } from '../../interface';\nimport TOSBase, { TosResponse } from '../base';\nimport { StorageClassType } from '../../TosExportEnum';\nimport { getCopySourceHeaderValue } from './utils';\n\nexport interface CopyObjectInput {\n  bucket?: string;\n  key: string;\n\n  srcBucket?: string;\n  srcKey?: string;\n  srcVersionID?: string;\n  cacheControl?: string;\n  contentDisposition?: string;\n  contentEncoding?: string;\n  contentLanguage?: string;\n  contentType?: string;\n  expires?: Date;\n\n  copySourceIfMatch?: string;\n  copySourceIfModifiedSince?: string | Date;\n  copySourceIfNoneMatch?: string;\n  copySourceIfUnmodifiedSince?: string;\n  copySourceSSECAlgorithm?: string;\n  copySourceSSECKey?: string;\n  copySourceSSECKeyMD5?: string;\n\n  ssecAlgorithm?: string;\n  ssecKey?: string;\n  ssecKeyMD5?: string;\n  serverSideEncryption?: string;\n  /**\n   * unit: bit/s\n   * server side traffic limit\n   **/\n  trafficLimit?: number;\n\n  acl?: Acl;\n  grantFullControl?: string;\n  grantRead?: string;\n  grantReadAcp?: string;\n  grantWriteAcp?: string;\n\n  metadataDirective?: string;\n  meta?: Record<string, string>;\n  websiteRedirectLocation?: string;\n  storageClass?: StorageClassType;\n  ifMatch?: string;\n  forbidOverwrite?: boolean;\n\n  headers?: {\n    [key: string]: string | undefined;\n    ['x-tos-copy-source']?: string;\n    ['x-tos-acl']?: string;\n    ['x-tos-copy-source-if-match']?: string;\n    ['x-tos-copy-source-if-modified-since']?: string;\n    ['x-tos-copy-source-if-none-match']?: string;\n    ['x-tos-copy-source-if-unmodified-since']?: string;\n    ['x-tos-copy-source-server-side-encryption-customer-algorithm']?: string;\n    ['x-tos-copy-source-server-side-encryption-customer-key']?: string;\n    ['x-tos-copy-source-server-side-encryption-customer-key-MD5']?: string;\n    ['x-tos-grant-full-control']?: string;\n    ['x-tos-grant-read']?: string;\n    ['x-tos-grant-read-acp']?: string;\n    ['x-tos-metadata-directive']?: string;\n    ['x-tos-website-redirect-location']?: string;\n    ['x-tos-storage-class']?: StorageClass;\n    ['x-tos-server-side-encryption']?: ServerSideEncryption;\n    ['x-tos-forbid-overwrite']?: string;\n    'If-Match'?: string;\n  };\n}\n\ninterface CopyObjectBody {\n  ETag: string;\n}\n\nexport interface CopyObjectOutput extends CopyObjectBody {}\n\nexport async function copyObject(\n  this: TOSBase,\n  input: CopyObjectInput\n): Promise<TosResponse<CopyObjectOutput>> {\n  const headers = normalizeHeadersKey(input.headers);\n  input.headers = headers;\n  fillRequestHeaders(input, [\n    'cacheControl',\n    'contentDisposition',\n    'contentEncoding',\n    'contentLanguage',\n    'contentType',\n    'expires',\n\n    'copySourceIfMatch',\n    'copySourceIfModifiedSince',\n    'copySourceIfNoneMatch',\n    'copySourceIfUnmodifiedSince',\n    'copySourceSSECAlgorithm',\n    'copySourceSSECKey',\n    'copySourceSSECKeyMD5',\n\n    'acl',\n    'grantFullControl',\n    'grantRead',\n    'grantReadAcp',\n    'grantWriteAcp',\n\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n    'serverSideEncryption',\n\n    'metadataDirective',\n    'meta',\n    'websiteRedirectLocation',\n    'storageClass',\n    'trafficLimit',\n    'forbidOverwrite',\n    'ifMatch',\n  ]);\n  if (input.srcBucket && input.srcKey) {\n    let copySource = getCopySourceHeaderValue(input.srcBucket, input.srcKey);\n    if (input.srcVersionID) {\n      copySource += `?versionId=${input.srcVersionID}`;\n    }\n    headers['x-tos-copy-source'] = headers['x-tos-copy-source'] ?? copySource;\n  }\n\n  const [err, res] = await safeAwait(\n    this._fetchObject<CopyObjectBody>(input, 'PUT', {}, headers)\n  );\n\n  if (err || !res || !res.data.ETag) {\n    // TODO: throw TosServerErr\n    throw err;\n  }\n  return res;\n}\n\nexport default copyObject;\n","import { createWriteStream } from '../../nodejs/fs-promises';\nimport TosClientError from '../../TosClientError';\nimport { DataTransferStatus, DataTransferType, Headers } from '../../interface';\nimport {\n  fillRequestHeaders,\n  fillRequestQuery,\n  streamToBuf,\n  isReadable,\n  normalizeHeadersKey,\n  safeAwait,\n} from '../../utils';\nimport TOSBase, { TosResponse } from '../base';\nimport {\n  IRateLimiter,\n  createRateLimiterStream,\n} from '../../universal/rate-limiter';\nimport { getRestoreInfoFromHeaders, isValidRateLimiter } from './utils';\nimport { createReadNReadStream } from '../../nodejs/EmitReadStream';\nimport { RestoreInfo, TosHeader } from './sharedTypes';\nimport { ReplicationStatusType } from '../../TosExportEnum';\n\nexport interface GetObjectInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n\n  headers?: {\n    [key: string]: string | undefined;\n    'If-Modified-Since'?: string;\n    'If-Unmodified-Since'?: string;\n    'If-Match'?: string;\n    'If-None-Match'?: string;\n    'x-tos-server-side-encryption-customer-key'?: string;\n    'x-tos-server-side-encryption-customer-key-md5'?: string;\n    'x-tos-server-side-encryption-customer-algorithm'?: string;\n    Range?: string;\n  };\n  response?: Headers & {\n    'cache-control'?: string;\n    'content-disposition'?: string;\n    'content-encoding'?: string;\n    'content-language'?: string;\n    'content-type'?: string;\n    expires?: string;\n  };\n}\n\n/**\n * @deprecated use getObjectV2 instead\n * @returns arraybuffer\n */\nexport async function getObject(this: TOSBase, input: GetObjectInput | string) {\n  const normalizedInput = typeof input === 'string' ? { key: input } : input;\n  const query: Record<string, any> = {};\n  if (normalizedInput.versionId) {\n    query.versionId = normalizedInput.versionId;\n  }\n  const headers: Headers = normalizeHeadersKey(normalizedInput?.headers);\n  const response: Partial<Headers> = normalizedInput?.response || {};\n  Object.keys(response).forEach((key: string) => {\n    const v = response[key];\n    if (v != null) {\n      query[`response-${key}`] = v;\n    }\n  });\n\n  // TODO: maybe need to return response's headers\n  return this._fetchObject<Buffer>(input, 'GET', query, headers, undefined, {\n    axiosOpts: { responseType: 'arraybuffer' },\n  });\n}\n\ntype DataType = 'stream' | 'buffer' | 'blob';\nexport interface GetObjectV2Input {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n\n  /**\n   * The type of return value, 'stream' | 'blob'\n   * default: 'stream'\n   *\n   * nodejs environment can use 'stream' and 'buffer'\n   * browser environment can use 'blob'\n   */\n  dataType?: DataType;\n\n  ifMatch?: string;\n  ifModifiedSince?: string | Date;\n  ifNoneMatch?: string;\n  ifUnmodifiedSince?: string | Date;\n\n  ssecAlgorithm?: string;\n  ssecKey?: string;\n  ssecKeyMD5?: string;\n  /**\n   * unit: bit/s\n   * server side traffic limit\n   **/\n  trafficLimit?: number;\n  /**\n   * only works for nodejs environment\n   */\n  rateLimiter?: IRateLimiter;\n\n  range?: string;\n  rangeStart?: number;\n  rangeEnd?: number;\n\n  process?: string;\n  // need base64url encode\n  saveBucket?: string;\n  // need base64url encode\n  saveObject?: string;\n\n  responseCacheControl?: string;\n  responseContentDisposition?: string;\n  responseContentEncoding?: string;\n  responseContentLanguage?: string;\n  responseContentType?: string;\n  responseExpires?: Date;\n\n  dataTransferStatusChange?: (status: DataTransferStatus) => void;\n  /**\n   * the simple progress feature\n   * percent is [0, 1].\n   */\n  progress?: (percent: number) => void;\n\n  headers?: {\n    [key: string]: string | undefined;\n    'If-Modified-Since'?: string;\n    'If-Unmodified-Since'?: string;\n    'If-Match'?: string;\n    'If-None-Match'?: string;\n    'x-tos-server-side-encryption-customer-key'?: string;\n    'x-tos-server-side-encryption-customer-key-md5'?: string;\n    'x-tos-server-side-encryption-customer-algorithm'?: string;\n    range?: string;\n  };\n  /**\n   * @deprecated use responseXxx options instead\n   */\n  response?: Headers & {\n    'cache-control'?: string;\n    'content-disposition'?: string;\n    'content-encoding'?: string;\n    'content-language'?: string;\n    'content-type'?: string;\n    expires?: string;\n  };\n}\nexport interface GetObjectV2Output {\n  content: NodeJS.ReadableStream | Buffer | Blob;\n  etag: string;\n  lastModified: string;\n\n  // object created before tos server supports crc, hashCrc64ecma will be empty string\n  hashCrc64ecma: string;\n  RestoreInfo?: RestoreInfo;\n  ReplicationStatus?: ReplicationStatusType;\n}\n\nexport interface GetObjectV2OutputStream\n  extends Omit<GetObjectV2Output, 'content'> {\n  content: NodeJS.ReadableStream;\n}\nexport interface GetObjectV2InputBuffer\n  extends Omit<GetObjectV2Input, 'dataType'> {\n  dataType: 'buffer';\n}\nexport interface GetObjectV2OutputBuffer\n  extends Omit<GetObjectV2Output, 'content'> {\n  content: Buffer;\n}\nexport interface GetObjectV2InputBlob\n  extends Omit<GetObjectV2Input, 'dataType'> {\n  dataType: 'blob';\n}\nexport interface GetObjectV2OutputBlob\n  extends Omit<GetObjectV2Output, 'content'> {\n  content: Blob;\n}\n\nconst NODEJS_DATATYPE: DataType[] = ['stream', 'buffer'];\nconst BROWSER_DATATYPE: DataType[] = ['blob'];\n\nfunction checkSupportDataType(dataType: DataType) {\n  let environment: 'node' | 'browser' = 'node';\n  let supportDataTypes: DataType[] = [];\n  if (process.env.TARGET_ENVIRONMENT === 'node') {\n    environment = 'node';\n    supportDataTypes = NODEJS_DATATYPE;\n  } else {\n    environment = 'browser';\n    supportDataTypes = BROWSER_DATATYPE;\n  }\n  if (!supportDataTypes.includes(dataType)) {\n    throw new TosClientError(\n      `The value of \\`dataType\\` only supports \\`${supportDataTypes.join(\n        ' | '\n      )}\\` in ${environment} environment`\n    );\n  }\n}\n\n/**\n * `getObjectV2` default returns stream, using `dataType` param to return other type(eg: buffer, blob)\n */\nasync function getObjectV2(\n  this: TOSBase,\n  input: GetObjectV2InputBlob\n): Promise<TosResponse<GetObjectV2OutputBlob>>;\nasync function getObjectV2(\n  this: TOSBase,\n  input: GetObjectV2InputBuffer\n): Promise<TosResponse<GetObjectV2OutputBuffer>>;\nasync function getObjectV2(\n  this: TOSBase,\n  input: GetObjectV2Input | string\n): Promise<TosResponse<GetObjectV2OutputStream>>;\nasync function getObjectV2(\n  this: TOSBase,\n  input: GetObjectV2Input | string\n): Promise<TosResponse<GetObjectV2Output>> {\n  const normalizedInput = typeof input === 'string' ? { key: input } : input;\n  const headers = normalizeHeadersKey(normalizedInput.headers);\n  normalizedInput.headers = headers;\n  const dataType = normalizedInput.dataType || 'stream';\n  normalizedInput.dataType = dataType;\n\n  checkSupportDataType(dataType);\n\n  const query: Record<string, unknown> = {};\n  const response: Partial<Headers> = normalizedInput?.response || {};\n  Object.keys(response).forEach((key: string) => {\n    const v = response[key];\n    if (v != null) {\n      query[`response-${key}`] = v;\n    }\n  });\n  fillRequestQuery(normalizedInput, query, [\n    'versionId',\n    'process',\n    'saveBucket',\n    'saveObject',\n    'responseCacheControl',\n    'responseContentDisposition',\n    'responseContentEncoding',\n    'responseContentLanguage',\n    'responseContentType',\n    'responseExpires',\n  ]);\n\n  fillRequestHeaders(normalizedInput, [\n    'ifMatch',\n    'ifModifiedSince',\n    'ifNoneMatch',\n    'ifUnmodifiedSince',\n\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n\n    'range',\n    'trafficLimit',\n  ]);\n\n  if (\n    normalizedInput.range == null &&\n    (normalizedInput.rangeStart != null || normalizedInput.rangeEnd != null)\n  ) {\n    const start =\n      normalizedInput.rangeStart != null ? `${normalizedInput.rangeStart}` : '';\n    const end =\n      normalizedInput.rangeEnd != null ? `${normalizedInput.rangeEnd}` : '';\n    const range = `bytes=${start}-${end}`;\n    headers['range'] = headers['range'] ?? range;\n  }\n\n  const responseType = (() => {\n    if (process.env.TARGET_ENVIRONMENT === 'node') {\n      return 'stream';\n    }\n    return 'arraybuffer';\n  })();\n\n  let consumedBytes = 0;\n  // totalSize is unknown when start download\n  let totalSize = -1;\n  const { dataTransferStatusChange, progress } = normalizedInput;\n  const triggerDataTransfer = (\n    type: DataTransferType,\n    rwOnceBytes: number = 0\n  ) => {\n    // request cancel will make rwOnceBytes < 0 in browser\n    if (rwOnceBytes < 0) {\n      return;\n    }\n    if (!dataTransferStatusChange && !progress) {\n      return;\n    }\n    consumedBytes += rwOnceBytes;\n    dataTransferStatusChange?.({\n      type,\n      rwOnceBytes,\n      consumedBytes,\n      totalBytes: totalSize,\n    });\n    const progressValue = (() => {\n      // `totalSize` is unknown if it's in start or fail\n      if (totalSize < 0) {\n        return 0;\n      }\n\n      if (totalSize === 0) {\n        if (type === DataTransferType.Succeed) {\n          return 1;\n        }\n        return 0;\n      }\n      return consumedBytes / totalSize;\n    })();\n    if (progressValue === 1) {\n      if (type === DataTransferType.Succeed) {\n        progress?.(progressValue);\n      } else {\n        // not exec progress\n      }\n    } else {\n      progress?.(progressValue);\n    }\n  };\n\n  triggerDataTransfer(DataTransferType.Started);\n  const [err, res] = await safeAwait(\n    this._fetchObject<any>(input, 'GET', query, headers, undefined, {\n      axiosOpts: {\n        responseType,\n        onDownloadProgress: (event) => {\n          totalSize = event.total;\n          triggerDataTransfer(\n            DataTransferType.Rw,\n            event.loaded - consumedBytes\n          );\n        },\n      },\n    })\n  );\n  if (err || !res) {\n    triggerDataTransfer(DataTransferType.Failed);\n    throw err;\n  }\n\n  let resHeaders = res.headers;\n  let newData: NodeJS.ReadableStream | Blob | Buffer = res.data;\n  totalSize = +(resHeaders['content-length'] || 0);\n\n  if (process.env.TARGET_ENVIRONMENT === 'node') {\n    // res.data must be a stream in nodejs environment\n    if (isReadable(newData)) {\n      if (\n        normalizedInput.rateLimiter &&\n        isValidRateLimiter(normalizedInput.rateLimiter)\n      ) {\n        newData = createRateLimiterStream(\n          newData as NodeJS.ReadableStream,\n          normalizedInput.rateLimiter\n        );\n      }\n\n      newData = createReadNReadStream(newData, (n) =>\n        triggerDataTransfer(DataTransferType.Rw, n)\n      );\n      newData.on('end', () => triggerDataTransfer(DataTransferType.Succeed));\n\n      if (dataType === 'buffer') {\n        // consume stream after `createRateLimiterStream`\n        newData = await streamToBuf(newData);\n      }\n    } else {\n      // should not enter this branch\n    }\n  } else {\n    // \n    if (dataType === 'blob') {\n      newData = new Blob([res.data], {\n        type: resHeaders['content-type'],\n      });\n    }\n    triggerDataTransfer(DataTransferType.Succeed);\n  }\n\n  const actualRes: TosResponse<GetObjectV2Output> = {\n    ...res,\n    data: {\n      content: newData,\n      etag: resHeaders['etag'] || '',\n      lastModified: resHeaders['last-modified'] || '',\n      hashCrc64ecma: resHeaders['x-tos-hash-crc64ecma'] || '',\n      ReplicationStatus: resHeaders[TosHeader.HeaderReplicationStatus] as\n        | ReplicationStatusType\n        | undefined,\n    },\n  };\n\n  const info = getRestoreInfoFromHeaders(resHeaders);\n  if (info) {\n    actualRes.data.RestoreInfo = info;\n  }\n  return actualRes;\n}\n\ninterface GetObjectToFileInput extends Omit<GetObjectV2Input, 'dataType'> {\n  filePath: string;\n}\ninterface GetObjectToFileOutput extends Omit<GetObjectV2Output, 'content'> {}\n\nexport async function getObjectToFile(\n  this: TOSBase,\n  input: GetObjectToFileInput\n): Promise<TosResponse<GetObjectToFileOutput>> {\n  if (process.env.TARGET_ENVIRONMENT !== 'node') {\n    throw new TosClientError(\n      \"getObjectToFile doesn't support in browser environment\"\n    );\n  }\n\n  return new Promise(async (resolve, reject) => {\n    const getObjectRes = await getObjectV2.call(this, input);\n    const stream = getObjectRes.data.content;\n\n    const fsWriteStream = createWriteStream(input.filePath);\n    stream.pipe(fsWriteStream);\n    stream.on('error', (err) => fsWriteStream.destroy(err));\n    fsWriteStream.on('error', (err) => reject(err));\n    fsWriteStream.on('finish', () => {\n      const newData: any = { ...getObjectRes.data };\n      delete newData.content;\n      resolve({ ...getObjectRes, data: { ...newData } });\n    });\n  });\n}\n\nexport { getObjectV2 };\n","import TOSBase, { TosResponse } from '../base';\nimport {\n  DEFAULT_PART_SIZE,\n  isCancelError,\n  makeSerialAsyncTask,\n  safeParseCheckpointFile,\n} from '../../utils';\nimport * as fsp from '../../nodejs/fs-promises';\nimport { DataTransferStatus, DataTransferType } from '../../interface';\nimport headObject, { HeadObjectInput, HeadObjectOutput } from './headObject';\nimport { CancelToken } from 'axios';\nimport { Stats } from 'fs';\nimport path from 'path';\nimport TosClientError from '../../TosClientError';\nimport { getObjectV2, GetObjectV2Output } from './getObject';\nimport TosServerError from '../../TosServerError';\nimport { CancelError } from '../../CancelError';\nimport { IRateLimiter } from '../../universal/rate-limiter';\nimport { validateCheckpoint } from './utils';\nimport { createCrcReadStream } from '../../nodejs/CrcReadStream';\nimport { CRC } from '../../universal/crc';\nimport { combineCrc64 } from '../../universal/crc';\n\nexport interface DownloadFileCheckpointRecord {\n  bucket: string;\n  key: string;\n  version_id?: string;\n  part_size: number;\n\n  object_info: {\n    etag: string;\n    hash_crc64ecma: string;\n    object_size: number;\n    last_modified: string;\n  };\n\n  file_info: {\n    file_path: string;\n    temp_file_path: string;\n  };\n\n  parts_info: DownloadFileCheckpointRecordPartInfo[];\n}\n\nexport interface DownloadFileCheckpointRecordPartInfo {\n  part_number: number;\n  range_start: number;\n  range_end: number;\n  hash_crc64ecma: string;\n  is_completed: boolean;\n}\n\nexport interface DownloadFileInput extends HeadObjectInput {\n  filePath: string;\n  /**\n   * @private unstable tempFilePath\n   */\n  tempFilePath?: string;\n\n  /**\n   * default is 20 MB\n   *\n   * unit: B\n   */\n  partSize?: number;\n\n  /**\n   * the number of request to parallel upload partdefault value is 1\n   */\n  taskNum?: number;\n\n  /**\n   * if checkpoint is a string and point to a exist file,\n   * the checkpoint record will recover from this file.\n   *\n   * if checkpoint is a string and point to a directory,\n   * the checkpoint will be auto generated,\n   * and its name is `{bucketName}_{objectName}.{uploadId}`.\n   */\n  checkpoint?: string | DownloadFileCheckpointRecord;\n\n  dataTransferStatusChange?: (status: DataTransferStatus) => void;\n\n  /**\n   * the simple progress feature\n   * percent is [0, 1]\n   */\n  progress?: (\n    percent: number,\n    checkpoint: DownloadFileCheckpointRecord\n  ) => void;\n\n  /**\n   * the feature of pause and continue downloading\n   */\n  downloadEventChange?: (event: DownloadEvent) => void;\n\n  /**\n   * cancel this upload progress\n   */\n  cancelToken?: CancelToken;\n  /**\n   * unit: bit/s\n   * server side traffic limit\n   **/\n  trafficLimit?: number;\n  /**\n   * only works for nodejs environment\n   */\n  rateLimiter?: IRateLimiter;\n\n  /**\n   * @private unstable\n   * custom rename file to support not overwrite file\n   */\n  customRenameFileAfterDownloadCompleted?: (\n    tempFilePath: string,\n    filePath: string\n  ) => void;\n}\nexport interface DownloadFileOutput extends HeadObjectOutput {}\n\nexport interface DownloadEvent {\n  type: DownloadEventType;\n  err?: Error;\n\n  bucket: string;\n  key: string;\n  versionId?: string;\n  filePath: string;\n  checkpointFile?: string;\n  downloadPartInfo?: DownloadPartInfo;\n}\n\nexport interface DownloadPartInfo {\n  partNumber: number;\n  rangeStart: number;\n  rangeEnd: number;\n}\n\nexport enum DownloadEventType {\n  CreateTempFileSucceed = 1,\n  CreateTempFileFailed,\n  DownloadPartSucceed,\n  DownloadPartFailed,\n  DownloadPartAborted,\n  RenameTempFileSucceed,\n  RenameTempFileFailed,\n}\n\ninterface CheckpointRichInfo {\n  filePath?: string | undefined;\n\n  filePathIsPlaceholder?: boolean;\n\n  record?: DownloadFileCheckpointRecord;\n}\n\ninterface Task {\n  partSize: number;\n  offset: number;\n  partNumber: number;\n}\n\nconst CHECKPOINT_FILE_NAME_PLACEHOLDER = '@@checkpoint-file-placeholder@@';\nconst ABORT_ERROR_STATUS_CODE = [403, 404, 405];\n\nexport async function downloadFile(\n  this: TOSBase,\n  input: DownloadFileInput\n): Promise<TosResponse<DownloadFileOutput>> {\n  if (process.env.TARGET_ENVIRONMENT === 'browser') {\n    throw new TosClientError(\n      '`downloadFile` is not supported in browser environment'\n    );\n  }\n  const { cancelToken, versionId } = input;\n  const isCancel = () => cancelToken && !!cancelToken.reason;\n  validateCheckpoint(input.checkpoint);\n\n  const headObjectRes = await headObject.call(this, {\n    bucket: input.bucket,\n    key: input.key,\n    versionId,\n  });\n  const { data: objectStats } = headObjectRes;\n  const etag = objectStats['etag'];\n  const symlinkTargetSize = objectStats['x-tos-symlink-target-size'] ?? 0;\n  const objectSize =\n    objectStats['x-tos-object-type'] === 'Symlink'\n      ? +symlinkTargetSize\n      : +objectStats['content-length'];\n\n  const checkpointRichInfo = await (async (): Promise<CheckpointRichInfo> => {\n    if (process.env.TARGET_ENVIRONMENT === 'node') {\n      if (typeof input.checkpoint === 'string') {\n        const { checkpoint } = input;\n        // file doesn't exist when stat is null\n        let checkpointStat: Stats | null = null;\n        try {\n          checkpointStat = await fsp.stat(checkpoint);\n        } catch (_err) {\n          // TODO: remove any\n          const err = _err as any;\n          if (err.code === 'ENOENT') {\n            // file doesn't exist\n          } else {\n            throw err;\n          }\n        }\n\n        const isDirectory = (() => {\n          if (checkpointStat) {\n            return checkpointStat.isDirectory();\n          }\n          return checkpoint.endsWith('/');\n        })();\n\n        // filePath will generated by uploadId, use placeholder temporarily\n        const filePath = isDirectory\n          ? path.resolve(checkpoint, CHECKPOINT_FILE_NAME_PLACEHOLDER)\n          : checkpoint;\n        const dirPath = path.dirname(filePath);\n        // ensure directory exist\n        await fsp.safeMkdirRecursive(dirPath);\n\n        if (isDirectory) {\n          return {\n            filePath,\n            filePathIsPlaceholder: true,\n          };\n        }\n\n        return {\n          filePath,\n          filePathIsPlaceholder: false,\n          // filePath is json file\n          // TODO: validate json schema\n          record: checkpointStat\n            ? await safeParseCheckpointFile(filePath)\n            : undefined,\n        };\n      }\n    }\n\n    if (typeof input.checkpoint === 'object') {\n      return {\n        record: input.checkpoint,\n      };\n    }\n\n    return {};\n  })();\n\n  // check if file info is matched\n  await (async () => {\n    if (checkpointRichInfo.record?.object_info) {\n      const { last_modified, object_size } =\n        checkpointRichInfo.record?.object_info;\n      if (\n        // TODO: `last-modified` aligns to number\n        objectStats['last-modified'] !== last_modified ||\n        objectSize !== object_size\n      ) {\n        console.warn(\n          `The file has been modified since ${new Date(\n            last_modified\n          )}, so the checkpoint file is invalid, and specified object will be downloaded again.`\n        );\n        delete checkpointRichInfo.record;\n      }\n    }\n  })();\n\n  const partSize =\n    input.partSize || checkpointRichInfo.record?.part_size || DEFAULT_PART_SIZE;\n\n  // check partSize is matched\n  if (\n    checkpointRichInfo.record &&\n    checkpointRichInfo.record.part_size !== partSize\n  ) {\n    console.warn(\n      'The partSize param does not equal the partSize in checkpoint file, ' +\n        'so the checkpoint file is invalid, and specified object will be downloaded again.'\n    );\n    delete checkpointRichInfo.record;\n  }\n\n  let bucket = input.bucket || this.opts.bucket || '';\n  const key = input.key;\n  const filePath = await (async () => {\n    let filePathStats: Stats | null = null;\n    try {\n      filePathStats = await fsp.stat(input.filePath);\n    } catch (_err) {\n      const err = _err as any;\n      if (err.code === 'ENOENT') {\n        // file doesn't exist\n      } else {\n        throw err;\n      }\n    }\n\n    const isDirectory = (() => {\n      if (filePathStats) {\n        return filePathStats.isDirectory();\n      }\n      return input.filePath.endsWith('/');\n    })();\n    const filePath = isDirectory\n      ? path.resolve(input.filePath, key)\n      : input.filePath;\n\n    const dirPath = path.dirname(filePath);\n    await fsp.safeMkdirRecursive(dirPath);\n\n    return filePath;\n  })();\n  const [tempFilePath, isExist] = await (async () => {\n    const tempFilePath = input.tempFilePath\n      ? input.tempFilePath\n      : filePath + '.temp';\n    let isExist = true;\n    try {\n      await fsp.stat(tempFilePath);\n    } catch (_err) {\n      const err = _err as any;\n      if (err.code === 'ENOENT') {\n        isExist = false;\n        // file doesn't exist\n      } else {\n        throw err;\n      }\n    }\n    return [tempFilePath, isExist];\n  })();\n  if (checkpointRichInfo.record) {\n    if (!isExist) {\n      console.warn(\n        \"The temp file doesn't not exist \" +\n          'so the checkpoint file is invalid, and specified object will be downloaded again.'\n      );\n      delete checkpointRichInfo.record;\n    }\n  }\n\n  let tasks: Task[] = [];\n  const allTasks: Task[] = getAllTasks(objectSize, partSize);\n  const initConsumedBytes = (checkpointRichInfo.record?.parts_info || [])\n    .filter((it) => it.is_completed)\n    .reduce((prev, it) => prev + (it.range_end - it.range_start + 1), 0);\n\n  // recorded tasks\n  const recordedTasks = checkpointRichInfo.record?.parts_info || [];\n  const recordedTaskMap: Map<number, DownloadFileCheckpointRecordPartInfo> =\n    new Map();\n  recordedTasks.forEach((it) => recordedTaskMap.set(it.part_number, it));\n\n  const nextEnsureCloseFd = async () => {\n    const getCheckpointContent = () => {\n      const checkpointContent: DownloadFileCheckpointRecord = {\n        bucket,\n        key,\n        version_id: versionId,\n        part_size: partSize,\n        parts_info: recordedTasks,\n        file_info: {\n          file_path: filePath,\n          temp_file_path: tempFilePath,\n        },\n        object_info: {\n          last_modified: objectStats['last-modified'],\n          etag: etag,\n          hash_crc64ecma: objectStats['x-tos-hash-crc64ecma'] || '',\n          object_size: objectSize,\n        },\n      };\n      return checkpointContent;\n    };\n    const triggerDownloadEvent = (\n      e: Omit<\n        DownloadEvent,\n        'bucket' | 'versionId' | 'key' | 'checkpointFile' | 'filePath'\n      >\n    ) => {\n      if (!input.downloadEventChange) {\n        return;\n      }\n\n      const event: DownloadEvent = {\n        bucket,\n        versionId,\n        key,\n        filePath,\n        ...e,\n      };\n      if (checkpointRichInfo.filePath) {\n        event.checkpointFile = checkpointRichInfo.filePath;\n      }\n\n      input.downloadEventChange(event);\n    };\n\n    let consumedBytesForProgress = initConsumedBytes;\n    enum TriggerProgressEventType {\n      start = 0,\n      downloadPartSucceed = 1,\n      renameTempFileSucceed = 2,\n    }\n    const triggerProgressEvent = (type: TriggerProgressEventType) => {\n      if (!input.progress) {\n        return;\n      }\n\n      const percent = (() => {\n        if (type === TriggerProgressEventType.start && objectSize === 0) {\n          return 0;\n        }\n        return !objectSize ? 1 : consumedBytesForProgress / objectSize;\n      })();\n\n      if (\n        consumedBytesForProgress === objectSize &&\n        type === TriggerProgressEventType.downloadPartSucceed\n      ) {\n        // 100%  complete  100% \n      } else {\n        input.progress(percent, getCheckpointContent());\n      }\n    };\n    let consumedBytes = initConsumedBytes;\n    const { dataTransferStatusChange } = input;\n    const triggerDataTransfer = (\n      type: DataTransferType,\n      rwOnceBytes: number = 0\n    ) => {\n      if (!dataTransferStatusChange) {\n        return;\n      }\n      consumedBytes += rwOnceBytes;\n\n      dataTransferStatusChange?.({\n        type,\n        rwOnceBytes,\n        consumedBytes,\n        totalBytes: objectSize,\n      });\n    };\n    const writeCheckpointFile = makeSerialAsyncTask(async () => {\n      if (\n        process.env.TARGET_ENVIRONMENT === 'node' &&\n        checkpointRichInfo.filePath\n      ) {\n        const content = JSON.stringify(getCheckpointContent(), null, 2);\n        const dirPath = path.dirname(checkpointRichInfo.filePath); // ensure directory exist\n\n        await fsp.safeMkdirRecursive(dirPath);\n        await fsp.writeFile(checkpointRichInfo.filePath, content, 'utf-8');\n      }\n    });\n    const rmCheckpointFile = async () => {\n      if (\n        process.env.TARGET_ENVIRONMENT === 'node' &&\n        checkpointRichInfo.filePath\n      ) {\n        await fsp.rm(checkpointRichInfo.filePath).catch((err: any) => {\n          // eat err\n          console.warn(\n            'remove checkpoint file failure, you can remove it by hand.\\n',\n            `checkpoint file path: ${checkpointRichInfo.filePath}\\n`,\n            err.message\n          );\n        });\n      }\n    };\n\n    /**\n     *\n     * @param task one part task\n     * @param downloadPartRes upload part failed if `downloadPartRes` is Error\n     */\n    const updateAfterDownloadPart = async (\n      task: Task,\n      downloadPartRes:\n        | {\n            res: GetObjectV2Output & { rangeHashCrc64ecma: string };\n            err?: null;\n          }\n        | {\n            err: Error;\n          }\n    ) => {\n      let existRecordTask = recordedTaskMap.get(task.partNumber);\n      const rangeStart = task.offset;\n      const rangeEnd = Math.min(task.offset + partSize - 1, objectSize - 1);\n      if (!existRecordTask) {\n        existRecordTask = {\n          part_number: task.partNumber,\n          range_start: rangeStart,\n          range_end: rangeEnd,\n          hash_crc64ecma: '',\n          is_completed: false,\n        };\n        recordedTasks.push(existRecordTask);\n        recordedTaskMap.set(existRecordTask.part_number, existRecordTask);\n      }\n\n      if (!downloadPartRes.err) {\n        existRecordTask.is_completed = true;\n        existRecordTask.hash_crc64ecma = downloadPartRes.res.rangeHashCrc64ecma;\n      }\n\n      await writeCheckpointFile();\n      const downloadPartInfo: DownloadPartInfo = {\n        partNumber: existRecordTask.part_number,\n        rangeStart,\n        rangeEnd,\n      };\n\n      if (downloadPartRes.err) {\n        const err = downloadPartRes.err;\n        let type: DownloadEventType = DownloadEventType.DownloadPartFailed;\n\n        if (err instanceof TosServerError) {\n          if (ABORT_ERROR_STATUS_CODE.includes(err.statusCode)) {\n            type = DownloadEventType.DownloadPartAborted;\n          }\n        }\n\n        triggerDownloadEvent({\n          type,\n          err,\n          downloadPartInfo: downloadPartInfo,\n        });\n        return;\n      }\n\n      consumedBytesForProgress +=\n        downloadPartInfo.rangeEnd - downloadPartInfo.rangeStart + 1;\n\n      triggerDownloadEvent({\n        type: DownloadEventType.DownloadPartSucceed,\n        downloadPartInfo: downloadPartInfo,\n      });\n      triggerProgressEvent(TriggerProgressEventType.downloadPartSucceed);\n    };\n\n    if (checkpointRichInfo.record) {\n      bucket = checkpointRichInfo.record.bucket;\n\n      // checkpoint info exists, so need to calculate remain tasks\n      const uploadedPartSet: Set<number> = new Set(\n        (checkpointRichInfo.record.parts_info || [])\n          .filter((it) => it.is_completed)\n          .map((it) => it.part_number)\n      );\n      tasks = allTasks.filter((it) => !uploadedPartSet.has(it.partNumber));\n    } else {\n      try {\n        // create temp file\n        await fsp.writeFile(tempFilePath, '', {\n          flag: 'w+',\n        });\n      } catch (_err) {\n        const err = _err as any;\n        triggerDownloadEvent({\n          type: DownloadEventType.CreateTempFileFailed,\n          err,\n        });\n        throw err;\n      }\n\n      if (checkpointRichInfo.filePathIsPlaceholder) {\n        checkpointRichInfo.filePath = checkpointRichInfo.filePath?.replace(\n          `${CHECKPOINT_FILE_NAME_PLACEHOLDER}`,\n          getDefaultCheckpointFilePath(bucket, key, versionId)\n        );\n      }\n\n      triggerDownloadEvent({\n        type: DownloadEventType.CreateTempFileSucceed,\n      });\n      triggerDataTransfer(DataTransferType.Started);\n      tasks = allTasks;\n    }\n\n    const handleTasks = async () => {\n      let firstErr: Error | null = null;\n      let index = 0;\n\n      // TODO: how to test parallel does work, measure time is not right\n      await Promise.all(\n        Array.from({ length: input.taskNum || 1 }).map(async () => {\n          while (true) {\n            const currentIndex = index++;\n            if (currentIndex >= tasks.length) {\n              return;\n            }\n\n            const curTask = tasks[currentIndex];\n            let consumedBytesThisTask = 0;\n            try {\n              const res = await getObjectV2.call(this, {\n                bucket,\n                key,\n                versionId,\n                headers: {\n                  'if-match': etag,\n                  range: `bytes=${curTask.offset}-${Math.min(\n                    curTask.offset + curTask.partSize - 1,\n                    objectSize - 1\n                  )}`,\n                },\n                trafficLimit: input.trafficLimit,\n                rateLimiter: input.rateLimiter,\n                dataTransferStatusChange(status) {\n                  if (status.type !== DataTransferType.Rw) {\n                    return;\n                  }\n                  if (isCancel()) {\n                    return;\n                  }\n                  consumedBytesThisTask += status.rwOnceBytes;\n                  triggerDataTransfer(DataTransferType.Rw, status.rwOnceBytes);\n                },\n              });\n\n              // need to handle stream's error event before throw a error\n              // if (isCancel()) {\n              //   throw new CancelError('cancel downloadFile');\n              // }\n\n              let dataStream = res.data.content;\n              const crcInst = new CRC();\n              if (\n                process.env.TARGET_ENVIRONMENT === 'node' &&\n                this.opts.enableCRC\n              ) {\n                dataStream = createCrcReadStream(dataStream, crcInst);\n              }\n              await new Promise((resolve, reject) => {\n                const writeStream = fsp.createWriteStream(tempFilePath, {\n                  start: curTask.offset,\n                  flags: 'r+',\n                });\n\n                let isErr = false;\n                let err: any = null;\n                writeStream.on('close', () => {\n                  if (isErr) {\n                    reject(err);\n                  } else {\n                    resolve(undefined);\n                  }\n                });\n\n                writeStream.on('error', (_err) => {\n                  isErr = true;\n                  err = _err;\n                });\n\n                dataStream.pipe(writeStream);\n                dataStream.on('error', (err) => writeStream.destroy(err));\n                function handleOnceCancel() {\n                  if (isCancel()) {\n                    reject(new CancelError('cancel downloadFile'));\n                    // fix windows\n                    writeStream.end();\n                    dataStream.unpipe(writeStream);\n                    dataStream.off('data', handleOnceCancel);\n                  }\n                }\n                dataStream.on('data', handleOnceCancel);\n              });\n\n              if (isCancel()) {\n                throw new CancelError('cancel downloadFile');\n              }\n\n              await updateAfterDownloadPart(curTask, {\n                res: { ...res.data, rangeHashCrc64ecma: crcInst.getCrc64() },\n              });\n            } catch (_err) {\n              const err = _err as any;\n              consumedBytes -= consumedBytesThisTask;\n              consumedBytesThisTask = 0;\n\n              if (isCancelError(err)) {\n                throw err;\n              }\n\n              if (isCancel()) {\n                throw new CancelError('cancel downloadFile');\n              }\n\n              if (!firstErr) {\n                firstErr = err;\n              }\n              await updateAfterDownloadPart(curTask, { err });\n            }\n          }\n        })\n      );\n\n      if (firstErr) {\n        throw firstErr;\n      }\n\n      const serverCRC64 = headObjectRes.data['x-tos-hash-crc64ecma'];\n      if (this.opts.enableCRC && serverCRC64) {\n        const actualCrc64 = combineCRCInParts(getCheckpointContent());\n        if (actualCrc64 !== serverCRC64) {\n          throw new TosClientError(\n            `validate file crc64 failed. Expect crc64 ${serverCRC64}, actual crc64 ${actualCrc64}. Please try again.`\n          );\n        }\n      }\n    };\n\n    const handleEmptyObj = async () => {};\n\n    triggerProgressEvent(TriggerProgressEventType.start);\n    objectSize === 0 ? await handleEmptyObj() : await handleTasks();\n\n    try {\n      if (typeof input.customRenameFileAfterDownloadCompleted === 'function') {\n        await input.customRenameFileAfterDownloadCompleted(\n          tempFilePath,\n          filePath\n        );\n      } else {\n        await fsp.rename(tempFilePath, filePath);\n      }\n    } catch (_err) {\n      const err = _err as any;\n      triggerDownloadEvent({\n        type: DownloadEventType.RenameTempFileFailed,\n        err,\n      });\n      triggerDataTransfer(DataTransferType.Failed);\n      throw err;\n    }\n\n    triggerDownloadEvent({\n      type: DownloadEventType.RenameTempFileSucceed,\n    });\n    triggerProgressEvent(TriggerProgressEventType.renameTempFileSucceed);\n    triggerDataTransfer(DataTransferType.Succeed);\n    await rmCheckpointFile();\n\n    return headObjectRes;\n  };\n\n  try {\n    return await nextEnsureCloseFd();\n  } finally {\n    // there is no global fd, don't need to close fd\n  }\n}\n\nexport default downloadFile;\n\n/**\n *  totalSize  0 Part Server  read request body failed\n */\nfunction getAllTasks(totalSize: number, partSize: number) {\n  const tasks: Task[] = [];\n  for (let i = 0; ; ++i) {\n    const offset = i * partSize;\n    const currPartSize = Math.min(partSize, totalSize - offset);\n\n    tasks.push({\n      offset,\n      partSize: currPartSize,\n      partNumber: i + 1,\n    });\n\n    if ((i + 1) * partSize >= totalSize) {\n      break;\n    }\n  }\n\n  return tasks;\n}\n\nfunction getDefaultCheckpointFilePath(\n  bucket: string,\n  key: string,\n  versionId?: string\n) {\n  const originPath = `${bucket}_${key}.${versionId}.json`;\n  const normalizePath = originPath.replace(/[\\\\/]/g, '');\n  return normalizePath;\n}\n\nfunction combineCRCInParts(cp: DownloadFileCheckpointRecord) {\n  let res = '0';\n  const sortedPartsInfo =\n    cp.parts_info?.sort?.((a, b) => a.part_number - b.part_number) ?? [];\n  for (const part of sortedPartsInfo) {\n    res = combineCrc64(\n      res,\n      part.hash_crc64ecma,\n      part.range_end - part.range_start + 1\n    );\n  }\n  return res;\n}\n","// @ts-nocheck\nimport { hashSha256, hmacSha256, stringify, parse } from './universal/crypto';\nimport { getSortedQueryString } from './utils';\n\nexport interface ISign {\n  signature(\n    opt: ISigOptions,\n    expiredAt: number,\n    credentials?: ISigCredentials\n  ): string;\n  signatureHeader(\n    opt: ISigOptions,\n    expiredAt?: number,\n    credentials?: ISigCredentials\n  ): Map<string, string>;\n  gnrCopySig(\n    opt: ISigOptions,\n    credentials: ISigCredentials\n  ): { key: string; value: string };\n  getSignatureQuery(\n    opt: ISigOptions,\n    expiredAt: number\n  ): { [key: string]: any };\n  getSignature(\n    reqOpts: ISigOptions,\n    expiredAt: number\n  ): { key: string; value: string };\n}\n\nexport interface ISigCredentials {\n  GetSecretKey(): string;\n  GetAccessKey(): string;\n}\n\nexport interface ISigPolicyQuery {\n  policy: {\n    conditions: (string[] | { bucket: string } | { key: string })[];\n  };\n}\n\nexport interface ISigOptions {\n  sigName?: string;\n  endpoints?: string;\n  bucket?: string;\n  headers?: { [key: string]: string | undefined };\n  region?: string;\n  serviceName?: string;\n  algorithm?: string;\n  path: string;\n  method: string;\n  query?: string;\n  datetime?: string;\n  host?: string;\n  port?: number;\n}\n\nexport interface ISigQueryOptions extends Omit<ISigOptions, 'query'> {\n  query?: Record<string, any>;\n}\n\nexport const SIG_QUERY = {\n  algorithm: 'tos-algorithm',\n  expiration: 'tos-expiration',\n  signame: 'tos-signame',\n  signature: 'tos-signature',\n\n  v4_algorithm: 'X-Tos-Algorithm',\n  v4_credential: 'X-Tos-Credential',\n  v4_date: 'X-Tos-Date',\n  v4_expires: 'X-Tos-Expires',\n  v4_signedHeaders: 'X-Tos-SignedHeaders',\n  v4_security_token: 'X-Tos-Security-Token',\n  v4_signature: 'X-Tos-Signature',\n  v4_content_sha: 'X-Tos-Content-Sha256',\n  v4_policy: 'X-Tos-Policy',\n\n\n};\n\nexport function isDefaultPort(port?: number) {\n  if (port && port !== 80 && port !== 443) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @api private\n */\nconst v4Identifier = 'request';\n\ninterface ISignV4Opt {\n  algorithm?: string;\n  region?: string;\n  serviceName?: string;\n  securityToken?: string;\n  bucket: string;\n}\n/**\n * @api private\n */\nexport class SignersV4 implements ISign {\n  private options: ISignV4Opt;\n  private credentials: ISigCredentials;\n  constructor(opt: ISignV4Opt, credentials: ISigCredentials) {\n    this.options = opt;\n    this.credentials = credentials;\n  }\n\n  /*\n   * normal v4 signature\n   * */\n  public signature = (\n    opt: ISigOptions,\n    expiredAt: number,\n    credentials?: ISigCredentials\n  ) => {\n    if (!credentials) {\n      credentials = this.credentials;\n    }\n    const parts: string[] = [];\n    const datatime = opt.datetime as string;\n    const credString = this.credentialString(datatime);\n    parts.push(\n      this.options.algorithm +\n        ' Credential=' +\n        credentials.GetAccessKey() +\n        '/' +\n        credString\n    );\n\n    // console.log(this.algorithm + ' Credential=' +\n    //   credentials.accessKeyId + '/' + credString)\n\n    parts.push('SignedHeaders=' + this.signedHeaders(opt));\n    parts.push('Signature=' + this.authorization(opt, credentials, 0));\n    return parts.join(', ');\n  };\n\n  public signatureHeader = (\n    opt: ISigOptions,\n    expiredAt?: number,\n    credentials?: ISigCredentials\n  ): Map<string, string> => {\n    // const datetime = (new Date(new Date().toUTCString())).Format(\"yyyyMMddTHHmmssZ\")\n    opt.datetime = this.getDateTime();\n    const header = new Map<string, string>();\n    /* istanbul ignore if */\n    if (!opt.headers) {\n      const h: { [key: string]: string } = {};\n      opt.headers = h;\n    }\n\n    opt.headers.host = `${opt.host}`;\n    /* istanbul ignore if */\n    if (!isDefaultPort(opt.port)) {\n      opt.headers.host += ':' + opt.port;\n    }\n    /* istanbul ignore if */\n    if (opt.endpoints) {\n      opt.headers.host = `${this.options.bucket}.${opt.endpoints}`;\n    }\n\n    header.set('host', opt.headers.host); // opt.endpoints as string)\n    header.set('x-tos-date', opt.datetime); // opt.datetime)\n    /* istanbul ignore if\n      if (opt.endpoints) {\n          let bucket = this.options.bucket;\n          if (opt.bucket) {\n              bucket = opt.bucket;\n          }\n          if (!opt.path || opt.path === '/' || opt.path === `/${bucket}`) {\n              opt.path = '/' + bucket;\n          } else {\n              opt.path = '/' + bucket + opt.path;\n          }\n      }\n      */\n    header.set('x-tos-content-sha256', this.hexEncodedBodyHash());\n    if (this.options.securityToken) {\n      header.set('x-tos-security-token', this.options.securityToken);\n    }\n    // x-tos- must to be signatured\n    header.forEach((value, key) => {\n      if (key.startsWith('x-tos')) {\n        opt.headers[key] = value;\n      }\n    });\n    opt.path = this.getEncodePath(opt.path);\n    const sign = this.signature(opt, 0, credentials);\n    header.set('authorization', sign);\n\n    return header;\n  };\n\n  public gnrCopySig = (\n    opt: ISigOptions,\n    credentials: ISigCredentials\n  ): { key: string; value: string } => {\n    return { key: '', value: '' };\n  };\n\n  public getSignature = (\n    opt: ISigOptions,\n    expiredAt: number\n  ): { key: ''; value: '' } => {\n    return { key: '', value: '' };\n  };\n\n  public getSignatureQuery = (\n    opt: ISigQueryOptions,\n    expiredAt: number\n  ): { [key: string]: any } => {\n    opt.datetime = this.getDateTime();\n    if (!opt.headers) {\n      const h: { [key: string]: string } = {};\n      opt.headers = h;\n    }\n\n    opt.headers.host = `${opt.host}`;\n    if (!isDefaultPort(opt.port)) {\n      opt.headers.host += ':' + opt.port;\n    }\n\n    opt.path = this.getEncodePath(opt.path);\n    if (opt.endpoints) {\n      opt.headers.host = `${this.options.bucket}.${opt.endpoints}`;\n      // opt.path = `${opt.path}`;\n    }\n\n    opt.headers[SIG_QUERY.v4_date] = opt.datetime;\n    const credString = this.credentialString(opt.datetime as string);\n    const res = {\n      ...(opt.query || {}),\n      [SIG_QUERY.v4_algorithm]: this.options.algorithm,\n      [SIG_QUERY.v4_content_sha]: this.hexEncodedBodyHash(),\n      [SIG_QUERY.v4_credential]:\n        this.credentials.GetAccessKey() + '/' + credString,\n      [SIG_QUERY.v4_date]: opt.datetime,\n      [SIG_QUERY.v4_expires]: '' + expiredAt,\n      [SIG_QUERY.v4_signedHeaders]: this.signedHeaders(opt),\n    };\n    if (this.options.securityToken) {\n      res[SIG_QUERY.v4_security_token] = this.options.securityToken;\n    }\n    opt.query = getSortedQueryString(res);\n\n    res[SIG_QUERY.v4_signature] = this.authorization(\n      opt,\n      this.credentials,\n      expiredAt\n    );\n    return res;\n  };\n\n  public getSignaturePolicyQuery = (\n    opt: ISigPolicyQuery,\n    expiredAt: number\n  ): { [key: string]: any } => {\n    opt.datetime = this.getDateTime();\n\n    const credString = this.credentialString(opt.datetime as string);\n    const res = {\n      [SIG_QUERY.v4_algorithm]: this.options.algorithm,\n      [SIG_QUERY.v4_credential]:\n        this.credentials.GetAccessKey() + '/' + credString,\n      [SIG_QUERY.v4_date]: opt.datetime,\n      [SIG_QUERY.v4_expires]: '' + expiredAt,\n      [SIG_QUERY.v4_policy]: stringify(\n        parse(JSON.stringify(opt.policy), 'utf-8'),\n        'base64'\n      ),\n    };\n    if (this.options.securityToken) {\n      res[SIG_QUERY.v4_security_token] = this.options.securityToken;\n    }\n    opt.query = getSortedQueryString(res);\n\n    res[SIG_QUERY.v4_signature] = this.authorization(\n      opt,\n      this.credentials,\n      expiredAt\n    );\n    return res;\n  };\n\n  private hexEncodedBodyHash = () => {\n    return 'UNSIGNED-PAYLOAD';\n    // return this.hexEncodedHash('');\n  };\n\n  private authorization = (\n    opt: ISigOptions,\n    credentials: ISigCredentials,\n    expiredAt: number\n  ) => {\n    /* istanbul ignore if */\n    if (!opt.datetime) {\n      return '';\n    }\n\n    const signingKey = this.getSigningKey(\n      credentials,\n      opt.datetime.substr(0, 8)\n    );\n    // console.log(\n    // 'signingKey:',\n    //  signingKey,\n    //  'sign:',\n    //  this.stringToSign(opt.datetime, opt)\n    //  );\n    return hmacSha256(signingKey, this.stringToSign(opt.datetime, opt), 'hex');\n  };\n\n  private getDateTime = () => {\n    const date = new Date(new Date().toUTCString());\n    const datetime =\n      date\n        .toISOString()\n        .replace(/\\..+/, '')\n        .replace(/-/g, '')\n        .replace(/:/g, '') + 'Z';\n    return datetime;\n  };\n  private credentialString = (datetime: string) => {\n    return this.createScope(\n      datetime.substr(0, 8),\n      this.options.region,\n      this.options.serviceName\n    );\n  };\n\n  private createScope = (date, region, serviceName) => {\n    return [date.substr(0, 8), region, serviceName, v4Identifier].join('/');\n  };\n\n  private getSigningKey = (credentials: ISigCredentials, date) => {\n    const kDate = hmacSha256(credentials.GetSecretKey(), date);\n    const kRegion = hmacSha256(kDate, this.options.region as string);\n    const kService = hmacSha256(kRegion, this.options.serviceName as string);\n    const signingKey = hmacSha256(kService, v4Identifier);\n\n    return signingKey;\n  };\n\n  private stringToSign = (datetime: string, opt: ISigOptions) => {\n    /* istanbul ignore if */\n    if (!this.options.algorithm) {\n      return '';\n    }\n\n    const parts: string[] = [];\n    parts.push(this.options.algorithm);\n    parts.push(datetime);\n    parts.push(this.credentialString(datetime));\n    const canonicalString =\n      'policy' in opt\n        ? this.canonicalStringPolicy(opt)\n        : this.canonicalString(opt);\n    // console.log('canonicalString',this.canonicalString(opt),' code:',this.hexEncodedHash(this.canonicalString(opt)));\n    parts.push(this.hexEncodedHash(canonicalString));\n    return parts.join('\\n');\n  };\n\n  private hexEncodedHash = string => {\n    return hashSha256(string, 'hex');\n  };\n\n  private canonicalString = (opt: ISigOptions) => {\n    const parts: any[] = [];\n    parts.push(opt.method);\n    parts.push(opt.path);\n    parts.push(this.getEncodePath(opt.query as string, false));\n    parts.push(this.canonicalHeaders(opt) + '\\n');\n    parts.push(this.signedHeaders(opt));\n    parts.push(this.hexEncodedBodyHash());\n    return parts.join('\\n');\n  };\n\n  private canonicalStringPolicy = (opt: ISigOptions) => {\n    const parts: any[] = [];\n    parts.push(this.getEncodePath(opt.query as string, false));\n    parts.push(this.hexEncodedBodyHash());\n    return parts.join('\\n');\n  };\n\n  private canonicalHeaders = (opt: ISigOptions) => {\n    const parts: string[] = [];\n    const needSignHeaders = getNeedSignedHeaders(opt.headers);\n\n    for (let key of needSignHeaders) {\n      const value = opt.headers[key];\n      key = key.toLowerCase();\n      parts.push(key + ':' + this.canonicalHeaderValues(value.toString()));\n    }\n\n    return parts.join('\\n');\n  };\n\n  private canonicalHeaderValues = (values: string) => {\n    return values.replace(/\\s+/g, ' ').replace(/^\\s+|\\s+$/g, '');\n  };\n\n  private signedHeaders = (opt: ISigOptions) => {\n    const keys: string[] = [];\n    const needSignHeaders = getNeedSignedHeaders(opt.headers);\n\n    for (let key of needSignHeaders) {\n      key = key.toLowerCase();\n      keys.push(key);\n    }\n\n    return keys.sort().join(';');\n  };\n\n  /**\n   * ! * ' () aren't transformed by encodeUrl, so they need be handled\n   */\n  private getEncodePath(path: string, encodeAll: boolean = true): string {\n    if (!path) {\n      return '';\n    }\n\n    let tmpPath = path;\n    if (encodeAll) {\n      tmpPath = path.replace(/%2F/g, '/');\n    }\n    tmpPath = tmpPath.replace(/\\(/g, '%28');\n    tmpPath = tmpPath.replace(/\\)/g, '%29');\n    tmpPath = tmpPath.replace(/!/g, '%21');\n    tmpPath = tmpPath.replace(/\\*/g, '%2A');\n    tmpPath = tmpPath.replace(/\\'/g, '%27');\n    return tmpPath;\n  }\n}\n\nexport class ISigV4Credentials implements ISigCredentials {\n  public securityToken: string;\n  public secretAccessKey: string;\n  public accessKeyId: string;\n\n  constructor(\n    securityToken?: string,\n    secretAccessKey?: string,\n    accessKeyId?: string\n  ) {\n    this.accessKeyId = accessKeyId as string;\n    this.secretAccessKey = secretAccessKey as string;\n    this.securityToken = securityToken as string;\n  }\n\n  public GetAccessKey(): string {\n    return this.accessKeyId;\n  }\n\n  public GetSecretKey(): string {\n    return this.secretAccessKey;\n  }\n}\n\nfunction getNeedSignedHeaders(headers: Record<string, unknown> | undefined) {\n  const needSignHeaders: string[] = [];\n  Object.keys(headers || {}).forEach((key: string) => {\n    if (key === 'host' || key.startsWith('x-tos-')) {\n      if (headers[key] != null) {\n        needSignHeaders.push(key);\n      }\n    }\n  });\n  return needSignHeaders.sort();\n}\n","import http from 'http';\nimport https from 'https';\nimport { Socket } from 'net';\n\n// add missing type\ndeclare module 'http' {\n  interface AgentOptions {\n    // reference:\n    // https://stackoverflow.com/questions/51363855/how-to-configure-axios-to-use-ssl-certificate\n    rejectUnauthorized?: boolean;\n  }\n\n  interface Agent {\n    createConnection(...opts: unknown[]): Socket;\n  }\n}\n\ninterface TosAgentOptions extends http.AgentOptions {\n  tosOpts: {\n    enableVerifySSL: boolean;\n    connectionTimeout: number;\n    maxConnections: number;\n    idleConnectionTime: number;\n    isHttps: boolean;\n  };\n}\n\n// not use class grammar, because Agent is dynamic\nexport function TosAgent(opts: TosAgentOptions) {\n  const { tosOpts, ...agentOpts } = opts;\n  const Agent = tosOpts.isHttps ? https.Agent : http.Agent;\n  const agent = new Agent({\n    ...agentOpts,\n    keepAlive: true,\n    rejectUnauthorized: tosOpts.enableVerifySSL,\n    timeout: tosOpts.idleConnectionTime,\n  });\n\n  agent.maxFreeSockets = Infinity;\n  agent.maxTotalSockets = tosOpts.maxConnections;\n\n  const oriCreateConnection = agent.createConnection;\n  agent.createConnection = function (...args) {\n    const socket = oriCreateConnection.call(this, ...args);\n    let isTimeout = false;\n    let isConnected = false;\n    let connectTimer: NodeJS.Timeout | null = null;\n\n    // Place `setTimeout` in `process.nextTick` to avoid to\n    // trigger \"Connect timeout\" when debug\n    process.nextTick(() => {\n      if (isConnected) {\n        return;\n      }\n\n      connectTimer = setTimeout(() => {\n        isTimeout = true;\n      }, tosOpts.connectionTimeout);\n    });\n\n    socket.on('connect', () => {\n      isConnected = true;\n      if (connectTimer) {\n        clearTimeout(connectTimer);\n      }\n\n      if (isTimeout) {\n        socket.destroy(new Error('Connect timeout'));\n      }\n    });\n\n    return socket;\n  };\n\n  return agent;\n}\n","import { hashMd5 } from '../universal/crypto';\nimport axios, {\n  AxiosAdapter,\n  AxiosInstance,\n  AxiosRequestConfig,\n  AxiosResponse,\n  Method,\n} from 'axios';\nimport { ISigV4Credentials, SignersV4 } from '../signatureV4';\nimport { Headers, StringKeys } from '../interface';\nimport TosServerError, { TosServerErrorData } from '../TosServerError';\nimport {\n  encodeHeadersValue,\n  getEndpoint,\n  getNormalDataFromError,\n  getSortedQueryString,\n  isValidBucketName,\n  normalizeProxy,\n} from '../utils';\nimport version from '../version';\nimport { TosAgent } from '../nodejs/TosAgent';\nimport TosClientError from '../TosClientError';\nimport {\n  DEFAULT_CONTENT_TYPE,\n  getObjectInputKey,\n  lookupMimeType,\n  validateObjectName,\n} from './object/utils';\nimport { makeAxiosInst } from '../axios';\nimport type { CRCCls } from '../universal/crc';\nimport * as log from '../log';\nimport mpAdapter from '../axios-miniprogram-adapter';\nimport uniappAdapter from 'axios-adapter-uniapp';\nimport os from 'os';\nimport { retrySignatureNamespace } from '../axios';\n\nexport interface TOSConstructorOptions {\n  accessKeyId: string;\n  accessKeySecret: string;\n  stsToken?: string;\n  bucket?: string;\n  endpoint?: string;\n  /**\n   * default value: true\n   * when using proxyHost&proxyPort, it needs to be set to false\n   */\n  secure?: boolean;\n  region: string;\n\n  /**\n   * proxy for web, use it with the middleware of `./proxy`\n   */\n  proxy?:\n    | string\n    | {\n        url: string;\n        needProxyParams?: boolean;\n      };\n  /**\n   * proxy to general http proxy server, this feature doesn't work in browser environment.\n   * only support http proxy server.\n   * proxyHost and proxyPort are required if the proxy function works.\n   * HINT: need set `secure` field false\n   */\n  proxyHost?: string;\n  proxyPort?: number;\n  // username and password don't be supported currently\n  // proxyUsername?: string;\n  // proxyPassword?: string;\n\n  /**\n   * default value: true\n   */\n  enableVerifySSL?: boolean;\n\n  /**\n   * default value: true\n   */\n  autoRecognizeContentType?: boolean;\n\n  /**\n   * unit: ms\n   * default value: 120s\n   * disable if value <= 0\n   */\n  requestTimeout?: number;\n\n  /**\n   * unit: ms\n   * default value: 10s\n   * disable if value <= 0\n   */\n  connectionTimeout?: number;\n\n  /**\n   * default value: 1024\n   */\n  maxConnections?: number;\n\n  /**\n   * unit: ms\n   * default value: 30s\n   */\n  idleConnectionTime?: number;\n\n  /**\n   * default value: 3\n   *\n   * disable if value <= 0\n   */\n  maxRetryCount?: number;\n\n  // TODO: need more efficient way, 1min for 10M currently\n  /**\n   * default value: false\n   *\n   * CRC executed by js is slow currently, it's default value will be true if it is fast enough.\n   */\n  enableCRC?: boolean;\n\n  /**\n   * set request adapter to send request.\n   */\n  requestAdapter?: AxiosAdapter;\n\n  /**\n   * default value: false  ${bucket}.${endpoint}\n   * if true request will not combine `${bucket}.${endpoint}`\n   */\n  isCustomDomain?: boolean;\n\n  /**\n   * @private unstable option: false | true | undefined\n   * default value: undefined\n   * true:\n   * Allow SDK to internally catch server errors for 404 and return default values\n   * Allow SDK to internally change some put methods to delete methods when pass empty value\n   */\n  enableOptimizeMethodBehavior?: boolean;\n  /**\n   * @private unstable option\n   */\n  forcePathStyle?: boolean;\n\n  userAgentProductName?: string;\n  userAgentSoftName?: string;\n  userAgentSoftVersion?: string;\n  userAgentCustomizedKeyValues?: Record<string, string>;\n}\n\ninterface NormalizedTOSConstructorOptions extends TOSConstructorOptions {\n  secure: boolean;\n  endpoint: string;\n  enableVerifySSL: boolean;\n  autoRecognizeContentType: boolean;\n  requestTimeout: number;\n  connectionTimeout: number;\n  maxConnections: number;\n  idleConnectionTime: number;\n  maxRetryCount: number;\n  enableCRC: boolean;\n}\n\ninterface GetSignatureQueryUrlInput {\n  bucket: string;\n  method: Method;\n  path: string;\n  subdomain: boolean;\n  endpoint: string;\n  // unit: second\n  expires: number;\n  query?: Record<string, any>;\n}\n\ninterface GetSignaturePolicyQueryInput {\n  bucket: string;\n  expires: number;\n  policy: {\n    conditions: (string[] | { bucket: string } | { key: string })[];\n  };\n}\n\ntype GetSignatureQueryInput =\n  | GetSignatureQueryUrlInput\n  | GetSignaturePolicyQueryInput;\n\ninterface FetchOpts<T> {\n  needMd5?: boolean;\n  handleResponse?: (response: AxiosResponse<T>) => T;\n  subdomainBucket?: string;\n  axiosOpts?: AxiosRequestConfig;\n}\n\nexport interface TosResponse<T> {\n  data: T;\n\n  statusCode: number;\n  headers: Headers;\n  /**\n   * identifies the errored request, equals to headers['x-tos-request-id'].\n   * If you has any question about the request, please send the requestId and id2 to TOS worker.\n   */\n  requestId: string;\n\n  /**\n   * identifies the errored request, equals to headers['x-tos-id-2'].\n   * If you has any question about the request, please send the requestId and id2 to TOS worker.\n   */\n  id2: string;\n}\n\nexport class TOSBase {\n  opts: NormalizedTOSConstructorOptions;\n\n  axiosInst: AxiosInstance;\n\n  userAgent: string;\n\n  private httpAgent: unknown;\n  private httpsAgent: unknown;\n\n  constructor(_opts: TOSConstructorOptions) {\n    this.opts = this.normalizeOpts(_opts);\n\n    if (process.env.TARGET_ENVIRONMENT === 'node') {\n      this.httpAgent = TosAgent({ tosOpts: { ...this.opts, isHttps: false } });\n      // fix axios issue, it uses `httpsAgent` although http proxy is enabled.\n      const isProxy = !!this.opts.proxyHost;\n      this.httpsAgent = TosAgent({\n        tosOpts: { ...this.opts, isHttps: !isProxy },\n      });\n    }\n\n    this.userAgent = this.getUserAgent();\n    this.axiosInst = makeAxiosInst(this.opts.maxRetryCount);\n  }\n\n  private normalizeOpts(_opts: TOSConstructorOptions) {\n    //  trim \n    const trimKeys = [\n      'accessKeyId',\n      'accessKeySecret',\n      'stsToken',\n      'region',\n      'endpoint',\n    ] as const;\n    trimKeys.forEach((key) => {\n      const value = _opts[key];\n      if (typeof value === 'string') {\n        // maybe undefined\n        _opts[key] = value.trim();\n      }\n    });\n\n    const mustKeys = ['accessKeyId', 'accessKeySecret', 'region'];\n    const mustKeysErrorStr = mustKeys\n      .filter((key) => !(_opts as any)[key])\n      .join(', ');\n\n    if (mustKeysErrorStr) {\n      throw new TosClientError(`lack params: ${mustKeysErrorStr}.`);\n    }\n\n    const endpoint = _opts.endpoint || getEndpoint(_opts.region);\n    if (!endpoint) {\n      throw new TosClientError(\n        `the value of param region is invalid, correct values are cn-beijing, cn-nantong etc.`\n      );\n    }\n\n    if (endpoint.includes('s3')) {\n      throw new TosClientError(\n        `do not support s3 endpoint, please use tos endpoint.`\n      );\n    }\n\n    const secure = _opts.secure == null ? true : !!_opts.secure;\n    const _default = <T extends unknown>(\n      v: T | undefined | null,\n      defaultValue: T\n    ) => (v == null ? defaultValue : v);\n\n    const enableCRC = _opts.enableCRC ?? false;\n    if (enableCRC && process.env.TARGET_ENVIRONMENT === 'browser') {\n      throw new TosClientError('not support crc in browser environment');\n    }\n\n    return {\n      ..._opts,\n      endpoint,\n      secure,\n      enableVerifySSL: _default(_opts.enableVerifySSL, true),\n      autoRecognizeContentType: _default(_opts.autoRecognizeContentType, true),\n      requestTimeout: _default(_opts.requestTimeout, 120_000),\n      connectionTimeout: _default(_opts.connectionTimeout, 10_000),\n      maxConnections: _default(_opts.maxConnections, 1024),\n      idleConnectionTime: _default(_opts.idleConnectionTime, 30_000),\n      maxRetryCount: _default(_opts.maxRetryCount, 3),\n      enableCRC: _opts.enableCRC ?? false,\n      requestAdapter: getAdapter(),\n    };\n  }\n\n  private getUserAgent() {\n    // ve-tos-go-sdk/v2.0.0 (linux/amd64;go1.17.0)\n    const language =\n      process.env.TARGET_ENVIRONMENT === 'browser' ? 'browserjs' : 'nodejs';\n    const sdkVersion = `ve-tos-${language}-sdk/v${version}`;\n    if (process.env.TARGET_ENVIRONMENT === 'browser') {\n      return sdkVersion;\n    }\n\n    const osType = (() => {\n      const oriType = os.type();\n      const aliasType: Record<string, string> = {\n        Linux: 'linux',\n        Darwin: 'darwin',\n        Windows_NT: 'windows',\n      };\n      return aliasType[oriType] || oriType;\n    })();\n    const nodeVersion = (() => {\n      return process.version.replace('v', '');\n    })();\n    const stdStr = `${sdkVersion} (${osType}/${process.arch};nodejs${nodeVersion})`;\n    const moreStr = (() => {\n      const { userAgentProductName, userAgentSoftName, userAgentSoftVersion } =\n        this.opts;\n      let customStr = Object.entries(\n        this.opts.userAgentCustomizedKeyValues || {}\n      )\n        .map(([k, v]) => {\n          return `${k}/${v}`;\n        })\n        .join(';');\n      customStr = customStr ? `(${customStr})` : '';\n\n      if (\n        !userAgentProductName &&\n        !userAgentSoftName &&\n        !userAgentSoftVersion &&\n        !customStr\n      ) {\n        return '';\n      }\n      const defaultValue = 'undefined';\n      const productSoftStr = [\n        userAgentProductName,\n        userAgentSoftName,\n        userAgentSoftVersion,\n      ]\n        .map((it) => it || defaultValue)\n        .join('/');\n\n      return [productSoftStr, customStr].filter(Boolean).join(' ');\n    })();\n\n    return [stdStr, moreStr].filter(Boolean).join(' -- ');\n  }\n\n  protected async fetch<Data>(\n    method: Method,\n    path: string,\n    query: Record<string, any>,\n    headers: Headers,\n    body?: Object | File | Blob | NodeJS.ReadableStream,\n    opts?: FetchOpts<Data>\n  ): Promise<TosResponse<Data>> {\n    const handleResponse = opts?.handleResponse || ((res) => res.data);\n    const needMd5 = opts?.needMd5 || false;\n\n    if (body && needMd5) {\n      const md5String = hashMd5(JSON.stringify(body), 'base64');\n      headers['content-md5'] = md5String;\n    }\n\n    const [endpoint, newPath] = (() => {\n      if (opts?.subdomainBucket && this.opts.forcePathStyle) {\n        return [this.opts.endpoint, `/${opts.subdomainBucket}${path}`];\n      }\n      // if isCustomDomain true, not add subdomainBucket\n      if (opts?.subdomainBucket && !this.opts.isCustomDomain) {\n        // endpoint is ip address\n        if (/^(\\d|:)/.test(this.opts.endpoint)) {\n          return [this.opts.endpoint, `/${opts.subdomainBucket}${path}`];\n        }\n        return [`${opts?.subdomainBucket}.${this.opts.endpoint}`, path];\n      }\n      return [this.opts.endpoint, path];\n    })();\n    path = newPath;\n\n    headers = encodeHeadersValue(headers);\n\n    const signOpt = {\n      // TODO: delete endpoints and buckets\n      endpoints: undefined,\n      bucket: '',\n\n      method,\n      headers: { ...headers },\n      path,\n      query: getSortedQueryString(query),\n      host: endpoint,\n    };\n\n    const signv4 = new ISigV4Credentials(\n      this.opts.stsToken,\n      this.opts.accessKeySecret,\n      this.opts.accessKeyId\n    );\n\n    const sig = new SignersV4(\n      {\n        algorithm: 'TOS4-HMAC-SHA256',\n        region: this.opts.region,\n        serviceName: 'tos',\n        bucket: '',\n        securityToken: this.opts.stsToken,\n      },\n      signv4\n    );\n\n    const signatureHeaders = sig.signatureHeader(signOpt);\n    const reqHeaders = { ...headers };\n\n    const reqOpts: AxiosRequestConfig = {\n      method,\n      baseURL: `http${this.opts.secure ? 's' : ''}://${endpoint}`,\n      url: path,\n      params: query,\n      headers: reqHeaders,\n      // axios xhr  === undefined  content-type\n      data: body || '',\n    };\n\n    signatureHeaders.forEach((value, key) => {\n      reqOpts.headers[key] = value;\n    });\n\n    const normalizedProxy = normalizeProxy(this.opts.proxy);\n    if (normalizedProxy?.url && !this.opts.proxyHost) {\n      // proxy for nodejs middleware server\n      reqOpts.baseURL = normalizedProxy.url;\n      if (normalizedProxy?.needProxyParams) {\n        reqOpts.params['x-proxy-tos-host'] = endpoint;\n        delete reqHeaders['host'];\n      }\n    } else if (this.opts.proxyHost) {\n      if (!this.opts.proxyPort) {\n        throw new TosClientError(\n          'The `proxyPort` is required if `proxyHost` is truly.'\n        );\n      }\n\n      // proxy for general proxy server\n      reqOpts.proxy = {\n        host: this.opts.proxyHost,\n        port: this.opts.proxyPort,\n        protocol: 'http',\n      };\n    }\n\n    reqHeaders['user-agent'] = this.userAgent;\n    if (this.opts.requestTimeout > 0 && this.opts.requestTimeout !== Infinity) {\n      reqOpts.timeout = this.opts.requestTimeout;\n    }\n\n    if (process.env.TARGET_ENVIRONMENT === 'node') {\n      reqOpts.httpAgent = this.httpAgent;\n      reqOpts.httpsAgent = this.httpsAgent;\n    }\n\n    try {\n      const logReqOpts = { ...reqOpts };\n      delete logReqOpts.httpAgent;\n      delete logReqOpts.httpsAgent;\n      log.TOS('reqOpts: ', logReqOpts);\n      const res = await this.axiosInst({\n        ...{\n          maxBodyLength: Infinity,\n          maxContentLength: Infinity,\n          adapter: this.opts.requestAdapter,\n        },\n        ...reqOpts,\n        ...(opts?.axiosOpts || {}),\n        [retrySignatureNamespace]: {\n          signOpt,\n          sigInst: sig,\n        },\n      });\n\n      const data = handleResponse(res);\n      return {\n        data,\n        statusCode: res.status,\n        headers: res.headers,\n        requestId: res.headers['x-tos-request-id'],\n        id2: res.headers['x-tos-id-2'],\n      };\n    } catch (err) {\n      if (\n        axios.isAxiosError(err) &&\n        err.response?.headers?.['x-tos-request-id']\n      ) {\n        // it's ServerError only if `RequestId` exists\n        const response: AxiosResponse<TosServerErrorData> = err.response;\n        log.TOS('TosServerError response: ', response);\n        const err2 = new TosServerError(response);\n        throw err2;\n      }\n\n      // it is neither ServerError nor ClientError, it's other error\n      log.TOS('err: ', err);\n      throw err;\n    }\n  }\n\n  protected async fetchBucket<Data>(\n    bucket: string | undefined,\n    method: Method,\n    query: any,\n    headers: Headers,\n    body?: Object | File | Blob | NodeJS.ReadableStream,\n    opts?: FetchOpts<Data>\n  ): Promise<TosResponse<Data>> {\n    const actualBucket = bucket || this.opts.bucket;\n    if (!actualBucket) {\n      throw new TosClientError('Must provide bucket param');\n    }\n\n    isValidBucketName(actualBucket, this.opts.isCustomDomain);\n\n    return this.fetch(method, '/', query, headers, body, {\n      ...opts,\n      subdomainBucket: actualBucket,\n    });\n  }\n\n  protected async _fetchObject<Data>(\n    input: { bucket?: string; key: string } | string,\n    method: Method,\n    query: any,\n    headers: Headers,\n    body?: Object | File | Blob | NodeJS.ReadableStream,\n    opts?: FetchOpts<Data>\n  ): Promise<TosResponse<Data>> {\n    const actualBucket =\n      (typeof input !== 'string' && input.bucket) || this.opts.bucket;\n    const actualKey = typeof input === 'string' ? input : input.key;\n    if (!actualBucket) {\n      throw new TosClientError('Must provide bucket param');\n    }\n\n    isValidBucketName(actualBucket, this.opts.isCustomDomain);\n    validateObjectName(actualKey);\n\n    return this.fetch(\n      method,\n      `/${encodeURIComponent(actualKey)}`,\n      query,\n      headers,\n      body,\n      {\n        ...opts,\n        subdomainBucket: actualBucket,\n      }\n    );\n  }\n\n  protected getSignatureQuery(\n    input: GetSignatureQueryInput\n  ): Record<string, string> {\n    const signv4 = new ISigV4Credentials(\n      this.opts.stsToken,\n      this.opts.accessKeySecret,\n      this.opts.accessKeyId\n    );\n\n    const sig = new SignersV4(\n      {\n        algorithm: 'TOS4-HMAC-SHA256',\n        region: this.opts.endpoint,\n        serviceName: 'tos',\n        // SignV4 uses this.options.bucket, so set it here\n        bucket: input.bucket,\n        securityToken: this.opts.stsToken,\n      },\n      signv4\n    );\n\n    if ('policy' in input) {\n      return sig.getSignaturePolicyQuery(\n        {\n          policy: input.policy,\n        },\n        input.expires\n      );\n    } else {\n      return sig.getSignatureQuery(\n        {\n          method: input.method,\n          path: input.path,\n          endpoints: input.subdomain ? input.endpoint : undefined,\n          host: input.endpoint,\n          query: input.query,\n        },\n        input.expires\n      );\n    }\n  }\n\n  protected getObjectPath = (\n    opts: { bucket?: string; key: string } | string\n  ) => {\n    const actualBucket =\n      (typeof opts !== 'string' && opts.bucket) || this.opts.bucket;\n    const actualKey = typeof opts === 'string' ? opts : opts.key;\n    if (!actualBucket) {\n      throw new TosClientError('Must provide bucket param');\n    }\n    return `/${actualBucket}/${encodeURIComponent(actualKey)}`;\n  };\n\n  protected normalizeBucketInput<T extends { bucket: string }>(\n    input: T | string\n  ): T {\n    return (typeof input === 'string' ? { bucket: input } : input) as T;\n  }\n  protected normalizeObjectInput<T extends { key: string }>(\n    input: T | string\n  ): T {\n    return (typeof input === 'string' ? { key: input } : input) as T;\n  }\n\n  protected setObjectContentTypeHeader = (\n    input: string | { key: string },\n    headers: Headers\n  ): void => {\n    if (headers['content-type'] != null) {\n      return;\n    }\n\n    let mimeType = DEFAULT_CONTENT_TYPE;\n    const key = getObjectInputKey(input);\n\n    if (this.opts.autoRecognizeContentType) {\n      mimeType = lookupMimeType(key) || mimeType;\n    }\n\n    if (mimeType) {\n      headers['content-type'] = mimeType;\n    }\n  };\n\n  protected getNormalDataFromError = getNormalDataFromError;\n}\n\nexport default TOSBase;\n\nfunction getAdapter(): AxiosAdapter | undefined {\n  if (process.env.TARGET_ENVIRONMENT === 'node') {\n    // nodejs env\n    return undefined;\n  }\n  if (typeof window !== 'undefined' && typeof window.location !== 'undefined') {\n    // browser env\n    return undefined;\n  }\n\n  switch (true) {\n    case typeof wx !== 'undefined':\n    case typeof swan !== 'undefined':\n    case typeof dd !== 'undefined':\n    case typeof my !== 'undefined':\n      return mpAdapter as AxiosAdapter;\n    case typeof uni !== 'undefined':\n      return uniappAdapter as AxiosAdapter;\n    default:\n      return undefined;\n  }\n}\n","import { covertCamelCase2Kebab, makeArrayProp } from '../../utils';\nimport TOSBase from '../base';\n\nexport interface ListObjectsInput {\n  bucket?: string;\n  continuationToken?: string;\n  delimiter?: string;\n  encodingType?: string;\n  fetchOwner?: string;\n  maxKeys?: string | number;\n  prefix?: string;\n  marker?: string;\n\n  /**\n   * use `marker` instead of `startAfter`\n   */\n  startAfter?: string;\n  /**\n   * equal to listObjectVersions when input\n   */\n  versions?: string;\n  listType?: string;\n  versionIdMarker?: string;\n  /**\n   * only works when pass versions field\n   */\n  keyMarker?: string;\n}\n\nexport interface ListObjectsContentItem {\n  ETag: string;\n  Key: string;\n  // \"2021-08-02T09:53:27.000Z\"\n  LastModified: string;\n  Owner: { ID: string; DisplayName: string };\n  Size: number;\n  StorageClass: string;\n}\n\nexport interface ListObjectsVersionItem {\n  ETag: string;\n  IsLatest: boolean;\n  Key: string;\n  LastModified: string;\n  Owner: { ID: string; DisplayName: string };\n  Size: number;\n  StorageClass: string;\n  VersionId: string;\n}\n\nexport interface ListObjectDeleteMarkerItem {\n  ETag: string;\n  IsLatest: boolean;\n  Key: string;\n  LastModified: string;\n  Owner: { ID: string; DisplayName: string };\n  Size: number;\n  StorageClass: string;\n  VersionId: string;\n}\n\nexport interface ListedCommonPrefix {\n  Prefix: string;\n}\nexport interface ListObjectsOutput {\n  CommonPrefixes: ListedCommonPrefix[];\n  Contents: ListObjectsContentItem[];\n  IsTruncated: boolean;\n  Marker: string;\n  MaxKeys: number;\n  KeyMarker?: string;\n  Name: string;\n  Prefix: string;\n  ContinuationToken?: string;\n  NextContinuationToken?: string;\n  Delimiter?: string;\n  EncodingType?: string;\n  NextMarker?: string;\n  VersionIdMarker?: string;\n  Versions: ListObjectsVersionItem[];\n  NextKeyMarker?: string;\n  DeleteMarkers: ListObjectDeleteMarkerItem[];\n  NextVersionIdMarker?: string;\n}\n\nclass TOSListObjects extends TOSBase {\n  listObjects = listObjects;\n  listObjectVersions = listObjectVersions;\n}\n\n/**\n *\n * @deprecated use listObjectsType2 instead\n * @returns\n */\nexport async function listObjects(\n  this: TOSListObjects,\n  input: ListObjectsInput = {}\n) {\n  const { bucket, ...nextQuery } = input;\n  const ret = await this.fetchBucket<ListObjectsOutput>(\n    input.bucket,\n    'GET',\n    covertCamelCase2Kebab(nextQuery),\n    {}\n  );\n  const arrayProp = makeArrayProp(ret.data);\n  arrayProp('CommonPrefixes');\n  arrayProp('Contents');\n  arrayProp('Versions');\n  arrayProp('DeleteMarkers');\n  return ret;\n}\n\nexport type ListObjectVersionsInput = Pick<\n  ListObjectsInput,\n  | 'bucket'\n  | 'prefix'\n  | 'delimiter'\n  | 'keyMarker'\n  | 'versionIdMarker'\n  | 'maxKeys'\n  | 'encodingType'\n>;\n\nexport interface listObjectVersionsOutput {\n  Name: string;\n  Prefix: string;\n  KeyMarker?: string;\n  VersionIdMarker?: string;\n  MaxKeys: number;\n  Delimiter?: string;\n  IsTruncated: boolean;\n  EncodingType?: string;\n  NextKeyMarker?: string;\n  NextVersionIdMarker?: string;\n  CommonPrefixes: ListedCommonPrefix[];\n  Versions: ListObjectsVersionItem[];\n  DeleteMarkers: ListObjectDeleteMarkerItem[];\n}\n\nexport async function listObjectVersions(\n  this: TOSListObjects,\n  input: ListObjectVersionsInput = {}\n) {\n  const { bucket, ...nextQuery } = input;\n  const ret = await this.fetchBucket<listObjectVersionsOutput>(\n    input.bucket,\n    'GET',\n    covertCamelCase2Kebab({ versions: '', ...nextQuery }),\n    {}\n  );\n  const arrayProp = makeArrayProp(ret.data);\n  arrayProp('CommonPrefixes');\n  arrayProp('Versions');\n  arrayProp('DeleteMarkers');\n  return ret;\n}\n","import { covertCamelCase2Kebab, makeArrayProp } from '../../utils';\nimport TOSBase, { TosResponse } from '../base';\n\nexport interface ListObjectsType2Input {\n  bucket?: string;\n  prefix?: string;\n  delimiter?: string;\n  encodingType?: string;\n  /**\n   * if not specify `maxKeys` field, default maxKeys value is 1000.\n   */\n  maxKeys?: number;\n  continuationToken?: string;\n  startAfter?: string;\n  /**\n   * default value: false\n   * if set false, the method will keep fetch objects until get `maxKeys` objects.\n   * if set true,  the method will fetch objects once\n   */\n  listOnlyOnce?: boolean;\n}\n\nexport interface ListObjectsType2ContentItem {\n  ETag: string;\n  Key: string;\n  // \"2021-08-02T09:53:27.000Z\"\n  LastModified: string;\n  Owner?: { ID: string; DisplayName: string };\n  Size: number;\n  StorageClass: string;\n  HashCrc64ecma?: string;\n}\n\nexport interface ListObjectsType2VersionItem {\n  ETag: string;\n  IsLatest: boolean;\n  Key: string;\n  LastModified: string;\n  Owner: { ID: string; DisplayName: string };\n  Size: number;\n  StorageClass: string;\n  VersionId: string;\n}\n\nexport interface ListObjectDeleteMarkerItem {\n  ETag: string;\n  IsLatest: boolean;\n  Key: string;\n  LastModified: string;\n  Owner: { ID: string; DisplayName: string };\n  Size: number;\n  StorageClass: string;\n  VersionId: string;\n}\n\nexport interface ListedCommonPrefix {\n  Prefix: string;\n}\n\nexport interface ListObjectsType2Output {\n  Name: string;\n  Prefix: string;\n  MaxKeys: number;\n  Delimiter?: string;\n  EncodingType?: string;\n  IsTruncated: boolean;\n  KeyCount: number;\n  StartAfter?: string;\n  ContinuationToken?: string;\n  NextContinuationToken?: string;\n  CommonPrefixes: ListedCommonPrefix[];\n  Contents: ListObjectsType2ContentItem[];\n}\n\nclass TOSListObjectsType2 extends TOSBase {\n  listObjectsType2 = listObjectsType2;\n}\nconst DefaultListMaxKeys = 1000;\n\nexport async function listObjectsType2(\n  this: TOSListObjectsType2,\n  input: ListObjectsType2Input = {}\n): Promise<TosResponse<ListObjectsType2Output>> {\n  const { listOnlyOnce = false } = input;\n\n  let output;\n  if (!input.maxKeys) {\n    input.maxKeys = DefaultListMaxKeys;\n  }\n\n  if (listOnlyOnce) {\n    output = await listObjectsType2Once.call(this, input);\n  } else {\n    const maxKeys = input.maxKeys;\n    let params = {\n      ...input,\n      maxKeys,\n    };\n    while (true) {\n      const res = await listObjectsType2Once.call(this, params);\n      if (output == null) {\n        output = res;\n      } else {\n        output = {\n          ...res,\n          data: output.data,\n        };\n        output.data.KeyCount += res.data.KeyCount;\n        output.data.IsTruncated = res.data.IsTruncated;\n        output.data.NextContinuationToken = res.data.NextContinuationToken;\n        output.data.Contents = output.data.Contents.concat(res.data.Contents);\n        output.data.CommonPrefixes = output.data.CommonPrefixes.concat(\n          res.data.CommonPrefixes\n        );\n      }\n\n      if (!res.data.IsTruncated || output.data.KeyCount >= maxKeys) {\n        break;\n      }\n\n      params.continuationToken = res.data.NextContinuationToken;\n      params.maxKeys = params.maxKeys - res.data.KeyCount;\n    }\n  }\n\n  return output;\n}\nasync function listObjectsType2Once(\n  this: TOSListObjectsType2,\n  input: ListObjectsType2Input\n) {\n  const { bucket, ...nextQuery } = input;\n\n  const ret = await this.fetchBucket<ListObjectsType2Output>(\n    input.bucket,\n    'GET',\n    {\n      'list-type': 2,\n      ...covertCamelCase2Kebab(nextQuery),\n    },\n    {}\n  );\n  const arrayProp = makeArrayProp(ret.data);\n  arrayProp('CommonPrefixes');\n  arrayProp('Contents');\n  return ret;\n}\n","import { TosClientError } from './browser-index';\nimport { TOSBase, type TOSConstructorOptions } from './methods/base';\nimport { paramsSerializer } from './utils';\nimport { getObjectV2 } from './methods/object/getObject';\nimport headObject from './methods/object/headObject';\nimport { listObjectVersions, listObjects } from './methods/object/listObjects';\nimport downloadFile from './methods/object/downloadFile';\nimport { listObjectsType2 } from './methods/object/listObjectsType2';\n\nexport interface ShareLinkClientOptions\n  extends Omit<\n    TOSConstructorOptions,\n    'region' | 'accessKeyId' | 'accessKeySecret' | 'endpoint' | 'bucket'\n  > {\n  policyUrl: string;\n}\n\ninterface ParsedPolicyUrlVal {\n  origin: string;\n  host: string;\n  search: string;\n}\n\n/** @private unstable */\nexport class ShareLinkClient extends TOSBase {\n  shareLinkClientOpts: ShareLinkClientOptions;\n\n  private parsedPolicyUrlVal: ParsedPolicyUrlVal;\n\n  modifyAxiosInst() {\n    const axiosInst = this.axiosInst;\n\n    axiosInst.interceptors.request.use((config) => {\n      const headers = config.headers || {};\n      delete headers['authorization'];\n      headers['host'] = this.parsedPolicyUrlVal.host;\n      config.baseURL = this.parsedPolicyUrlVal.origin;\n      config.paramsSerializer = (params) => {\n        const addQueryStr = paramsSerializer(params);\n        return [this.parsedPolicyUrlVal.search, addQueryStr]\n          .filter((it) => it.trim())\n          .join('&');\n      };\n      return config;\n    });\n  }\n\n  constructor(_opts: ShareLinkClientOptions) {\n    super({\n      ..._opts,\n\n      bucket: 'fake-bucket',\n      region: 'fake-region',\n      accessKeyId: 'fake-accessKeyId',\n      accessKeySecret: 'fake-accessKeySecret',\n      endpoint: 'fake-endpoint.com',\n    });\n\n    this.shareLinkClientOpts = _opts;\n    this.parsedPolicyUrlVal = this.initParsedPolicyUrlVal();\n    this.modifyAxiosInst();\n  }\n\n  private initParsedPolicyUrlVal(): ParsedPolicyUrlVal {\n    const reg = /(https?:\\/\\/(?:[^@]+@)?([^/?]+))[^?]*\\?(.+)/;\n    const matched = this.shareLinkClientOpts.policyUrl.match(reg);\n    if (!matched) {\n      throw new TosClientError('the `policyUrl` param is invalid');\n    }\n    return {\n      origin: matched[1],\n      host: matched[2],\n      search: matched[3],\n    };\n  }\n\n  headObject = headObject;\n  getObjectV2 = getObjectV2;\n  listObjects = listObjects;\n  listObjectsType2 = listObjectsType2;\n  listObjectVersions = listObjectVersions;\n  downloadFile = downloadFile;\n}\n","import TOSBase from '../base';\nimport { Acl, Headers, StorageClass } from '../../interface';\nimport {\n  fillRequestHeaders,\n  makeArrayProp,\n  normalizeHeadersKey,\n} from '../../utils';\nimport TosClientError from '../../TosClientError';\nimport { AzRedundancyType, StorageClassType } from '../../TosExportEnum';\nimport { TosHeader } from '../object/sharedTypes';\n\nexport interface Bucket {\n  // '2021-07-20T09:22:05.000Z'\n  CreationDate: string;\n  ExtranetEndpoint: string;\n  IntranetEndpoint: string;\n  Location: string;\n  Name: string;\n  Owner: { ID: string };\n  BucketType?: string;\n}\n\nexport interface ListBucketOutput {\n  Buckets: Bucket[];\n}\n\nexport interface PutBucketInput {\n  bucket?: string;\n  acl?: Acl;\n  grantFullControl?: string;\n  grantRead?: string;\n  grantReadAcp?: string;\n  grantWrite?: string;\n  grantWriteAcp?: string;\n  storageClass?: StorageClassType;\n  azRedundancy?: AzRedundancyType;\n  projectName?: string;\n  bucketType?: string;\n  headers?: {\n    [key: string]: string | undefined;\n    ['x-tos-acl']?: Acl;\n    ['x-tos-grant-full-control']?: string;\n    ['x-tos-grant-read']?: string;\n    ['x-tos-grant-read-acp']?: string;\n    ['x-tos-grant-write']?: string;\n    ['x-tos-grant-write-acp']?: string;\n    ['x-tos-storage-class']?: StorageClass;\n  };\n}\nexport interface ListBucketInput {\n  projectName?: string;\n}\nexport async function listBuckets(this: TOSBase, input: ListBucketInput = {}) {\n  const headers = {};\n  /**\n   * empty string is invalid value\n   */\n  input?.projectName &&\n    fillRequestHeaders({ ...input, headers }, ['projectName']);\n  const res = await this.fetch<ListBucketOutput>('GET', '/', {}, headers);\n  const arrayProp = makeArrayProp(res.data);\n  arrayProp('Buckets');\n\n  return res;\n}\n\nexport async function createBucket(this: TOSBase, input: PutBucketInput) {\n  const actualBucket = input.bucket || this.opts.bucket;\n  // these errors are only for creating bucket\n  if (actualBucket) {\n    if (actualBucket.length < 3 || actualBucket.length > 63) {\n      throw new TosClientError(\n        'invalid bucket name, the length must be [3, 63]'\n      );\n    }\n    if (!/^([a-z]|-|\\d)+$/.test(actualBucket)) {\n      throw new TosClientError(\n        'invalid bucket name, the character set is illegal'\n      );\n    }\n    if (/^-/.test(actualBucket) || /-$/.test(actualBucket)) {\n      throw new TosClientError(\n        `invalid bucket name, the bucket name can be neither starting with '-' nor ending with '-'`\n      );\n    }\n  }\n  const headers = (input.headers = normalizeHeadersKey(input.headers));\n\n  fillRequestHeaders(input, [\n    'acl',\n    'grantFullControl',\n    'grantRead',\n    'grantReadAcp',\n    'grantWrite',\n    'grantWriteAcp',\n    'storageClass',\n    'azRedundancy',\n    'bucketType',\n  ]);\n\n  /**\n   * empty string is invalid value\n   */\n  input?.projectName && fillRequestHeaders(input, ['projectName']);\n\n  const res = await this.fetchBucket(input.bucket, 'PUT', {}, headers);\n  return res;\n}\n\nexport async function deleteBucket(this: TOSBase, bucket?: string) {\n  return this.fetchBucket(bucket, 'DELETE', {}, {});\n}\n\nexport interface HeadBucketOutput {\n  ['x-tos-bucket-region']: string;\n  ['x-tos-storage-class']: StorageClass;\n  ['x-tos-bucket-type']?: string;\n  ProjectName?: string;\n}\n\nexport async function headBucket(this: TOSBase, bucket?: string) {\n  return this.fetchBucket<HeadBucketOutput>(bucket, 'HEAD', {}, {}, undefined, {\n    handleResponse: (res) => {\n      return {\n        ...res.headers,\n        ProjectName: res.headers[TosHeader.HeaderProjectName],\n      };\n    },\n  });\n}\n\nexport interface PutBucketStorageClassInput {\n  bucket: string;\n  storageClass: StorageClassType;\n}\n\nexport interface PutBucketStorageClassOutput {}\n\nexport async function putBucketStorageClass(\n  this: TOSBase,\n  input: PutBucketStorageClassInput\n) {\n  const { bucket, storageClass } = input;\n\n  return this.fetchBucket<PutBucketStorageClassOutput>(\n    bucket,\n    'PUT',\n    { storageClass: '' },\n    {\n      'x-tos-storage-class': storageClass,\n    }\n  );\n}\n","import TOSBase from '../base';\nimport { Headers, AclInterface, Acl } from '../../interface';\nimport { makeArrayProp } from '../../utils';\n\nexport type GetBucketAclOutput = AclInterface;\n\nexport interface PutBucketAclInput {\n  bucket?: string;\n  acl?: Acl;\n  aclBody?: AclInterface;\n}\n\nexport async function putBucketAcl(this: TOSBase, input: PutBucketAclInput) {\n  const headers: Headers = {};\n  if (input.acl) headers['x-tos-acl'] = input.acl;\n\n  const res = await this.fetchBucket(\n    input.bucket,\n    'PUT',\n    { acl: '' },\n    headers,\n    input.aclBody,\n    { needMd5: true }\n  );\n  return res;\n}\n\nexport async function getBucketAcl(this: TOSBase, bucket?: string) {\n  const res = await this.fetchBucket<GetBucketAclOutput>(\n    bucket,\n    'GET',\n    {\n      acl: '',\n    },\n    {}\n  );\n  const arrayProp = makeArrayProp(res.data);\n  arrayProp('Grants');\n  return res;\n}\n","import TOSBase from '../base';\n\ninterface TLSHttpsConfig {\n  Enable: boolean;\n  MinTLSVersion: string;\n  MaxTLSVersion: string;\n}\n\nexport interface PutBucketHttpsConfigInput  {\n  bucket: string;\n  TLS: TLSHttpsConfig;\n}\n\nexport interface GetBucketHttpsConfigOutput  {\n  TLS: TLSHttpsConfig;\n}\n\n/**\n * @private\n */\nexport async function putBucketHttpsConfig(this: TOSBase, input: PutBucketHttpsConfigInput) {\n  const { bucket, TLS } = input;\n  const res = await this.fetchBucket(\n    bucket,\n    'PUT',\n    { httpsConfig: '' },\n    {},\n    {\n      TLS,\n    },\n  );\n  return res;\n}\n\n/**\n * @private\n */\nexport async function getBucketHttpsConfig(this: TOSBase, bucket: string) {\n  const res = await this.fetchBucket<GetBucketHttpsConfigOutput>(\n    bucket,\n    'GET',\n    {\n      httpsConfig: '',\n    },\n    {}\n  );\n  return res;\n}\n","import TOSBase, { TosResponse } from '../base';\nimport {\n  checkCRC64WithHeaders,\n  fillRequestHeaders,\n  makeRetryStreamAutoClose,\n  normalizeHeadersKey,\n  safeAwait,\n  tryDestroy,\n} from '../../utils';\nimport {\n  Acl,\n  DataTransferStatus,\n  DataTransferType,\n  SupportObjectBody,\n} from '../../interface';\nimport TosClientError from '../../TosClientError';\nimport * as fsp from '../../nodejs/fs-promises';\nimport { Stats, ReadStream } from 'fs';\nimport { getSize, getNewBodyConfig } from './utils';\nimport { retryNamespace } from '../../axios';\nimport { IRateLimiter } from '../../universal/rate-limiter';\nimport { StorageClassType } from '../../TosExportEnum';\n\nexport interface PutObjectInput {\n  bucket?: string;\n  key: string;\n  /**\n   * body is empty buffer if it's falsy.\n   */\n  body?: SupportObjectBody;\n\n  contentLength?: number;\n  contentMD5?: string;\n  contentSHA256?: string;\n  cacheControl?: string;\n  contentDisposition?: string;\n  contentEncoding?: string;\n  contentLanguage?: string;\n  contentType?: string;\n  expires?: Date;\n\n  acl?: Acl;\n  grantFullControl?: string;\n  grantRead?: string;\n  grantReadAcp?: string;\n  grantWrite?: string;\n  grantWriteAcp?: string;\n\n  ssecAlgorithm?: string;\n  ssecKey?: string;\n  ssecKeyMD5?: string;\n  serverSideEncryption?: string;\n  /**\n   * @private unstable\n   */\n  serverSideDataEncryption?: string;\n\n  meta?: Record<string, string>;\n  websiteRedirectLocation?: string;\n  storageClass?: StorageClassType;\n  ifMatch?: string;\n\n  dataTransferStatusChange?: (status: DataTransferStatus) => void;\n\n  /**\n   * the simple progress feature\n   * percent is [0, 1].\n   *\n   * since putObject is stateless, so if `putObject` fail and you retry it,\n   * `percent` will start from 0 again rather than from the previous value.\n   * if you need `percent` start from the previous value, you can use `uploadFile` instead.\n   */\n  progress?: (percent: number) => void;\n  /**\n   * unit: bit/s\n   * server side traffic limit\n   **/\n  trafficLimit?: number;\n  /**\n   * only works for nodejs environment\n   **/\n  rateLimiter?: IRateLimiter;\n\n  forbidOverwrite?: boolean;\n\n  callback?: string;\n  callbackVar?: string;\n\n  headers?: {\n    [key: string]: string | undefined;\n    'content-length'?: string;\n    'content-type'?: string;\n    'content-md5'?: string;\n    'cache-control'?: string;\n    expires?: string;\n    'x-tos-acl'?: Acl;\n    'x-tos-grant-full-control'?: string;\n    'x-tos-grant-read'?: string;\n    'x-tos-grant-read-acp'?: string;\n    'x-tos-grant-write-acp'?: string;\n    'x-tos-server-side-encryption-customer-algorithm'?: string;\n    'x-tos-server-side-encryption-customer-key'?: string;\n    'x-tos-server-side-encryption-customer-key-md5'?: string;\n    'x-tos-website-redirect-location'?: string;\n    'x-tos-storage-class'?: string;\n    'x-tos-server-side-encryption'?: string;\n    'x-tos-forbid-overwrite'?: string;\n    'If-Match'?: string;\n  };\n}\n\ninterface PutObjectInputInner extends PutObjectInput {\n  makeRetryStream?: () => NodeJS.ReadableStream | undefined;\n}\n\nexport interface PutObjectOutput {\n  'x-tos-server-side-encryption-customer-algorithm'?: string;\n  'x-tos-server-side-encryption-customer-key-md5'?: string;\n  'x-tos-version-id'?: string;\n  'x-tos-hash-crc64ecma'?: string;\n  'x-tos-server-side-encryption'?: string;\n  CallbackResult?: string;\n}\n\nexport async function putObject(this: TOSBase, input: PutObjectInput | string) {\n  return _putObject.call(this, input);\n}\n\nexport async function _putObject(\n  this: TOSBase,\n  input: PutObjectInputInner | string\n): Promise<TosResponse<PutObjectOutput>> {\n  input = this.normalizeObjectInput(input);\n  const headers = (input.headers = normalizeHeadersKey(input.headers));\n  fillRequestHeaders(input, [\n    'contentLength',\n    'contentMD5',\n    'contentSHA256',\n    'cacheControl',\n    'contentDisposition',\n    'contentEncoding',\n    'contentLanguage',\n    'contentType',\n    'expires',\n    'acl',\n    'grantFullControl',\n    'grantRead',\n    'grantReadAcp',\n    'grantWrite',\n    'grantWriteAcp',\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n    'serverSideEncryption',\n    'serverSideDataEncryption',\n    'meta',\n    'websiteRedirectLocation',\n    'storageClass',\n    'trafficLimit',\n    'callback',\n    'callbackVar',\n    'forbidOverwrite',\n    'ifMatch',\n  ]);\n  this.setObjectContentTypeHeader(input, headers);\n\n  const totalSize = getSize(input.body, headers);\n  const totalSizeValid = totalSize != null;\n\n  if (!totalSizeValid && (input.dataTransferStatusChange || input.progress)) {\n    console.warn(\n      `Don't get totalSize of putObject's body, the \\`dataTransferStatusChange\\` and \\`progress\\` callback will not trigger. You can use \\`putObjectFromFile\\` instead`\n    );\n  }\n\n  let consumedBytes = 0;\n  const { dataTransferStatusChange, progress } = input;\n  const triggerDataTransfer = (\n    type: DataTransferType,\n    rwOnceBytes: number = 0\n  ) => {\n    // request cancel will make rwOnceBytes < 0 in browser\n    if (!totalSizeValid || rwOnceBytes < 0) {\n      return;\n    }\n    if (!dataTransferStatusChange && !progress) {\n      return;\n    }\n    consumedBytes += rwOnceBytes;\n\n    dataTransferStatusChange?.({\n      type,\n      rwOnceBytes,\n      consumedBytes,\n      totalBytes: totalSize,\n    });\n    const progressValue = (() => {\n      if (totalSize === 0) {\n        if (type === DataTransferType.Succeed) {\n          return 1;\n        }\n        return 0;\n      }\n      return consumedBytes / totalSize;\n    })();\n    if (progressValue === 1) {\n      if (type === DataTransferType.Succeed) {\n        progress?.(progressValue);\n      } else {\n        // not exec progress\n      }\n    } else {\n      progress?.(progressValue);\n    }\n  };\n\n  const bodyConfig = await getNewBodyConfig({\n    body: input.body,\n    dataTransferCallback: (n) => triggerDataTransfer(DataTransferType.Rw, n),\n    makeRetryStream: input.makeRetryStream,\n    enableCRC: this.opts.enableCRC,\n    rateLimiter: input.rateLimiter,\n  });\n\n  triggerDataTransfer(DataTransferType.Started);\n\n  const task = async () => {\n    const res = await this._fetchObject<PutObjectOutput>(\n      input,\n      'PUT',\n      {},\n      headers,\n      bodyConfig.body || '',\n      {\n        handleResponse: (res) => {\n          const result = { ...res.headers };\n          if ((input as PutObjectInputInner)?.callback && res.data) {\n            result.CallbackResult = `${JSON.stringify(res.data)}`;\n          }\n          return result;\n        },\n        axiosOpts: {\n          [retryNamespace]: {\n            beforeRetry: () => {\n              consumedBytes = 0;\n              bodyConfig.beforeRetry?.();\n            },\n            makeRetryStream: bodyConfig.makeRetryStream,\n          },\n          onUploadProgress: (event) => {\n            triggerDataTransfer(\n              DataTransferType.Rw,\n              event.loaded - consumedBytes\n            );\n          },\n        },\n      }\n    );\n    if (this.opts.enableCRC && bodyConfig.crc) {\n      checkCRC64WithHeaders(bodyConfig.crc, res.headers);\n    }\n    return res;\n  };\n  const [err, res] = await safeAwait(task());\n\n  if (err || !res) {\n    triggerDataTransfer(DataTransferType.Failed);\n    throw err;\n  }\n\n  triggerDataTransfer(DataTransferType.Succeed);\n  return res;\n}\n\ninterface PutObjectFromFileInput extends Omit<PutObjectInput, 'body'> {\n  filePath: string;\n}\n\nexport async function putObjectFromFile(\n  this: TOSBase,\n  input: PutObjectFromFileInput\n): Promise<TosResponse<PutObjectOutput>> {\n  const normalizedHeaders = normalizeHeadersKey(input.headers);\n  if (process.env.TARGET_ENVIRONMENT !== 'node') {\n    throw new TosClientError(\n      \"putObjectFromFile doesn't support in browser environment\"\n    );\n  }\n\n  if (!normalizedHeaders['content-length']) {\n    const stats: Stats = await fsp.stat(input.filePath);\n    normalizedHeaders['content-length'] = `${stats.size}`;\n  }\n\n  const makeRetryStream = makeRetryStreamAutoClose(() =>\n    fsp.createReadStream(input.filePath)\n  );\n\n  try {\n    return await _putObject.call(this, {\n      ...input,\n      body: makeRetryStream.make(),\n      headers: normalizedHeaders,\n      makeRetryStream: makeRetryStream.make,\n    });\n  } catch (err) {\n    tryDestroy(makeRetryStream.getLastStream(), err);\n    throw err;\n  }\n}\n\nexport default putObject;\n","import { StorageClassType } from '../../TosExportEnum';\nimport { Acl } from '../../interface';\nimport { fillRequestHeaders, normalizeHeadersKey } from '../../utils';\nimport TOSBase from '../base';\n\nexport interface FetchObjectInput {\n  bucket?: string;\n  key: string;\n  url: string;\n  ignoreSameKey?: boolean;\n\n  acl?: Acl;\n  grantFullControl?: string;\n  grantRead?: string;\n  grantReadAcp?: string;\n  grantWriteAcp?: string;\n  storageClass?: StorageClassType;\n\n  ssecAlgorithm?: string;\n  ssecKey?: string;\n  ssecKeyMD5?: string;\n  meta?: Record<string, string>;\n\n  // contentMD5 is the base64 encoded of object's md5\n  contentMD5?: string;\n\n  headers?: {\n    [key: string]: string | undefined;\n  };\n}\n\nexport interface FetchObjectOutput {\n  VersionID?: string;\n  Etag: string;\n  SSECAlgorithm?: string;\n  SSECKeyMD5?: string;\n}\n\nexport async function fetchObject(this: TOSBase, input: FetchObjectInput) {\n  const headers = (input.headers = normalizeHeadersKey(input.headers));\n  fillRequestHeaders(input, [\n    'acl',\n    'grantFullControl',\n    'grantRead',\n    'grantReadAcp',\n    'grantWriteAcp',\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n    'meta',\n    'storageClass',\n  ]);\n  const res = await this._fetchObject<FetchObjectOutput>(\n    input,\n    'POST',\n    {\n      fetch: '',\n    },\n    headers,\n    {\n      URL: input.url,\n      IgnoreSameKey: input.ignoreSameKey,\n      ContentMD5: input.contentMD5,\n    },\n    {\n      needMd5: true,\n    }\n  );\n  return res;\n}\n\nexport interface PutFetchTaskInput {\n  bucket?: string;\n  key: string;\n  url: string;\n  ignoreSameKey?: boolean;\n\n  acl?: Acl;\n  grantFullControl?: string;\n  grantRead?: string;\n  grantReadAcp?: string;\n  grantWriteAcp?: string;\n  storageClass?: StorageClassType;\n\n  ssecAlgorithm?: string;\n  ssecKey?: string;\n  ssecKeyMD5?: string;\n  meta?: Record<string, string>;\n\n  // contentMD5 is the base64 encoded of object's md5\n  contentMD5?: string;\n\n  headers?: {\n    [key: string]: string | undefined;\n  };\n}\n\nexport interface PutFetchTaskOutput {\n  TaskId: string;\n}\n\nexport async function putFetchTask(this: TOSBase, input: PutFetchTaskInput) {\n  const headers = (input.headers = normalizeHeadersKey(input.headers));\n  fillRequestHeaders(input, [\n    'acl',\n    'grantFullControl',\n    'grantRead',\n    'grantReadAcp',\n    'grantWriteAcp',\n    'ssecAlgorithm',\n    'ssecKey',\n    'ssecKeyMD5',\n    'meta',\n    'storageClass',\n  ]);\n\n  const res = await this._fetchObject<PutFetchTaskOutput>(\n    input,\n    'POST',\n    {\n      fetchTask: '',\n    },\n    headers,\n    {\n      URL: input.url,\n      IgnoreSameKey: input.ignoreSameKey,\n      ContentMD5: input.contentMD5,\n      Object: input.key,\n    },\n    {\n      needMd5: true,\n    }\n  );\n  return res;\n}\n","import TosClientError from '../../TosClientError';\nimport { covertCamelCase2Kebab, normalizeProxy } from '../../utils';\nimport TOSBase from '../base';\nimport { validateObjectName } from './utils';\n\nexport interface GetPreSignedUrlInput {\n  bucket?: string;\n  key: string;\n  /**\n   * default: 'GET'\n   */\n  method?: 'GET' | 'PUT';\n  /**\n   * unit: second, default: 1800\n   */\n  expires?: number;\n  alternativeEndpoint?: string;\n  response?: {\n    contentType?: string;\n    contentDisposition?: string;\n  };\n  versionId?: string;\n  query?: Record<string, string>;\n  /**\n   * default: false\n   * if set true. generate domain will direct use `endpoint` or `alternativeEndpoint`.\n   */\n  isCustomDomain?: boolean;\n}\n\nexport function getPreSignedUrl(\n  this: TOSBase,\n  input: GetPreSignedUrlInput | string\n) {\n  validateObjectName(input);\n  const normalizedInput = typeof input === 'string' ? { key: input } : input;\n  const endpoint = normalizedInput.alternativeEndpoint || this.opts.endpoint;\n  const subdomain =\n    normalizedInput.alternativeEndpoint || normalizedInput.isCustomDomain\n      ? false\n      : true;\n  const bucket = normalizedInput.bucket || this.opts.bucket || '';\n  if (subdomain && !bucket) {\n    throw new TosClientError('Must provide bucket param');\n  }\n\n  const [newHost, newPath, signingPath] = (() => {\n    const encodedKey = encodeURIComponent(normalizedInput.key);\n    const objectKeyPath = normalizedInput.key\n      .split('/')\n      .map((it) => encodeURIComponent(it))\n      .join('/');\n\n    if (subdomain) {\n      return [`${bucket}.${endpoint}`, `/${objectKeyPath}`, `/${encodedKey}`];\n    }\n    return [endpoint, `/${objectKeyPath}`, `/${encodedKey}`];\n  })();\n\n  const nextQuery: Record<string, any> = normalizedInput.query || {};\n  const setOneQuery = (k: string, v?: string) => {\n    if (nextQuery[k] == null && v != null) {\n      nextQuery[k] = v;\n    }\n  };\n  const response = normalizedInput.response || {};\n  Object.keys(response).forEach((_key) => {\n    const key = _key as keyof typeof response;\n    const kebabKey = covertCamelCase2Kebab(key);\n    setOneQuery(`response-${kebabKey}`, response[key]);\n  });\n  if (normalizedInput.versionId) {\n    setOneQuery('versionId', normalizedInput.versionId);\n  }\n\n  const query = this.getSignatureQuery({\n    bucket,\n    method: normalizedInput.method || 'GET',\n    path: signingPath,\n    endpoint,\n    subdomain,\n    expires: normalizedInput.expires || 1800,\n    query: nextQuery,\n  });\n\n  const normalizedProxy = normalizeProxy(this.opts.proxy);\n  let baseURL = `http${this.opts.secure ? 's' : ''}://${newHost}`;\n  if (normalizedProxy?.url) {\n    // if `baseURL` ends with '/'we filter it.\n    // because `newPath` starts with '/'\n    baseURL = normalizedProxy.url.replace(/\\/+$/g, '');\n    if (normalizedProxy?.needProxyParams) {\n      query['x-proxy-tos-host'] = newHost;\n    }\n  }\n\n  const queryStr = Object.keys(query)\n    .map((key) => {\n      return `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`;\n    })\n    .join('&');\n\n  return `${baseURL}${newPath}?${queryStr}`;\n}\n\nexport default getPreSignedUrl;\n","import TOSBase from '../base';\n\nexport interface DeleteObjectInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n  /**@private unstable */\n  skipTrash?: string;\n  /**@private unstable */\n  recursive?: string;\n}\n\nexport interface DeleteObjectOutput {\n  [key: string]: string | undefined;\n  ['x-tos-delete-marker']: string;\n  ['x-tos-version-id']: string;\n}\n\nexport async function deleteObject(\n  this: TOSBase,\n  input: DeleteObjectInput | string\n) {\n  const normalizedInput = typeof input === 'string' ? { key: input } : input;\n  const query: Record<string, any> = {};\n  if (normalizedInput.versionId) {\n    query.versionId = normalizedInput.versionId;\n  }\n  if (normalizedInput.skipTrash) {\n    query.skipTrash = normalizedInput.skipTrash;\n  }\n  if (normalizedInput.recursive) {\n    query.recursive = normalizedInput.recursive;\n  }\n  const res = await this._fetchObject<DeleteObjectOutput>(\n    input,\n    'DELETE',\n    query,\n    {},\n    {},\n    { handleResponse: (res) => res.headers }\n  );\n  return res;\n}\n\nexport default deleteObject;\n","import { fillRequestHeaders, normalizeHeadersKey } from '../../utils';\nimport TOSBase from '../base';\n\nexport interface RenameObjectInput {\n  bucket?: string;\n  key: string;\n  newKey: string;\n  recursiveMkdir?: boolean;\n  forbidOverwrite?: boolean;\n  headers?: {\n    [key: string]: string | undefined;\n  };\n}\n\nexport async function renameObject(this: TOSBase, input: RenameObjectInput) {\n  input.headers = input.headers || {};\n  fillRequestHeaders(input, ['recursiveMkdir', 'forbidOverwrite']);\n  return this._fetchObject<undefined>(\n    input,\n    'PUT',\n    { rename: '', name: input.newKey },\n    input.headers,\n    ''\n  );\n}\n\nexport default renameObject;\n","import { makeArrayProp } from '../../utils';\nimport TOSBase from '../base';\n\nexport interface DeleteMultiObjectsInput {\n  bucket?: string;\n  /**\n   * default: false\n   */\n  quiet?: boolean;\n  objects: {\n    key: string;\n    versionId?: string;\n  }[];\n  /**@private unstable */\n  skipTrash?: string;\n  /**@private unstable */\n  recursive?: string;\n}\n\nexport interface DeleteMultiObjectsOutput {\n  Deleted: {\n    Key: string;\n    VersionId: string;\n    DeleteMarker?: boolean;\n    DeleteMarkerVersionId?: string;\n  }[];\n\n  Error: {\n    Code: string;\n    Message: string;\n    Key: string;\n    VersionId: string;\n  }[];\n}\n\nexport async function deleteMultiObjects(\n  this: TOSBase,\n  input: DeleteMultiObjectsInput\n) {\n  const body = {\n    Quiet: input.quiet,\n    Objects: input.objects.map((it) => ({\n      Key: it.key,\n      VersionId: it.versionId,\n    })),\n  };\n\n  const query: Record<string, string> = {\n    delete: '',\n  };\n\n  if (input.skipTrash) {\n    query.skipTrash = input.skipTrash;\n  }\n\n  if (input.recursive) {\n    query.recursive = input.recursive;\n  }\n\n  const res = await this.fetchBucket<DeleteMultiObjectsOutput>(\n    input.bucket,\n    'POST',\n    query,\n    {},\n    body\n  );\n\n  const arrayProp = makeArrayProp(res.data);\n  arrayProp('Deleted');\n  arrayProp('Error');\n\n  return res;\n}\n\nexport default deleteMultiObjects;\n","import { Acl, AclInterface } from '../../../interface';\nimport { fillRequestHeaders, makeArrayProp, normalizeHeadersKey } from '../../../utils';\nimport TOSBase from '../../base';\n\nexport interface GetObjectAclInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n}\n\nexport type ObjectAclBody = AclInterface & {\n  BucketOwnerEntrusted?: boolean;\n  IsDefault?: boolean;\n};\n\nexport type GetObjectAclOutput = ObjectAclBody;\n\nexport async function getObjectAcl(\n  this: TOSBase,\n  input: GetObjectAclInput | string\n) {\n  const normalizedInput = typeof input === 'string' ? { key: input } : input;\n  const query: Record<string, any> = { acl: '' };\n  if (normalizedInput.versionId) {\n    query.versionId = normalizedInput.versionId;\n  }\n\n  const res = await this._fetchObject<GetObjectAclOutput>(input, 'GET', query, {});\n\n  const arrayProp = makeArrayProp(res.data);\n  arrayProp('Grants');\n\n  return res;\n}\n\nexport interface PutObjectAclInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n  acl?: Acl;\n  aclBody?: ObjectAclBody;\n  headers?: {\n    [key: string]: string | undefined;\n    'x-tos-acl'?: Acl;\n  };\n}\n\nexport async function putObjectAcl(this: TOSBase, input: PutObjectAclInput) {\n  const headers = (input.headers = normalizeHeadersKey(input.headers));\n  const query: Record<string, any> = { acl: '' };\n  if (input.versionId) {\n    query.versionId = input.versionId;\n  }\n  fillRequestHeaders(input, ['acl']);\n\n  return this._fetchObject<undefined>(\n    input,\n    'PUT',\n    query,\n    headers,\n    input.aclBody\n  );\n}\n","import TOSBase from '../../base';\n\nexport interface AbortMultipartUploadInput {\n  bucket?: string;\n  key: string;\n  uploadId: string;\n}\n\nexport async function abortMultipartUpload(\n  this: TOSBase,\n  input: AbortMultipartUploadInput\n) {\n  return this._fetchObject<undefined>(\n    input,\n    'DELETE',\n    {\n      uploadId: input.uploadId,\n    },\n    {}\n  );\n}\n","import { covertCamelCase2Kebab, makeArrayProp } from '../../../utils';\nimport TOSBase from '../../base';\n\nexport interface ListMultipartUploadsInput {\n  bucket?: string;\n  maxUploads?: number;\n  keyMarker?: string;\n  uploadIdMarker?: string;\n  delimiter?: string;\n  encodingType?: string;\n  prefix?: string;\n}\n\nexport interface ListMultipartUploadsOutput {\n  Uploads: {\n    Key: string;\n    UploadId: string;\n    StorageClass: string;\n    Initiated: string;\n  }[];\n  CommonPrefixes: string[];\n  Delimiter?: string;\n  EncodingType?: string;\n  KeyMarker?: string;\n  NextKeyMarker: string;\n  MaxUploads?: string;\n  UploadIdMarker?: string;\n  NextUploadIdMarker: string;\n  Prefix?: string;\n  IsTruncated: boolean;\n  Bucket: string;\n}\n\nexport async function listMultipartUploads(\n  this: TOSBase,\n  input: ListMultipartUploadsInput = {}\n) {\n  const { bucket, ...nextQuery } = input;\n  const ret = await this.fetchBucket<ListMultipartUploadsOutput>(\n    input.bucket,\n    'GET',\n    {\n      uploads: '',\n      ...covertCamelCase2Kebab(nextQuery),\n    },\n    {}\n  );\n\n  const arrayProp = makeArrayProp(ret.data);\n  arrayProp('Uploads');\n  arrayProp('CommonPrefixes');\n\n  return ret;\n}\n","import TOSBase from '../base';\nimport {\n  checkCRC64WithHeaders,\n  fillRequestHeaders,\n  normalizeHeadersKey,\n  safeAwait,\n} from '../../utils';\nimport { Acl, DataTransferStatus, DataTransferType } from '../../interface';\nimport { IRateLimiter } from '../../universal/rate-limiter';\nimport { getNewBodyConfig, getSize } from './utils';\nimport { StorageClassType } from '../../TosExportEnum';\nimport { retryNamespace } from '../../axios';\nimport TosClientError from '../../TosClientError';\nimport { combineCrc64 } from '../../universal/crc';\n\nexport interface AppendObjectInput {\n  bucket?: string;\n  key: string;\n  offset: number;\n  // body is empty buffer if it's falsy\n  body?: File | Blob | Buffer | NodeJS.ReadableStream;\n\n  // must provide preHashCrc64ecma if enableCRC is true and offset is non-zero\n  preHashCrc64ecma?: string;\n\n  /**\n   * unit: bit/s\n   * server side traffic limit\n   **/\n  trafficLimit?: number;\n  /**\n   * only works for nodejs environment\n   */\n  rateLimiter?: IRateLimiter;\n\n  contentLength?: number;\n  cacheControl?: string;\n  contentDisposition?: string;\n  contentEncoding?: string;\n  contentLanguage?: string;\n  contentType?: string;\n  expires?: Date;\n\n  acl?: Acl;\n  grantFullControl?: string;\n  grantRead?: string;\n  grantReadAcp?: string;\n  grantWriteAcp?: string;\n\n  meta?: Record<string, string>;\n  websiteRedirectLocation?: string;\n  storageClass?: StorageClassType;\n\n  dataTransferStatusChange?: (status: DataTransferStatus) => void;\n\n  /**\n   * the simple progress feature\n   * percent is [0, 1].\n   *\n   * since appendObject is stateless, so if `appendObject` fail and you retry it,\n   * `percent` will start from 0 again rather than from the previous value.\n   * if you need `percent` start from the previous value, you can use `uploadFile` instead.\n   */\n  progress?: (percent: number) => void;\n\n  headers?: {\n    [key: string]: string | undefined;\n    'Cache-Control'?: string;\n    'x-tos-acl'?: Acl;\n    'x-tos-grant-full-control'?: string;\n    'x-tos-grant-read'?: string;\n    'x-tos-grant-read-acp'?: string;\n    'x-tos-grant-write-acp'?: string;\n    'x-tos-website-redirect-location'?: string;\n    'x-tos-storage-class'?: string;\n  };\n}\n\nexport interface AppendObjectOutput {\n  nextAppendOffset: number;\n  hashCrc64ecma: string;\n  'x-tos-version-id'?: string;\n  'x-tos-hash-crc64ecma'?: string;\n  'x-tos-next-append-offset'?: string;\n}\n\nexport async function appendObject(\n  this: TOSBase,\n  input: AppendObjectInput | string\n) {\n  const normalizedInput = (input = this.normalizeObjectInput(input));\n  const headers = (input.headers = normalizeHeadersKey(input.headers));\n  fillRequestHeaders(input, [\n    'contentLength',\n    'cacheControl',\n    'contentDisposition',\n    'contentEncoding',\n    'contentLanguage',\n    'contentType',\n    'expires',\n    'acl',\n    'grantFullControl',\n    'grantRead',\n    'grantReadAcp',\n    'grantWriteAcp',\n    'meta',\n    'websiteRedirectLocation',\n    'storageClass',\n    'trafficLimit',\n  ]);\n  this.setObjectContentTypeHeader(input, headers);\n\n  const totalSize = getSize(input.body, headers);\n  const totalSizeValid = totalSize != null;\n  if (!totalSizeValid) {\n    throw new TosClientError(\n      `appendObject needs to know the content length in advance`\n    );\n  }\n  headers['content-length'] = headers['content-length'] || `${totalSize}`;\n\n  if (this.opts.enableCRC && input.offset !== 0 && !input.preHashCrc64ecma) {\n    throw new TosClientError(\n      'must provide preHashCrc64ecma if enableCRC is true and offset is non-zero'\n    );\n  }\n\n  let consumedBytes = 0;\n  const { dataTransferStatusChange, progress } = input;\n  const triggerDataTransfer = (\n    type: DataTransferType,\n    rwOnceBytes: number = 0\n  ) => {\n    // request cancel will make rwOnceBytes < 0 in browser\n    if (!totalSizeValid || rwOnceBytes < 0) {\n      return;\n    }\n    if (!dataTransferStatusChange && !progress) {\n      return;\n    }\n    consumedBytes += rwOnceBytes;\n\n    dataTransferStatusChange?.({\n      type,\n      rwOnceBytes,\n      consumedBytes,\n      totalBytes: totalSize,\n    });\n    const progressValue = (() => {\n      if (totalSize === 0) {\n        if (type === DataTransferType.Succeed) {\n          return 1;\n        }\n        return 0;\n      }\n      return consumedBytes / totalSize;\n    })();\n    if (progressValue === 1) {\n      if (type === DataTransferType.Succeed) {\n        progress?.(progressValue);\n      } else {\n        // not exec progress\n      }\n    } else {\n      progress?.(progressValue);\n    }\n  };\n\n  const bodyConfig = await getNewBodyConfig({\n    body: input.body,\n    dataTransferCallback: (n) => triggerDataTransfer(DataTransferType.Rw, n),\n    makeRetryStream: undefined,\n    enableCRC: this.opts.enableCRC,\n    rateLimiter: input.rateLimiter,\n  });\n\n  triggerDataTransfer(DataTransferType.Started);\n  const task = async () => {\n    const res = await this._fetchObject<AppendObjectOutput>(\n      input,\n      'POST',\n      { append: '', offset: normalizedInput.offset },\n      headers,\n      bodyConfig.body || '',\n      {\n        handleResponse: (res) => ({\n          ...res.headers,\n          nextAppendOffset: +res.headers['x-tos-next-append-offset'],\n          hashCrc64ecma: res.headers['x-tos-hash-crc64ecma'],\n        }),\n        axiosOpts: {\n          [retryNamespace]: {\n            beforeRetry: () => {\n              consumedBytes = 0;\n              bodyConfig.beforeRetry?.();\n            },\n            makeRetryStream: bodyConfig.makeRetryStream,\n          },\n          onUploadProgress: (event) => {\n            triggerDataTransfer(\n              DataTransferType.Rw,\n              event.loaded - consumedBytes\n            );\n          },\n        },\n      }\n    );\n    if (this.opts.enableCRC && bodyConfig.crc) {\n      const appendObjectCrc = combineCrc64(\n        normalizedInput.preHashCrc64ecma || '0',\n        bodyConfig.crc.getCrc64(),\n        totalSize\n      );\n      checkCRC64WithHeaders(appendObjectCrc, res.headers);\n    }\n    return res;\n  };\n  const [err, res] = await safeAwait(task());\n\n  if (err || !res) {\n    triggerDataTransfer(DataTransferType.Failed);\n    throw err;\n  }\n\n  triggerDataTransfer(DataTransferType.Succeed);\n  return res;\n}\n\nexport default appendObject;\n","import { fillRequestHeaders, normalizeHeadersKey } from '../../utils';\nimport TOSBase from '../base';\n\nexport interface SetObjectMetaInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n\n  // object meta data\n  cacheControl?: string;\n  contentDisposition?: string;\n  contentEncoding?: string;\n  contentLanguage?: string;\n  contentType?: string;\n  expires?: Date;\n  meta?: Record<string, string>;\n\n  headers?: {\n    [key: string]: string | undefined;\n    'Cache-Control'?: string;\n    'Content-Disposition'?: string;\n    Expires?: string;\n    'Content-Type'?: string;\n    'Content-Language'?: string;\n  };\n}\n\nexport async function setObjectMeta(\n  this: TOSBase,\n  input: SetObjectMetaInput | string\n) {\n  const normalizedInput = typeof input === 'string' ? { key: input } : input;\n  const headers = (normalizedInput.headers = normalizeHeadersKey(\n    normalizedInput.headers\n  ));\n  fillRequestHeaders(normalizedInput, [\n    'cacheControl',\n    'contentDisposition',\n    'contentEncoding',\n    'contentLanguage',\n    'contentType',\n    'expires',\n    'meta',\n  ]);\n  const query: Record<string, any> = { metadata: '' };\n  if (normalizedInput.versionId) {\n    query.versionId = normalizedInput.versionId;\n  }\n\n  return this._fetchObject<undefined>(input, 'POST', query, headers);\n}\n\nexport default setObjectMeta;\n","import TOSBase from '../base';\nimport { parse, stringify, hmacSha256 } from '../../universal/crypto';\nimport TosClientError from '../../TosClientError';\nimport { validateObjectName } from './utils';\n\nexport type PostSignatureCondition =\n  | {\n      [key: string]: string;\n    }\n  | ['eq', string, string]\n  | ['starts-with', string, string]\n  | ['content-length-range', number, number];\n\nexport interface CalculatePostSignatureInput {\n  bucket?: string;\n  key: string;\n  // unit: seconds, default: 3600(1 hour)\n  expiresIn?: number;\n  fields?: Record<string, unknown>;\n  conditions?: PostSignatureCondition[];\n}\n\nexport async function calculatePostSignature(\n  this: TOSBase,\n  input: CalculatePostSignatureInput | string\n) {\n  validateObjectName(input);\n  input = this.normalizeObjectInput(input);\n  const { expiresIn = 3600, key } = input;\n  const bucket = input.bucket || this.opts.bucket;\n  const fields = { ...input.fields };\n  const conditions = [...(input.conditions || [])];\n\n  if (!bucket) {\n    throw new TosClientError('Must provide bucket param');\n  }\n\n  const accessKeySecret = this.opts.accessKeySecret;\n  const date = new Date();\n  const expirationDateStr = getDateTimeStr({\n    date: new Date(date.valueOf() + expiresIn * 1000),\n    type: 'ISO',\n  });\n  const dateStr = getDateTimeStr();\n  const date8Str = dateStr.substring(0, 8);\n  const service = 'tos';\n  const requestStr = 'request';\n\n  const kDate = hmacSha256(accessKeySecret, date8Str);\n  const kRegion = hmacSha256(kDate, this.opts.region);\n  const kService = hmacSha256(kRegion, service);\n  const signingKey = hmacSha256(kService, requestStr);\n\n  const credential = [\n    this.opts.accessKeyId,\n    date8Str,\n    this.opts.region,\n    service,\n    requestStr,\n  ].join('/');\n\n  const addedInForm: Record<string, string> = {\n    key,\n    'x-tos-algorithm': 'TOS4-HMAC-SHA256',\n    'x-tos-date': dateStr,\n    'x-tos-credential': credential,\n  };\n  if (this.opts.stsToken) {\n    addedInForm['x-tos-security-token'] = this.opts.stsToken;\n  }\n\n  conditions.push({ bucket });\n  Object.entries(addedInForm).forEach(([key, value]) => {\n    fields[key] = value;\n  });\n  Object.entries(fields).forEach(([key, value]) => {\n    conditions.push({ [key]: `${value}` });\n  });\n\n  const policy = {\n    expiration: expirationDateStr,\n    conditions,\n  };\n  const policyStr = JSON.stringify(policy);\n  const policyBase64 = stringify(parse(policyStr, 'utf-8'), 'base64');\n  const signature = hmacSha256(signingKey, policyBase64, 'hex');\n\n  fields.policy = policyBase64;\n  fields['x-tos-signature'] = signature;\n\n  return fields;\n}\n\n/**\n *\n * Z for 20130728T000000Z\n * ISO for 2007-12-01T12:00:00.000Z\n * @param opt\n * @returns\n */\nfunction getDateTimeStr(opt?: { date?: Date; type?: 'Z' | 'ISO' }) {\n  const { date = new Date(), type = 'Z' } = opt || {};\n  if (type === 'ISO') {\n    return date.toISOString();\n  }\n\n  const dateTime =\n    date.toISOString().replace(/\\..+/, '').replace(/-/g, '').replace(/:/g, '') +\n    'Z';\n\n  return dateTime;\n}\n\nexport default calculatePostSignature;\n","import TosServerError from './TosServerError';\nimport { getNormalDataFromError } from './utils';\n\nconst defaultEmptyMethodMap: Record<string, boolean> = {\n  getBucketCustomDomain: true,\n  getBucketIntelligenttiering: true,\n  getBucketInventory: true,\n  listBucketInventory: true,\n  getBucketMirrorBack: true,\n  getBucketNotification: true,\n  getBucketPolicy: true,\n  getBucketRealTimeLog: true,\n  getBucketReplication: true,\n  getBucketTagging: true,\n  getBucketWebsite: true,\n};\n\nexport function handleEmptyServerError<T>(\n  err: Error | TosServerError | unknown,\n  opts: {\n    defaultResponse: T;\n    enableCatchEmptyServerError?: boolean;\n    methodKey: string;\n  }\n) {\n  const { enableCatchEmptyServerError, methodKey, defaultResponse } = opts;\n  if (err instanceof TosServerError) {\n    if (enableCatchEmptyServerError) {\n      if (err.statusCode === 404) {\n        return getNormalDataFromError(defaultResponse, err);\n      }\n    }\n    // 404catchenableCatchEmptyServerErrorbreak change\n    else if (enableCatchEmptyServerError === undefined) {\n      if (err.statusCode === 404 && defaultEmptyMethodMap[methodKey]) {\n        return getNormalDataFromError(defaultResponse, err);\n      }\n    }\n  }\n  throw err;\n}\n","import { makeArrayProp } from '../../utils';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase, { TosResponse } from '../base';\n\nexport interface BucketPolicyStatement {\n  Sid: string;\n  Effect: 'Allow' | 'Deny';\n  Action?: string | string[];\n  NotAction?: string | string[];\n  Condition?: {\n    [key in string]: {\n      [key in string]: string[];\n    };\n  };\n  Principal?: string[];\n  NotPrincipal?: string[];\n  Resource?: string | string[];\n  NotResource?: string | string[];\n}\n\nexport interface GetBucketPolicyOutput {\n  Statement: BucketPolicyStatement[];\n  Version: string;\n}\n\ninterface PutBucketPolicyInputPolicy\n  extends Omit<GetBucketPolicyOutput, 'Version'> {\n  Version?: string;\n}\n\nexport interface PutBucketPolicyInput {\n  bucket?: string;\n  policy: PutBucketPolicyInputPolicy;\n}\n\nexport async function putBucketPolicy(\n  this: TOSBase,\n  input: PutBucketPolicyInput\n) {\n  if (\n    (this.opts.enableOptimizeMethodBehavior ||\n      this.opts.enableOptimizeMethodBehavior === undefined) &&\n    !input.policy.Statement.length\n  ) {\n    return deleteBucketPolicy.call(this, input.bucket);\n  }\n\n  const res = await this.fetchBucket(\n    input.bucket,\n    'PUT',\n    { policy: '' },\n    {},\n    input.policy,\n    { needMd5: true }\n  );\n  return res;\n}\n\nexport async function getBucketPolicy(\n  this: TOSBase,\n  bucket?: string\n): Promise<TosResponse<GetBucketPolicyOutput>> {\n  try {\n    const res = await this.fetchBucket<GetBucketPolicyOutput>(\n      bucket,\n      'GET',\n      {\n        policy: '',\n      },\n      {}\n    );\n    res.data.Statement.forEach((it: any) => {\n      const arrayProp = makeArrayProp(it);\n\n      Object.keys(it.Condition || {}).forEach((key) => {\n        Object.keys(it.Condition[key]).forEach((key2) => {\n          arrayProp(`Condition[\"${key}\"][\"${key2}\"]`);\n        });\n      });\n    });\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetBucketPolicyOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketPolicy',\n      defaultResponse: {\n        Statement: [],\n        Version: '2012-10-17',\n      },\n    });\n  }\n}\n\nexport async function deleteBucketPolicy(this: TOSBase, bucket?: string) {\n  return this.fetchBucket(bucket, 'DELETE', { policy: '' }, {});\n}\n","import { VersioningStatusType } from '../../TosExportEnum';\nimport TOSBase from '../base';\n\n// for backward compatibility\nexport { VersioningStatusType as BucketVersioningStatus };\n\nexport type PutBucketVersioningInputStatus =\n  | VersioningStatusType.Enable\n  | VersioningStatusType.Enabled\n  | VersioningStatusType.Suspended;\n\nexport interface GetBucketVersioningOutput {\n  Status: VersioningStatusType;\n}\n\nexport interface PutBucketVersioningInput {\n  bucket?: string;\n  status: PutBucketVersioningInputStatus;\n}\n\nexport async function getBucketVersioning(this: TOSBase, bucket?: string) {\n  return this.fetchBucket<GetBucketVersioningOutput>(\n    bucket,\n    'GET',\n    { versioning: '' },\n    {}\n  );\n}\n\nexport async function putBucketVersioning(\n  this: TOSBase,\n  input: PutBucketVersioningInput\n) {\n  return this.fetchBucket(\n    input.bucket,\n    'PUT',\n    { versioning: '' },\n    {},\n    {\n      Status: input.status,\n    }\n  );\n}\n","import TosClientError from '../../TosClientError';\nimport { obj2QueryStr } from '../../utils';\nimport TOSBase from '../base';\n\nexport interface PreSignedPolicyURLInput {\n  bucket?: string;\n  /**\n   * unit: s\n   * default value: 3600\n   * range is: [1, 604800]\n   */\n  expires?: number;\n\n  conditions: PolicySignatureCondition[];\n\n  alternativeEndpoint?: string;\n  /**\n   * default: false\n   * if set true. generate domain will direct use `endpoint` or `alternativeEndpoint`.\n   */\n  isCustomDomain?: boolean;\n}\n\nexport interface PreSignedPolicyURLOutput {\n  getSignedURLForList(additionalQuery?: Record<string, string>): string;\n\n  // since conditions maybe includes multi exact key, so key isn't predictable\n  getSignedURLForGetOrHead(\n    key: string,\n    additionalQuery?: Record<string, string>\n  ): string;\n\n  signedQuery: string;\n}\n\nexport interface PolicySignatureCondition {\n  key: 'key';\n  value: string;\n  operator?: 'eq' | 'starts-with';\n}\n\ninterface NormalizedInput {\n  bucket: string;\n  /**\n   * unit: s\n   * default value: 3600\n   * range is: [1, 604800]\n   */\n  expires: number;\n\n  conditions: NormalizedPolicySignatureCondition[];\n\n  alternativeEndpoint?: string;\n}\n\ntype NormalizedPolicySignatureCondition = [\n  'eq' | 'starts-with',\n  '$key' | '$bucket',\n  string\n];\n\nexport function preSignedPolicyURL(\n  this: TOSBase,\n  input: PreSignedPolicyURLInput\n): PreSignedPolicyURLOutput {\n  const normalizedInput = normalizeInput.call(this, input);\n\n  validateConditions(input.conditions);\n\n  const endpoint =\n    input.alternativeEndpoint ||\n    (input.isCustomDomain\n      ? this.opts.endpoint\n      : `${normalizedInput.bucket}.${this.opts.endpoint}`);\n\n  const baseURL = `http${this.opts.secure ? 's' : ''}://${endpoint}`;\n\n  const query = this.getSignatureQuery({\n    bucket: normalizedInput.bucket,\n    expires: normalizedInput.expires,\n    policy: {\n      conditions: normalizedInput.conditions,\n    },\n  });\n\n  const queryStr = obj2QueryStr(query);\n\n  const getSignedURLForList: PreSignedPolicyURLOutput['getSignedURLForList'] = (\n    additionalQuery\n  ) => {\n    const str2 = obj2QueryStr(additionalQuery);\n    const q = [queryStr, str2].filter(Boolean).join('&');\n    return `${baseURL}?${q}`;\n  };\n  const getSignedURLForGetOrHead: PreSignedPolicyURLOutput['getSignedURLForGetOrHead'] =\n    (key, additionalQuery) => {\n      const str2 = obj2QueryStr(additionalQuery);\n      const q = [queryStr, str2].filter(Boolean).join('&');\n      // keep   '/'\n      const keyPath = key\n        .split('/')\n        .map((it) => encodeURIComponent(it))\n        .join('/');\n      return `${baseURL}/${keyPath}?${q}`;\n    };\n  return {\n    getSignedURLForList,\n    getSignedURLForGetOrHead,\n    signedQuery: queryStr,\n  };\n}\n\nfunction normalizeInput(\n  this: TOSBase,\n  input: PreSignedPolicyURLInput\n): NormalizedInput {\n  const actualBucket = input.bucket || this.opts.bucket;\n  const defaultExpires = 3600;\n\n  if (!actualBucket) {\n    throw new TosClientError('Must provide bucket param');\n  }\n\n  validateConditions(input.conditions);\n  const normalizedConditions: NormalizedPolicySignatureCondition[] =\n    input.conditions.map((it) => [it.operator || 'eq', '$key', it.value]);\n  normalizedConditions.push(['eq', '$bucket', actualBucket]);\n\n  return {\n    bucket: actualBucket,\n    expires: input.expires || defaultExpires,\n    conditions: normalizedConditions,\n  };\n}\n\nfunction validateConditions(conditions: PolicySignatureCondition[]) {\n  if (conditions.length < 1) {\n    throw new TosClientError(\n      'The `conditions` field of `PreSignedPolicyURLInput` must has one item at least'\n    );\n  }\n\n  for (const it of conditions) {\n    if (it.key !== 'key') {\n      throw new TosClientError(\n        \"The `key` field of `PolicySignatureCondition` must be `'key'`\"\n      );\n    }\n\n    if (it.operator && it.operator !== 'eq' && it.operator !== 'starts-with') {\n      throw new TosClientError(\n        \"The `operator` field of `PolicySignatureCondition` must be `'eq'` or `'starts-with'`\"\n      );\n    }\n  }\n}\n","import TOSBase from '../base';\n\nexport interface GetBucketLocationInput {\n  bucket: string;\n}\n\nexport interface GetBucketLocationOutput {\n  ExtranetEndpoint: string;\n  IntranetEndpoint: string;\n  Region: string;\n}\n\nexport async function getBucketLocation(\n  this: TOSBase,\n  input: GetBucketLocationInput\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket<GetBucketLocationOutput>(\n    bucket,\n    'GET',\n    { location: '' },\n    {}\n  );\n}\n","import { HttpMethodType } from '../../TosExportEnum';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase from '../base';\n\nexport interface CORSRule {\n  AllowedOrigins: string[];\n  AllowedMethods: HttpMethodType[];\n  AllowedHeaders: string[];\n  ExposeHeaders: string[];\n  MaxAgeSeconds: number;\n  ResponseVary?: boolean;\n}\n\nexport interface GetBucketCORSInput {\n  bucket: string;\n}\n\nexport interface GetBucketCORSOutput {\n  CORSRules: CORSRule[];\n}\n\nexport async function getBucketCORS(this: TOSBase, input: GetBucketCORSInput) {\n  try {\n    const { bucket } = input;\n\n    return await this.fetchBucket<GetBucketCORSOutput>(\n      bucket,\n      'GET',\n      { cors: '' },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketCORSOutput>(error, {\n      defaultResponse: { CORSRules: [] },\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketCORS',\n    });\n  }\n}\n\nexport interface PutBucketCORSInput {\n  bucket: string;\n  CORSRules: CORSRule[];\n}\n\nexport interface PutBucketCORSOutput {}\n\nexport async function putBucketCORS(this: TOSBase, input: PutBucketCORSInput) {\n  const { bucket, CORSRules } = input;\n  if (this.opts.enableOptimizeMethodBehavior && !CORSRules.length) {\n    return deleteBucketCORS.call(this, { bucket });\n  }\n  return this.fetchBucket<PutBucketCORSOutput>(\n    bucket,\n    'PUT',\n    { cors: '' },\n    {},\n    { CORSRules }\n  );\n}\n\nexport interface DeleteBucketCORSInput {\n  bucket: string;\n}\n\nexport interface DeleteBucketCORSOutput {}\n\nexport async function deleteBucketCORS(\n  this: TOSBase,\n  input: DeleteBucketCORSInput\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket<DeleteBucketCORSOutput>(\n    bucket,\n    'DELETE',\n    { cors: '' },\n    {}\n  );\n}\n","import { StorageClassType } from '../../TosExportEnum';\nimport TOSBase from '../base';\nimport { fillRequestHeaders, normalizeHeadersKey } from '../../utils';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\ninterface LifecycleRule {\n  ID?: string;\n  Prefix?: string;\n  Status: 'Enabled' | 'Disabled';\n  Filter?: {\n    GreaterThanIncludeEqual?: 'Enabled' | 'Disabled';\n    LessThanIncludeEqual?: 'Enabled' | 'Disabled';\n    /** unit bit */\n    ObjectSizeGreaterThan?: number;\n    /** unit bit */\n    ObjectSizeLessThan?: number;\n  };\n  Expiration?: { Date?: string; Days?: number };\n  Days?: number;\n  Date?: string;\n  NoncurrentVersionExpiration?: {\n    NoncurrentDays?: number;\n    NoncurrentDate?: string;\n  };\n  AbortIncompleteMultipartUpload?: { DaysAfterInitiation?: number };\n  DaysAfterInitiation?: number;\n  Transitions?: {\n    StorageClass: StorageClassType;\n    Days?: number;\n    Date?: string;\n  }[];\n  /**\n   * @private unstable\n   */\n  AccessTimeTransitions?: {\n    StorageClass: StorageClassType;\n    Days?: number;\n  }[];\n  /**\n   * @private unstable\n   */\n  AccessTimeExpiration?: {\n    Days: number;\n  };\n  /**\n   * @private unstable\n   */\n  NoncurrentVersionAccessTimeTransitions?: {\n    StorageClass: StorageClassType;\n    NoncurrentDays?: number;\n  }[];\n  /**\n   * @private unstable\n   */\n  NoncurrentVersionAccessTimeExpiration?: {\n    NoncurrentDays: number;\n  };\n  NoncurrentVersionTransitions?: {\n    StorageClass?: StorageClassType;\n    NoncurrentDays?: number;\n    NoncurrentDate?: string;\n  }[];\n  Tags?: {\n    Key?: string;\n    Value?: string;\n  }[];\n}\n\nexport interface PutBucketLifecycleInput {\n  bucket: string;\n  rules: LifecycleRule[];\n  allowSameActionOverlap?: boolean;\n}\n\nexport interface PutBucketLifecycleOutput {}\n\nexport async function putBucketLifecycle(\n  this: TOSBase,\n  input: PutBucketLifecycleInput\n) {\n  const { bucket, rules } = input;\n  if (this.opts.enableOptimizeMethodBehavior && !rules.length) {\n    return deleteBucketLifecycle.call(this, { bucket });\n  }\n\n  const headers = {};\n  fillRequestHeaders({ ...input, headers }, ['allowSameActionOverlap']);\n\n  return this.fetchBucket<PutBucketLifecycleOutput>(\n    bucket,\n    'PUT',\n    { lifecycle: '' },\n    headers,\n    {\n      Rules: rules,\n    }\n  );\n}\n\nexport interface GetBucketLifecycleInput {\n  bucket: string;\n}\n\nexport interface GetBucketLifecycleOutput {\n  Rules: LifecycleRule[];\n  AllowSameActionOverlap?: boolean;\n}\n\nexport async function getBucketLifecycle(\n  this: TOSBase,\n  input: GetBucketLifecycleInput\n) {\n  try {\n    const { bucket } = input;\n\n    return await this.fetchBucket<GetBucketLifecycleOutput>(\n      bucket,\n      'GET',\n      { lifecycle: '' },\n      {},\n      {},\n      {\n        handleResponse: (res) => {\n          return {\n            AllowSameActionOverlap:\n              res.headers['x-tos-allow-same-action-overlap'],\n            Rules: res.data.Rules,\n          };\n        },\n      }\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketLifecycleOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketLifecycle',\n      defaultResponse: {\n        Rules: [],\n      },\n    });\n  }\n}\n\nexport interface DeleteBucketLifecycleInput {\n  bucket: string;\n}\n\nexport interface DeleteBucketLifecycleOutput {}\n\nexport async function deleteBucketLifecycle(\n  this: TOSBase,\n  input: DeleteBucketLifecycleInput\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket<DeleteBucketLifecycleOutput>(\n    bucket,\n    'DELETE',\n    { lifecycle: '' },\n    {}\n  );\n}\n","import TOSBase from '../base';\nimport { hashMd5 } from '../../universal/crypto.browser';\n\nexport interface EncryptionData {\n  Rule: EncryptionDataRule;\n}\nexport interface EncryptionDataRule {\n  ApplyServerSideEncryptionByDefault: {\n    // SSEAlgorithm support 'kms' and 'AES256' and 'sm4'\n    SSEAlgorithm: string;\n    KMSMasterKeyID?: string;\n    /** @private unstable */\n    KMSDataEncryption?: string;\n  };\n}\n\nexport async function putBucketEncryption(\n  this: TOSBase,\n  input: { rule: EncryptionDataRule } & { bucket?: string }\n) {\n  const { bucket, rule } = input;\n\n  return this.fetchBucket(\n    bucket,\n    'PUT',\n    { encryption: '' },\n    {\n      'Content-MD5': hashMd5(\n        JSON.stringify({\n          Rule: rule,\n        }),\n        'base64'\n      ),\n    },\n    {\n      Rule: rule,\n    }\n  );\n}\n\nexport async function getBucketEncryption(\n  this: TOSBase,\n  input: { bucket?: string }\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket<EncryptionData>(\n    bucket,\n    'GET',\n    { encryption: '' },\n    {}\n  );\n}\n\nexport async function deleteBucketEncryption(\n  this: TOSBase,\n  input: { bucket?: string }\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket(bucket, 'DELETE', { encryption: '' }, {});\n}\n","import { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'mirror';\n\nexport interface MirrorBackRule {\n  ID: string;\n  Condition: {\n    HttpCode: number;\n    KeyPrefix?: string;\n    KeySuffix?: string;\n    /** private unstable */\n    AllowHost?: string[];\n    /** private unstable */\n    HttpMethod?: string[];\n  };\n  Redirect: {\n    RedirectType?: 'Mirror' | 'Async';\n    FetchSourceOnRedirect?: boolean;\n    /** @private unstable */\n    FetchSourceOnRedirectWithQuery?: boolean;\n    PublicSource?: {\n      SourceEndpoint: {\n        Primary: string[];\n        Follower?: string[];\n      };\n      FixedEndpoint?: boolean;\n    };\n    /** @private unstable */\n    PrivateSource?: {\n      SourceEndpoint: {\n        Primary: {\n          Endpoint: string;\n          BucketName: string;\n          CredentialProvider: { Role: string };\n        }[];\n      };\n    };\n    PassQuery?: boolean;\n    FollowRedirect?: boolean;\n    MirrorHeader?: {\n      PassAll?: boolean;\n      Pass?: string[];\n      Remove?: string[];\n      /** private unstable */\n      Set?: { Key: string; Value: string }[];\n    };\n    /** @private unstable */\n    PassHeaderFromSource?: string[];\n    /** @private unstable */\n    PassStatusCodeFromSource?: string[];\n\n    /** @private unstable */\n    DisableUploadSourceForNoneRangeMirror?: boolean;\n    /** @private unstable */\n    DisableUploadSourceForRangeMirror?: boolean;\n\n    Transform?: {\n      WithKeyPrefix?: string;\n      WithKeySuffix?: string;\n      ReplaceKeyPrefix?: {\n        KeyPrefix?: string;\n        ReplaceWith?: string;\n      };\n    };\n  };\n}\n\nexport interface PutBucketMirrorBackInput {\n  bucket: string;\n  rules: MirrorBackRule[];\n}\n\nexport interface PutBucketMirrorBackOutput {}\n\nexport async function putBucketMirrorBack(\n  this: TOSBase,\n  input: PutBucketMirrorBackInput\n) {\n  const { bucket, rules } = input;\n  if (this.opts.enableOptimizeMethodBehavior && !rules.length) {\n    return deleteBucketMirrorBack.call(this, { bucket });\n  }\n\n  return this.fetchBucket<PutBucketMirrorBackOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      Rules: rules,\n    }\n  );\n}\n\nexport interface GetBucketMirrorBackInput {\n  bucket: string;\n}\n\nexport interface GetBucketMirrorBackOutput {\n  Rules: MirrorBackRule[];\n}\n\nexport async function getBucketMirrorBack(\n  this: TOSBase,\n  input: GetBucketMirrorBackInput\n) {\n  const { bucket } = input;\n\n  try {\n    return await this.fetchBucket<GetBucketMirrorBackOutput>(\n      bucket,\n      'GET',\n      { [CommonQueryKey]: '' },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketMirrorBackOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketMirrorBack',\n      defaultResponse: {\n        Rules: [],\n      },\n    });\n  }\n}\n\nexport interface DeleteBucketMirrorBackInput {\n  bucket: string;\n}\n\nexport interface DeleteBucketMirrorBackOutput {}\n\nexport async function deleteBucketMirrorBack(\n  this: TOSBase,\n  input: DeleteBucketMirrorBackInput\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket<DeleteBucketMirrorBackOutput>(\n    bucket,\n    'DELETE',\n    { [CommonQueryKey]: '' },\n    {}\n  );\n}\n","import { makeArrayProp, normalizeHeadersKey } from '../../utils';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'tagging';\n\ninterface TagSet {\n  Tags: {\n    Key: string;\n    Value: string;\n  }[];\n}\n\nexport interface PutObjectTaggingInput {\n  bucket: string;\n  key: string;\n  versionId?: string;\n  tagSet: TagSet;\n}\n\nexport interface PutObjectTaggingOutput {}\n\nexport async function putObjectTagging(\n  this: TOSBase,\n  input: PutObjectTaggingInput\n) {\n  const { tagSet, versionId } = input;\n  const headers = normalizeHeadersKey({\n    versionId,\n  });\n\n  return this._fetchObject<PutObjectTaggingOutput>(\n    input,\n    'PUT',\n    { [CommonQueryKey]: '', ...headers },\n    {},\n    {\n      TagSet: tagSet,\n    }\n  );\n}\n\nexport interface GetObjectTaggingInput {\n  bucket: string;\n  key: string;\n  versionId?: string;\n}\n\nexport interface GetObjectTaggingOutput {\n  TagSet: TagSet;\n}\n\nexport async function getObjectTagging(\n  this: TOSBase,\n  input: GetObjectTaggingInput\n) {\n  const { versionId } = input;\n  const headers = normalizeHeadersKey({\n    versionId,\n  });\n  const res = await this._fetchObject<GetObjectTaggingOutput>(\n    input,\n\n    'GET',\n    { [CommonQueryKey]: '', ...headers },\n    {}\n  );\n  makeArrayProp(res.data.TagSet)('Tags');\n  return res;\n}\n\nexport interface DeleteObjectTaggingInput {\n  bucket: string;\n  key: string;\n  versionId?: string;\n}\n\nexport interface DeleteObjectTaggingOutput {}\n\nexport async function deleteObjectTagging(\n  this: TOSBase,\n  input: DeleteObjectTaggingInput\n) {\n  const { versionId } = input;\n  const headers = normalizeHeadersKey({\n    versionId,\n  });\n\n  return this._fetchObject<DeleteObjectTaggingOutput>(\n    input,\n    'DELETE',\n    { [CommonQueryKey]: '', ...headers },\n    {}\n  );\n}\n","import {\n  ACLType,\n  StorageClassInheritDirectiveType,\n  StorageClassType,\n} from '../../TosExportEnum';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'replication';\n\nexport interface ReplicationTag {\n  Key: string;\n  Value: string;\n}\n\nexport interface ReplicationRule {\n  ID: string;\n  Status: string;\n  PrefixSet?: string[];\n  Destination: {\n    Bucket: string;\n    Location: string;\n    StorageClass?: StorageClassType;\n    StorageClassInheritDirective: StorageClassInheritDirectiveType;\n  };\n  /**\n   *  @private unstable: internal(default) |tos_acc\n   */\n  TransferType?: string;\n  HistoricalObjectReplication: 'Enabled' | 'Disabled';\n  /** @private unstable */\n  Tags?: ReplicationTag[];\n  AccessControlTranslation?: {\n    Owner: string; //\"BucketOwnerEntrusted\"\n  };\n}\n\nexport interface PutBucketReplicationInput {\n  bucket: string;\n  role: string;\n  rules: ReplicationRule[];\n}\n\nexport interface PutBucketReplicationOutput {}\n\nexport async function putBucketReplication(\n  this: TOSBase,\n  input: PutBucketReplicationInput\n) {\n  const { bucket, rules, role } = input;\n  if (this.opts.enableOptimizeMethodBehavior && !rules.length) {\n    return deleteBucketReplication.call(this, { bucket });\n  }\n\n  return this.fetchBucket<PutBucketReplicationOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      Role: role,\n      Rules: rules,\n    }\n  );\n}\n\nexport interface GetBucketReplicationInput {\n  bucket: string;\n  progress?: string;\n  ruleId?: string;\n}\n\nexport interface GetBucketReplicationOutput {\n  Role: string;\n  Rules: ReplicationRule[];\n}\n\nexport async function getBucketReplication(\n  this: TOSBase,\n  input: GetBucketReplicationInput\n) {\n  const { bucket, progress, ruleId } = input;\n  const query: Record<string, string> = {\n    [CommonQueryKey]: '',\n    progress: progress || '',\n  };\n  if (ruleId != null) {\n    query['rule-id'] = `${ruleId}`;\n  }\n\n  try {\n    return await this.fetchBucket<GetBucketReplicationOutput>(\n      bucket,\n      'GET',\n      query,\n      {}\n    );\n  } catch (err) {\n    return handleEmptyServerError<GetBucketReplicationOutput>(err, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketReplication',\n      defaultResponse: {\n        Rules: [],\n        Role: '',\n      },\n    });\n  }\n}\n\nexport interface DeleteBucketReplicationInput {\n  bucket: string;\n}\n\nexport interface DeleteBucketReplicationOutput {}\n\nexport async function deleteBucketReplication(\n  this: TOSBase,\n  input: DeleteBucketReplicationInput\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket<DeleteBucketReplicationOutput>(\n    bucket,\n    'DELETE',\n    { [CommonQueryKey]: '' },\n    {}\n  );\n}\n","import { convertNormalCamelCase2Upper } from '../../utils';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'website';\n\ntype Protocol = 'http' | 'https';\n\ninterface RedirectAllRequestsTo {\n  HostName: string;\n  Protocol?: Protocol;\n}\n\ninterface IndexDocument {\n  Suffix: string;\n  ForbiddenSubDir?: boolean;\n}\ninterface ErrorDocument {\n  Key?: string;\n}\ninterface RoutingRule {\n  Condition: {\n    HttpErrorCodeReturnedEquals?: number;\n    KeyPrefixEquals?: string;\n  };\n  Redirect: {\n    HostName?: string;\n    HttpRedirectCode?: number;\n    Protocol?: Protocol;\n    ReplaceKeyPrefixWith?: string;\n    ReplaceKeyWith?: string;\n  };\n}\n\nexport interface PutBucketWebsiteInput {\n  bucket: string;\n  redirectAllRequestsTo?: RedirectAllRequestsTo;\n  indexDocument?: IndexDocument;\n  errorDocument?: ErrorDocument;\n  routingRules?: RoutingRule[];\n}\n\nexport interface PutBucketWebsiteOutput {}\n\nexport async function putBucketWebsite(\n  this: TOSBase,\n  input: PutBucketWebsiteInput\n) {\n  const { bucket, ...otherProps } = input;\n\n  const body = convertNormalCamelCase2Upper(otherProps);\n  return this.fetchBucket<PutBucketWebsiteOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      ...body,\n    }\n  );\n}\n\nexport interface GetBucketWebsiteInput {\n  bucket: string;\n}\n\nexport interface GetBucketWebsiteOutput {\n  RedirectAllRequestsTo?: RedirectAllRequestsTo;\n  IndexDocument?: IndexDocument;\n  ErrorDocument?: ErrorDocument;\n  RoutingRules?: RoutingRule[];\n}\n\nexport async function getBucketWebsite(\n  this: TOSBase,\n  input: GetBucketWebsiteInput\n) {\n  const { bucket } = input;\n\n  try {\n    return this.fetchBucket<GetBucketWebsiteOutput>(\n      bucket,\n      'GET',\n      { [CommonQueryKey]: '' },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketWebsiteOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketWebsite',\n      defaultResponse: {\n        RoutingRules: [],\n      },\n    });\n  }\n}\n\nexport interface DeleteBucketWebsiteInput {\n  bucket: string;\n}\n\nexport interface DeleteBucketWebsiteOutput {}\n\nexport async function deleteBucketWebsite(\n  this: TOSBase,\n  input: DeleteBucketWebsiteInput\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket<DeleteBucketWebsiteOutput>(\n    bucket,\n    'DELETE',\n    { [CommonQueryKey]: '' },\n    {}\n  );\n}\n","import { convertNormalCamelCase2Upper } from '../../utils';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'notification';\n\nexport interface Filter {\n  TOSKey?: {\n    FilterRules: {\n      Name: string;\n      Value: string;\n    }[];\n  };\n}\ninterface CloudFunctionConfiguration {\n  Events: string[];\n  Filter?: Filter;\n  RuleId?: string;\n  CloudFunction: string;\n}\n\nexport interface RocketMQConf {\n  InstanceId: string;\n  Topic: string;\n  AccessKeyId: string;\n}\nexport interface RocketMQConfiguration {\n  RuleId: string;\n  Role: string;\n  Events: string[]; // \n  Filter?: Filter;\n  RocketMQ: RocketMQConf;\n}\n\nexport interface PutBucketNotificationInput {\n  bucket: string;\n  cloudFunctionConfigurations?: CloudFunctionConfiguration[];\n  rocketMQConfigurations?: RocketMQConfiguration[];\n}\n\nexport interface PutBucketNotificationOutput {}\n\n/**\n * @deprecated use PutBucketNotificationType2 instead\n */\nexport async function putBucketNotification(\n  this: TOSBase,\n  input: PutBucketNotificationInput\n) {\n  const { bucket, ...otherProps } = input;\n\n  const body = convertNormalCamelCase2Upper(otherProps);\n  return this.fetchBucket<PutBucketNotificationOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      ...body,\n    }\n  );\n}\n\nexport interface GetBucketNotificationInput {\n  bucket: string;\n}\n\nexport interface GetBucketNotificationOutput {\n  CloudFunctionConfigurations: CloudFunctionConfiguration[];\n  RocketMQConfigurations: RocketMQConfiguration[];\n}\n\n/**\n * @deprecated use GetBucketNotificationType2 instead\n */\nexport async function getBucketNotification(\n  this: TOSBase,\n  input: GetBucketNotificationInput\n) {\n  const { bucket } = input;\n  try {\n    return await this.fetchBucket<GetBucketNotificationOutput>(\n      bucket,\n      'GET',\n      { [CommonQueryKey]: '' },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketNotificationOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketNotification',\n      defaultResponse: {\n        CloudFunctionConfigurations: [],\n        RocketMQConfigurations: [],\n      },\n    });\n  }\n}\n","import { convertNormalCamelCase2Upper } from '../../utils';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'customdomain';\n\nexport interface CustomDomainRule {\n  Domain: string;\n  Cname: string;\n  Forbidden?: boolean;\n  ForbiddenReason?: string;\n  CertId?: string;\n  CertStatus?: string;\n  /**@private unstable\n   * value tos|s3\n   * */\n  Protocol?: string;\n}\n\nexport interface PutBucketCustomDomainInput {\n  bucket: string;\n  customDomainRule: {\n    Domain: string;\n    CertId?: string;\n    /**@private unstable\n     * value tos|s3\n     * */\n    Protocol?: string;\n  };\n}\n\nexport interface PutBucketCustomDomainOutput {}\n\nexport async function putBucketCustomDomain(\n  this: TOSBase,\n  input: PutBucketCustomDomainInput\n) {\n  const { bucket, ...otherProps } = input;\n\n  const body = convertNormalCamelCase2Upper(otherProps);\n  return this.fetchBucket<PutBucketCustomDomainOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      ...body,\n    }\n  );\n}\n\nexport interface GetBucketCustomDomainInput {\n  bucket: string;\n}\n\nexport interface GetBucketCustomDomainOutput {\n  CustomDomainRules: CustomDomainRule[];\n}\n\nexport async function getBucketCustomDomain(\n  this: TOSBase,\n  input: GetBucketCustomDomainInput\n) {\n  try {\n    const { bucket } = input;\n    return await this.fetchBucket<GetBucketCustomDomainOutput>(\n      bucket,\n      'GET',\n      { [CommonQueryKey]: '' },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketCustomDomainOutput>(error, {\n      defaultResponse: { CustomDomainRules: [] },\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketCustomDomain',\n    });\n  }\n}\n\nexport interface DeleteBucketCustomDomainInput {\n  bucket: string;\n  customDomain: string;\n}\n\nexport interface DeleteBucketCustomDomainOutput {}\n\nexport async function deleteBucketCustomDomain(\n  this: TOSBase,\n  input: DeleteBucketCustomDomainInput\n) {\n  const { bucket, customDomain } = input;\n\n  return this.fetchBucket<DeleteBucketCustomDomainOutput>(\n    bucket,\n    'DELETE',\n    { customdomain: customDomain },\n    {}\n  );\n}\n","import { convertNormalCamelCase2Upper } from '../../utils';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'realtimeLog';\n\ninterface AccessLogConfiguration {\n  UseServiceTopic: boolean;\n  TLSProjectID?: string;\n  TLSTopicID?: string;\n}\n\ninterface RealTimeLogConfiguration {\n  Role: string;\n  AccessLogConfiguration: AccessLogConfiguration;\n}\n\nexport interface PutBucketRealTimeLogInput {\n  bucket: string;\n  realTimeLogConfiguration: RealTimeLogConfiguration;\n}\n\nexport interface PutBucketRealTimeLogOutput {}\n\nexport async function putBucketRealTimeLog(\n  this: TOSBase,\n  input: PutBucketRealTimeLogInput\n) {\n  const { bucket, ...otherProps } = input;\n\n  const body = convertNormalCamelCase2Upper(otherProps);\n  return this.fetchBucket<PutBucketRealTimeLogOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      ...body,\n    }\n  );\n}\n\nexport interface GetBucketRealTimeLogInput {\n  bucket: string;\n}\n\nexport interface GetBucketRealTimeLogOutput {\n  RealTimeLogConfiguration?: RealTimeLogConfiguration;\n}\n\nexport async function getBucketRealTimeLog(\n  this: TOSBase,\n  input: GetBucketRealTimeLogInput\n) {\n  const { bucket } = input;\n\n  try {\n    return await this.fetchBucket<GetBucketRealTimeLogOutput>(\n      bucket,\n      'GET',\n      { [CommonQueryKey]: '' },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketRealTimeLogOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketRealTimeLog',\n      defaultResponse: {},\n    });\n  }\n}\n\nexport interface DeleteBucketRealTimeLogInput {\n  bucket: string;\n}\n\nexport interface DeleteBucketRealTimeLogOutput {}\n\nexport async function deleteBucketRealTimeLog(\n  this: TOSBase,\n  input: DeleteBucketRealTimeLogInput\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket<DeleteBucketRealTimeLogOutput>(\n    bucket,\n    'DELETE',\n    { [CommonQueryKey]: '' },\n    {}\n  );\n}\n","import { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase, { TosResponse } from '../base';\n\n/**\n * \n */\nexport enum ScheduleFrequency {\n  /**  */\n  Daily = 'Daily',\n  /**  */\n  Weekly = 'Weekly',\n}\n\n/**\n * Object\n */\nexport enum IncludedObjectVersions {\n  /**  */\n  All = 'All',\n  /**  */\n  Current = 'Current',\n}\n\n/**\n * \n */\nexport enum InventoryOptionalFields {\n  /** Object */\n  Size = 'Size',\n  /** Object */\n  LastModifiedDat = 'LastModifiedDate',\n  /** Object */\n  ETag = 'ETag',\n  /** Object */\n  StorageClass = 'StorageClass',\n  /** Object */\n  IsMultipartUploaded = 'IsMultipartUploaded',\n  /** Object */\n  EncryptionStatus = 'EncryptionStatus',\n  CRC64 = 'CRC64',\n  /** crr */\n  ReplicationStatus = 'ReplicationStatus',\n  /** \n   * @private unstable\n   *  \n   */\n  RetentionMode = 'RetentionMode',\n  /**\n   * @private unstable  \n   *  \n   */\n  RetainUntilTimestamp = 'RetainUntilTimestamp',\n}\n\n/**\n * \n */\nexport interface BucketInventoryItem {\n  /**  */\n  Id: string;\n  /**  */\n  IsEnabled: boolean;\n  /**  */\n  Filter?: {\n    /**  */\n    Prefix?: string;\n  };\n  /**  */\n  Destination: {\n    /** Bucket  */\n    TOSBucketDestination: {\n      /**  */\n      Format: string;\n      /** Bucket ID */\n      AccountId: string;\n      /**  */\n      Role: string;\n      /**  Bucket */\n      Bucket: string;\n      /**  */\n      Prefix?: string;\n    };\n  };\n  /**  */\n  Schedule: {\n    /**  */\n    Frequency: ScheduleFrequency;\n  };\n  /**  Object  */\n  IncludedObjectVersions: string;\n  /**  */\n  OptionalFields?: {\n    Field: InventoryOptionalFields[];\n  };\n}\n\nexport interface PutBucketInventoryInput {\n  bucket: string;\n  inventoryConfiguration: BucketInventoryItem;\n}\n\nexport interface PutBucketInventoryOutput {}\n\nexport interface GetBucketInventoryInput {\n  bucket: string;\n  id: string;\n}\n\nexport type GetBucketInventoryOutput = BucketInventoryItem | undefined;\nexport interface ListBucketInventoryInput {\n  bucket: string;\n  continuationToken?: string;\n}\n\nexport interface ListBucketInventoryOutput {\n  InventoryConfigurations: BucketInventoryItem[];\n  IsTruncated?: boolean;\n  NextContinuationToken?: string;\n}\n\nexport interface DeleteBucketInventoryInput {\n  bucket: string;\n  id: string;\n}\n\nexport interface DeleteBucketInventoryOutput {}\n\n/**\n * \n */\nexport async function getBucketInventory(\n  this: TOSBase,\n  req: GetBucketInventoryInput\n): Promise<TosResponse<GetBucketInventoryOutput>> {\n  try {\n    const res = await this.fetchBucket<GetBucketInventoryOutput>(\n      req.bucket,\n      'GET',\n      {\n        inventory: '',\n        id: req.id,\n      },\n      {}\n    );\n\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetBucketInventoryOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketInventory',\n      defaultResponse: undefined,\n    });\n  }\n}\n\n/**\n * \n */\nexport async function listBucketInventory(\n  this: TOSBase,\n  req: ListBucketInventoryInput\n): Promise<TosResponse<ListBucketInventoryOutput>> {\n  const params = {\n    inventory: '',\n    ...(req.continuationToken\n      ? { 'continuation-token': req.continuationToken }\n      : null),\n  };\n  try {\n    const res = await this.fetchBucket<ListBucketInventoryOutput>(\n      req.bucket,\n      'GET',\n      params,\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<ListBucketInventoryOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'listBucketInventory',\n      defaultResponse: {\n        InventoryConfigurations: [],\n      },\n    });\n  }\n}\n\n/**\n * \n */\nexport async function deleteBucketInventory(\n  this: TOSBase,\n  req: DeleteBucketInventoryInput\n): Promise<TosResponse<DeleteBucketInventoryOutput>> {\n  return this.fetchBucket(\n    req.bucket,\n    'DELETE',\n    { inventory: '', id: req.id },\n    {}\n  );\n}\n\n/**\n * \n */\nexport function putBucketInventory(\n  this: TOSBase,\n  req: PutBucketInventoryInput\n): Promise<TosResponse<PutBucketInventoryOutput>> {\n  return this.fetchBucket(\n    req.bucket,\n    'PUT',\n    { inventory: '', id: req.inventoryConfiguration.Id },\n    {},\n    req.inventoryConfiguration\n  );\n}\n","/** @file TOS  QoSPolicy()   */\nimport { MergeExclusive } from 'type-fest';\nimport TOSBase from '../base';\n\nexport enum StringOp {\n  StringEquals = 'StringEquals',\n  StringNotEquals = 'StringNotEquals',\n  StringEqualsIgnoreCase = 'StringEqualsIgnoreCase',\n  StringNotEqualsIgnoreCase = 'StringNotEqualsIgnoreCase',\n  StringLike = 'StringLike',\n  StringNotLike = 'StringNotLike',\n}\nexport enum DateOp {\n  DateEquals = 'DateEquals',\n  DateNotEquals = 'DateNotEquals',\n  DateLessThan = 'DateLessThan',\n  DateLessThanEquals = 'DateLessThanEquals',\n  DateGreaterThan = 'DateGreaterThan',\n  DateGreaterThanEquals = 'DateGreaterThanEquals',\n}\nexport enum IpOp {\n  IpAddress = 'IpAddress',\n  NotIpAddress = 'NotIpAddress',\n}\n\n/** () */\nexport type QosOp = StringOp | DateOp | IpOp;\n\n/**  -  */\nexport type QosConditions = {\n  [operator in string]?: {\n    [key in string]: string[];\n  };\n};\n\n/**  */\nexport enum QuotaType {\n  /** Qps */\n  WritesQps = 'WritesQps',\n  /** Qps */\n  ReadsQps = 'ReadsQps',\n  /** listQps */\n  ListQps = 'ListQps',\n  /**  */\n  WritesRate = 'WritesRate',\n  /**  */\n  ReadsRate = 'ReadsRate',\n}\nexport type QuotaTypes = {\n  /**  action Qps */\n  [QuotaType.WritesQps]?: string;\n  /**  action Qps */\n  [QuotaType.ReadsQps]?: string;\n  /** list  action Qps */\n  [QuotaType.ListQps]?: string;\n  /**  action  Mbps */\n  [QuotaType.WritesRate]?: string;\n  /**  action  Mbps */\n  [QuotaType.ReadsRate]?: string;\n};\n\nexport type QosStatement = MergeExclusive<\n  /**  */\n  { Resource: string | string[] },\n  { NotResource: string | string[] }\n> &\n  MergeExclusive<\n    /**  */\n    { Principal: string[] },\n    { NotPrincipal: string[] }\n  > & {\n    /**  */\n    Sid: string;\n    /**  */\n    Quota: QuotaTypes;\n    /**  quota */\n    Condition?: QosConditions;\n  };\n\n/**  */\nexport interface QosPolicy {\n  /**  */\n  Statement: QosStatement[];\n  /** API  */\n  Version?: string;\n  /** Cas  */\n  CasVersion?: string;\n}\n\nexport interface QosPolicyBaseInput {\n  accountId: string;\n}\n\nexport interface GetQosPolicyInput extends QosPolicyBaseInput {}\nexport interface GetQosPolicyOutput extends QosPolicy {\n  Version: string;\n  CasVersion: string;\n}\n\nexport interface PutQosPolicyInput extends QosPolicy, QosPolicyBaseInput {}\n\nexport interface DeleteQosPolicyInput extends QosPolicyBaseInput {}\n\n/**\n * @private unstable method\n * @description \n * @param {GetQosPolicyInput}\n * @returns {GetQosPolicyOutput}\n */\nexport async function getQosPolicy(this: TOSBase, params: GetQosPolicyInput) {\n  const { accountId } = params;\n  const res = await this.fetch<GetQosPolicyOutput>(\n    'GET',\n    '/qospolicy',\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n * @description   QosPolicy\n * @param {PutQosPolicyInput}\n */\nexport async function putQosPolicy(this: TOSBase, params: PutQosPolicyInput) {\n  const { accountId, ...restParams } = params;\n  const res = await this.fetch(\n    'PUT',\n    '/qospolicy',\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    {\n      ...restParams,\n    },\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n * @description \n * @param {DeleteQosPolicyInput}\n */\nexport async function deleteQosPolicy(\n  this: TOSBase,\n  params: DeleteQosPolicyInput\n) {\n  const { accountId } = params;\n  const res = await this.fetch(\n    'DELETE',\n    '/qospolicy',\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n","import TOSBase from '../base';\nimport { convertNormalCamelCase2Upper, paramsSerializer } from '../../utils';\nimport { StorageClassType, TierType } from '../../TosExportEnum';\nexport type JobStatusType =\n  | 'New'\n  | 'Preparing'\n  | 'Suspended'\n  | 'Ready'\n  | 'Active'\n  | 'Pausing'\n  | 'Paused'\n  | 'Complete'\n  | 'Cancelling'\n  | 'Cancelled'\n  | 'Failing'\n  | 'Failed';\n\nexport type DirectiveType = 'COPY' | 'REPLACE' | 'ADD';\nexport type CannedAccessControlListType = 'default' | 'private' | 'public-read';\nexport type PermissionType = 'READ' | 'READ_ACP' | 'WRITE_ACP' | 'FULL_CONTROL';\nexport type PrefixReplaceType = 'true' | 'false';\nexport type ConfirmationRequiredType = '0' | '1';\n\nexport interface Tag {\n  Key: string;\n  Value: string;\n}\n\ninterface Manifest {\n  Location: {\n    ETag: string;\n    ObjectTrn: string;\n    ObjectVersionId?: string;\n  };\n  Spec: {\n    Format: 'TOSInventoryReport_CSV_V1';\n  };\n}\n\nexport interface NewObjectMetadataType {\n  SSEAlgorithm?: 'AES256';\n  UserMetadata?: {\n    member: { Key: string; Value: string }[];\n  };\n  'content-type'?: string;\n  'content-encoding'?: string;\n  'content-language'?: string;\n  'cache-control'?: string;\n  'content-disposition'?: string;\n  expires?: string;\n}\nexport interface NewObjectTaggingType {\n  TOSTag?: Tag[];\n}\nexport interface Report {\n  Bucket: string;\n  Enabled: PrefixReplaceType;\n  Format: 'Report_CSV_V1';\n  Prefix: string;\n  ReportScope: 'AllTasks' | 'FailedTasksOnly';\n}\n\nexport interface ProgressSummary {\n  TotalNumberOfTasks: number;\n  NumberOfTasksSucceeded: number;\n  NumberOfTasksFailed: number;\n}\n\nexport interface ListBatchInput {\n  accountId: string;\n  jobStatuses?: string[];\n  nextToken?: string;\n  maxResults?: number;\n}\n\nexport interface UpdateJobPriorityInput {\n  jobId: string;\n  priority: number;\n  accountId: string;\n}\nexport interface UpdateJobStatusInput {\n  jobId: string;\n  accountId: string;\n  requestedJobStatus: 'Ready' | 'Cancelled';\n  statusUpdateReason?: string;\n}\n\nexport interface JobInput {\n  JobId: string;\n  accountId: string;\n}\n\nexport type DeleteJob = JobInput;\nexport type DescribeJob = JobInput;\n\nexport interface AccessControlList {\n  TOSGrant: {\n    Grantee: {\n      Identifier: string;\n      TypeIdentifier: 'id';\n    };\n    Permission: PermissionType;\n  }[];\n}\nexport interface TOSPutObjectCopy {\n  TOSPutObjectCopy: {\n    PrefixReplace: PrefixReplaceType;\n    ResourcesPrefix: string;\n    TargetKeyPrefix: string;\n    StorageClass: StorageClassType;\n    AccessControlDirective: DirectiveType;\n    CannedAccessControlList?: CannedAccessControlListType;\n    AccessControlGrants?: AccessControlList;\n    TargetResource: string;\n    MetadataDirective: DirectiveType;\n    NewObjectMetadata: NewObjectMetadataType;\n    TaggingDirective: DirectiveType;\n    NewObjectTagging: NewObjectTaggingType;\n  };\n}\n\nexport interface TOSPutObjectAcl {\n  TOSPutObjectAcl: {\n    AccessControlPolicy: {\n      CannedAccessControlList: CannedAccessControlListType;\n      AccessControlList: AccessControlList;\n    };\n  };\n}\n\nexport interface TOSPutObjectTagging {\n  TOSPutObjectTagging: {\n    TOSTag: Tag[];\n  };\n}\n\nexport interface TOSRestoreObject {\n  TOSRestoreObject: {\n    Days: number;\n    Tier: TierType;\n  };\n}\n\nexport interface TOSDeleteObjectTagging {\n  TOSDeleteObjectTagging: {};\n}\n\nexport type PutJobInput = {\n  accountId: string;\n  clientRequestToken: string;\n  confirmationRequired: '0' | '1';\n  description?: string;\n  manifest: Manifest;\n  priority: string;\n  roleTrn: string;\n  report?: Report;\n  operation?:\n    | TOSPutObjectCopy\n    | TOSPutObjectAcl\n    | TOSPutObjectTagging\n    | TOSRestoreObject\n    | TOSDeleteObjectTagging;\n};\n\nexport interface DescribeJobRes {\n  Job: {\n    JobId: string;\n    ConfirmationRequired: ConfirmationRequiredType;\n    Description?: string;\n    FailureReasons?: {\n      JobFailure: {\n        FailureCode: string;\n        FailureReason: string;\n      };\n    };\n    Manifest: Manifest;\n    Priority: number;\n    ProgressSummary: ProgressSummary;\n    Report: Report;\n    RoleArn: string;\n    Status: JobStatusType;\n    StatusUpdateReason: string;\n    SuspendedDate: string;\n    TerminationDate: string;\n    CreationTime: string;\n    Operation:\n      | TOSPutObjectCopy\n      | TOSPutObjectAcl\n      | TOSPutObjectTagging\n      | TOSRestoreObject\n      | TOSDeleteObjectTagging;\n  };\n}\n\nexport interface JobList {\n  JobId: string;\n  CreationTime: string;\n  Operation:\n    | 'TOSPutObjectCopy'\n    | 'TOSPutObjectAcl'\n    | 'TOSPutObjectTagging'\n    | 'TOSRestoreObject'\n    | 'TOSDeleteObjectTagging';\n  Priority: number;\n  ProgressSummary: ProgressSummary;\n  Status: JobStatusType;\n  TerminationDate: string;\n  Description: string;\n}\nexport interface JobListRes {\n  Jobs: {\n    member: JobList[];\n  };\n  NextToken: string;\n}\n\n/**\n *\n * @private unstable method\n * @description \n * @param params\n * @returns\n */\nexport async function createJob(this: TOSBase, params: PutJobInput) {\n  const { accountId, ...reset } = params;\n  const data = convertNormalCamelCase2Upper(reset);\n  const res = await this.fetch(\n    'POST',\n    '/jobs',\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    {\n      ...data,\n    }\n  );\n  return res;\n}\n\n/**\n * @private unstable method\n * @description  \n * @param params\n * @returns\n */\nexport async function listJobs(this: TOSBase, params: ListBatchInput) {\n  const { accountId, maxResults = 1000, ...others } = params;\n  const res = await this.fetch<JobListRes>(\n    'GET',\n    '/jobs',\n    {\n      maxResults,\n      ...others,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {\n      axiosOpts: {\n        paramsSerializer,\n      },\n    }\n  );\n  return res;\n}\n\n/**\n *\n * @private unstable method\n * @description \n * @param params\n * @returns\n */\nexport async function updateJobPriority(\n  this: TOSBase,\n  params: UpdateJobPriorityInput\n) {\n  const { accountId, jobId: JobId, priority } = params;\n  const res = await this.fetch(\n    'POST',\n    `/jobs/${JobId}/priority`,\n    {\n      priority,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {\n      needMd5: true,\n    }\n  );\n  return res;\n}\n\n/**\n *\n * @private unstable method\n * @description \n * @param params\n * @returns\n */\nexport async function updateJobStatus(\n  this: TOSBase,\n  params: UpdateJobStatusInput\n) {\n  const {\n    accountId,\n    jobId: JobId,\n    requestedJobStatus,\n    statusUpdateReason,\n  } = params;\n  const res = await this.fetch(\n    'POST',\n    `/jobs/${JobId}/status`,\n    {\n      requestedJobStatus,\n      statusUpdateReason,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {\n      needMd5: true,\n    }\n  );\n  return res;\n}\n\n/**\n *\n * @private unstable method\n * @description \n * @param params\n * @returns\n */\nexport async function deleteJob(this: TOSBase, params: DeleteJob) {\n  const { accountId, JobId } = params;\n  const res = await this.fetch(\n    'DELETE',\n    `/jobs/${JobId}`,\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    {}\n  );\n  return res;\n}\n\n/**\n *\n * @private unstable method\n * @description \n * @param params\n * @returns\n */\nexport async function describeJob(this: TOSBase, params: DescribeJob) {\n  const { accountId, JobId } = params;\n  const res = await this.fetch<DescribeJobRes>(\n    'GET',\n    `/jobs/${JobId}`,\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    {}\n  );\n  return res;\n}\n","import { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase, { TosResponse } from '../base';\n\ninterface TagSet {\n  Tags: {\n    Key: string;\n    Value: string;\n  }[];\n}\n\nexport interface PutBucketTaggingInput {\n  bucket?: string;\n  tagging: {\n    TagSet: TagSet;\n  };\n}\n\nexport interface GetBucketTaggingInput {\n  bucket: string;\n}\nexport interface GetBucketTaggingOutput {\n  TagSet: TagSet;\n}\n\n/**\n * @private unstable method\n */\nexport async function putBucketTagging(\n  this: TOSBase,\n  input: PutBucketTaggingInput\n) {\n  const res = await this.fetchBucket(\n    input.bucket,\n    'PUT',\n    { tagging: '' },\n    {},\n    input.tagging,\n    {\n      needMd5: true,\n    }\n  );\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketTagging(\n  this: TOSBase,\n  { bucket }: GetBucketTaggingInput\n): Promise<TosResponse<GetBucketTaggingOutput>> {\n  try {\n    const res = await this.fetchBucket<GetBucketTaggingOutput>(\n      bucket,\n      'GET',\n      {\n        tagging: '',\n      },\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetBucketTaggingOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketTagging',\n      defaultResponse: {\n        TagSet: {\n          Tags: [],\n        },\n      },\n    });\n  }\n}\n\nexport interface DeleteBucketTaggingInput {\n  bucket: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function deleteBucketTagging(\n  this: TOSBase,\n  { bucket }: DeleteBucketTaggingInput\n) {\n  return this.fetchBucket(bucket, 'DELETE', { tagging: '' }, {});\n}\n","import TOSBase, { TosResponse } from '../base';\n\nexport interface BucketPayByTraffic {\n  ChargeType: 'FlowOut' | 'Bandwidth';\n  ActiveType: 'NextDay' | 'NextMonth';\n}\n\nexport interface PutBucketPayByTrafficInput {\n  bucket?: string;\n  payByTraffic: BucketPayByTraffic;\n}\n\nexport type GetBucketPayByTrafficOutput = BucketPayByTraffic & {\n  ActiveTime: string;\n};\n\n/**\n * @private unstable method\n */\nexport async function putBucketPayByTraffic(\n  this: TOSBase,\n  input: PutBucketPayByTrafficInput\n) {\n  const res = await this.fetchBucket(\n    input.bucket,\n    'PUT',\n    { payByTraffic: '' },\n    {},\n    input.payByTraffic\n  );\n  return res;\n}\n\ninterface GetBucketPayByTrafficInput {\n  bucket: string;\n}\n/**\n * @private unstable method\n */\nexport async function getBucketPayByTraffic(\n  this: TOSBase,\n  { bucket }: GetBucketPayByTrafficInput\n): Promise<TosResponse<GetBucketPayByTrafficOutput>> {\n  const res = await this.fetchBucket<GetBucketPayByTrafficOutput>(\n    bucket,\n    'GET',\n    {\n      payByTraffic: '',\n    },\n    {}\n  );\n  return res;\n}\n","import TOSBase, { TosResponse } from '../base';\nimport TosServerError from '../../TosServerError';\nexport interface ImageStyle {\n  Name: string;\n  Content: string;\n  CreateTime: string;\n  LastModifyTime: string;\n}\n\nexport interface BucketImgStyle {\n  bucket?: string;\n  imageStyles: { ImageStyles: ImageStyle[] };\n}\n\nexport interface ImageBriefInfo {\n  Name: string;\n  BucketLevelContent: string;\n  PrefixCount: number;\n}\n\nexport interface BucketImageBriefInfo {\n  BucketName: string;\n  ImageStyleBriefInfo: ImageBriefInfo[];\n}\n\nexport interface GetImageStyleBriefInfoInput {\n  bucket: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function getImageStyleBriefInfo(\n  this: TOSBase,\n  req: GetImageStyleBriefInfoInput\n): Promise<TosResponse<BucketImageBriefInfo>> {\n  const { bucket } = req;\n  try {\n    const res = await this.fetchBucket<BucketImageBriefInfo>(\n      bucket,\n      'GET',\n      {\n        imageStyleBriefInfo: '',\n      },\n      {}\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(\n          {\n            BucketName: bucket,\n            ImageStyleBriefInfo: [],\n          },\n          err\n        );\n      }\n    }\n\n    throw err;\n  }\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketImageStyleList(\n  this: TOSBase,\n  bucket: string\n): Promise<TosResponse<BucketImgStyle['imageStyles']>> {\n  try {\n    const res = await this.fetchBucket<BucketImgStyle['imageStyles']>(\n      bucket,\n      'GET',\n      {\n        imageStyle: '',\n      },\n      {}\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(\n          {\n            ImageStyles: [],\n          },\n          err\n        );\n      }\n    }\n\n    throw err;\n  }\n}\n\nexport interface GetBucketImageStyleListByNameInput {\n  bucket: string;\n  styleName: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketImageStyleListByName(\n  this: TOSBase,\n  req: GetBucketImageStyleListByNameInput\n): Promise<TosResponse<BucketImgStyle['imageStyles']>> {\n  try {\n    const { bucket, styleName } = req;\n    const res = await this.fetchBucket<BucketImgStyle['imageStyles']>(\n      bucket,\n      'GET',\n      {\n        imageStyleContent: '',\n        styleName,\n      },\n      {}\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(\n          {\n            ImageStyles: [],\n          },\n          err\n        );\n      }\n    }\n\n    throw err;\n  }\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketImageStyle(\n  this: TOSBase,\n  bucket: string,\n  styleName: string\n): Promise<TosResponse<ImageStyle | null>> {\n  try {\n    const res = await this.fetchBucket<ImageStyle>(\n      bucket,\n      'GET',\n      {\n        imageStyle: '',\n        styleName,\n      },\n      {}\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(null, err);\n      }\n    }\n\n    throw err;\n  }\n}\n\nexport interface PutBucketImageStyleInput {\n  bucket: string;\n  styleName: string;\n  content: string;\n  styleObjectPrefix?: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function putBucketImageStyle(\n  this: TOSBase,\n  req: PutBucketImageStyleInput\n): Promise<TosResponse<any>> {\n  const { bucket, styleName, content, styleObjectPrefix } = req;\n  try {\n    const res = await this.fetchBucket<any>(\n      bucket,\n      'PUT',\n      {\n        imageStyle: '',\n        styleName,\n        styleObjectPrefix,\n      },\n      {},\n      { Content: content }\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(null, err);\n      }\n    }\n\n    throw err;\n  }\n}\n\nexport interface DeleteBucketImageStyleInput {\n  bucket: string;\n  styleName: string;\n  styleObjectPrefix?: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function deleteBucketImageStyle(\n  this: TOSBase,\n  req: DeleteBucketImageStyleInput\n): Promise<TosResponse<any>> {\n  const { styleName, styleObjectPrefix, bucket } = req;\n  try {\n    const res = await this.fetchBucket<any>(\n      bucket,\n      'DELETE',\n      {\n        imageStyle: '',\n        styleName,\n        styleObjectPrefix,\n      },\n      {}\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(null, err);\n      }\n    }\n    throw err;\n  }\n}\n\nexport interface BucketImgProtect {\n  Enable: boolean;\n  Suffixes?: string[];\n  //OSS10\n  OIPRules?: any[];\n  Prefix?: string;\n  Suffix?: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function putBucketImageProtect(\n  this: TOSBase,\n  bucket: string,\n  data: BucketImgProtect\n): Promise<TosResponse<any>> {\n  try {\n    const res = await this.fetchBucket<any>(\n      bucket,\n      'PUT',\n      {\n        originalImageProtect: '',\n      },\n      {},\n      data\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(null, err);\n      }\n    }\n    throw err;\n  }\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketImageProtect(\n  this: TOSBase,\n  bucket: string\n): Promise<TosResponse<any>> {\n  try {\n    const res = await this.fetchBucket<any>(\n      bucket,\n      'GET',\n      {\n        originalImageProtect: '',\n      },\n      {}\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(null, err);\n      }\n    }\n    throw err;\n  }\n}\nexport type BucketImgProtectStyleSeparator = '-' | '_' | '!' | '\\\\';\n\nexport type BucketImgStyleSeparatorAffixes = Partial<\n  Record<BucketImgProtectStyleSeparator, string>\n>;\n\nexport interface PutBucketImageStyleSeparatorInput {\n  bucket: string;\n  Separator: BucketImgProtectStyleSeparator[];\n  SeparatorSuffix?: BucketImgStyleSeparatorAffixes;\n}\n\n/**\n * @private unstable method\n */\nexport async function putBucketImageStyleSeparator(\n  this: TOSBase,\n  req: PutBucketImageStyleSeparatorInput\n): Promise<TosResponse<any>> {\n  const { bucket, Separator, SeparatorSuffix } = req;\n  try {\n    const res = await this.fetchBucket<any>(\n      bucket,\n      'PUT',\n      {\n        imageStyleSeparator: '',\n      },\n      {},\n      { Separator, SeparatorSuffix }\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(null, err);\n      }\n    }\n    throw err;\n  }\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketImageStyleSeparator(\n  this: TOSBase,\n  bucket: string\n): Promise<TosResponse<any>> {\n  try {\n    const res = await this.fetchBucket<any>(\n      bucket,\n      'GET',\n      {\n        imageStyleSeparator: '',\n      },\n      {}\n    );\n    return res;\n  } catch (err) {\n    if (err instanceof TosServerError) {\n      if (err.statusCode === 404) {\n        return this.getNormalDataFromError(null, err);\n      }\n    }\n    throw err;\n  }\n}\n","import { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase, { TosResponse } from '../base';\n\nexport interface BucketIntelligenttieringOutput {\n  Status?: 'Enabled' | 'Disabled';\n  Transitions?: {\n    Days: number;\n    AccessTier: 'INFREQUENT' | 'ARCHIVEFR';\n  }[];\n}\n\nexport async function getBucketIntelligenttiering(\n  this: TOSBase,\n  bucket?: string\n): Promise<TosResponse<BucketIntelligenttieringOutput>> {\n  try {\n    const res = await this.fetchBucket<BucketIntelligenttieringOutput>(\n      bucket,\n      'GET',\n      { intelligenttiering: '' },\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<BucketIntelligenttieringOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketIntelligenttiering',\n      defaultResponse: {},\n    });\n  }\n}\n","import { convertNormalCamelCase2Upper } from '../../utils';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'rename';\n\nexport interface PutBucketRenameInput {\n  bucket?: string;\n  renameEnable: boolean;\n}\n\nexport interface PutBucketRenameOutput {}\n\nexport async function putBucketRename(\n  this: TOSBase,\n  input: PutBucketRenameInput\n) {\n  const { bucket, ...otherProps } = input;\n\n  const body = convertNormalCamelCase2Upper(otherProps);\n  return this.fetchBucket<PutBucketRenameOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      ...body,\n    }\n  );\n}\n\nexport interface GetBucketRenameInput {\n  bucket?: string;\n}\n\nexport interface GetBucketRenameOutput {\n  RenameEnable: boolean;\n}\n\nexport async function getBucketRename(\n  this: TOSBase,\n  input: GetBucketRenameInput\n) {\n  const { bucket } = input;\n  return await this.fetchBucket<GetBucketRenameOutput>(\n    bucket,\n    'GET',\n    { [CommonQueryKey]: '' },\n    {}\n  );\n}\n\nexport interface DeleteBucketRenameInput {\n  bucket?: string;\n}\n\nexport interface DeleteBucketRenameOutput {}\n\nexport async function deleteBucketRename(\n  this: TOSBase,\n  input: DeleteBucketRenameInput\n) {\n  const { bucket } = input;\n\n  return this.fetchBucket<DeleteBucketRenameOutput>(\n    bucket,\n    'DELETE',\n    { [CommonQueryKey]: '' },\n    {}\n  );\n}\n","import { TierType } from '../../TosExportEnum';\nimport { convertNormalCamelCase2Upper } from '../../utils';\nimport TOSBase from '../base';\n\nexport interface RestoreObjectInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n  days: number;\n  restoreJobParameters?: {\n    Tier: TierType;\n  };\n}\n\nexport async function restoreObject(this: TOSBase, input: RestoreObjectInput) {\n  const { bucket, key, versionId, ...otherProps } = input;\n  const query: Record<string, any> = { restore: '' };\n  if (versionId) {\n    query.versionId = versionId;\n  }\n  const body = convertNormalCamelCase2Upper(otherProps);\n\n  return this._fetchObject<undefined>(input, 'POST', query, {}, body);\n}\n\nexport default restoreObject;\n","import TOSBase from '../base';\nimport { paramsSerializer } from '../../utils';\n\nexport interface IMetaData {\n  accountId: string;\n}\n\nexport interface StorageLensInput extends IMetaData {\n  Id: string;\n}\ninterface IStrategy {\n  Buckets: {\n    Bucket: string[];\n  };\n  Regions: {\n    Region: string[];\n  };\n}\n\ninterface IPrefixLevel {\n  StorageMetrics: {\n    IsEnabled: boolean;\n    SelectionCriteria: {\n      MaxDepth?: number;\n      MinStorageBytesPercentage?: number;\n      Delimiter: string;\n      Prefixes?: string[];\n    };\n  };\n}\nexport interface StorageLensConfigurationInput extends StorageLensInput {\n  Region: string;\n  IsEnabled: boolean;\n  AccountLevel: {\n    BucketLevel: {\n      /** @deprecated will be removed soon */\n      ActivityMetrics?: {\n        IsEnabled: boolean;\n      };\n      HotStatsMetrics?: {\n        IsEnabled: boolean;\n        Actions: string[]; //action\n      };\n      PrefixLevel?: IPrefixLevel;\n    };\n  };\n  DataExport?: {\n    BucketDestination?: {\n      Bucket: string;\n      Prefix?: string;\n      OutputSchemaVersion: string;\n      Format: string;\n      Role: string;\n    };\n  };\n  Include?: IStrategy;\n  Exclude?: IStrategy;\n}\nexport type StorageLensConfigurationOutput = StorageLensConfigurationInput;\n\n/**\n * @private unstable method\n * @description \n * @param params\n * @returns\n */\nexport async function listStorageLens(this: TOSBase, params: IMetaData) {\n  const { accountId } = params;\n  const res = await this.fetch<StorageLensConfigurationOutput[]>(\n    'GET',\n    '/storagelens',\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {\n      axiosOpts: {\n        paramsSerializer,\n      },\n    }\n  );\n  return res;\n}\n\n/**\n * @private unstable method\n * @description \n * @param params\n * @returns\n */\nexport async function deleteStorageLens(\n  this: TOSBase,\n  params: StorageLensInput\n) {\n  const { accountId, Id } = params;\n  const res = await this.fetch(\n    'DELETE',\n    `/storagelens`,\n    {\n      id: Id,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {\n      needMd5: true,\n    }\n  );\n  return res;\n}\n\n/**\n * @private unstable method\n * @description \n * @param params\n * @returns\n */\nexport async function getStorageLens(this: TOSBase, params: StorageLensInput) {\n  const { accountId, Id } = params;\n  const res = await this.fetch<StorageLensConfigurationOutput>(\n    'GET',\n    `/storagelens`,\n    {\n      id: Id,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {\n      needMd5: true,\n    }\n  );\n  return res;\n}\n/**\n * @private unstable method\n * @description \n * @param params\n * @returns\n */\nexport async function putStorageLens(\n  this: TOSBase,\n  params: StorageLensConfigurationInput\n) {\n  const { accountId, Id, ...rest } = params;\n\n  const res = await this.fetch(\n    'PUT',\n    `/storagelens`,\n    {\n      id: Id,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {\n      ...rest,\n      Id,\n    },\n    {\n      needMd5: true,\n    }\n  );\n  return res;\n}\n","import { convertNormalCamelCase2Upper } from '../../utils';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'notification_v2';\n\nexport interface NotificationFilter {\n  TOSKey?: {\n    FilterRules: {\n      Name: string;\n      Value: string;\n    }[];\n  };\n}\n\nexport interface DestinationRocketMQ {\n  Role: string;\n  InstanceId: string;\n  Topic: string;\n  AccessKeyId: string;\n  Region?: string;\n}\n\n/**\n *  @private unstable\n */\nexport interface DestinationKafka {\n  Role: string;\n  InstanceId: string;\n  Topic: string;\n  User: string;\n  Region?: string;\n}\n\ninterface DestinationHttpServer {\n  Url: string;\n}\n\nexport interface NotificationDestination {\n  RocketMQ?: DestinationRocketMQ[];\n  VeFaaS?: { FunctionId: string }[];\n  Kafka?: DestinationKafka[];\n  HttpServer?: DestinationHttpServer[];\n}\n\nexport interface NotificationRule {\n  RuleId: string;\n  Events: string[];\n  Filter?: NotificationFilter;\n  Destination: NotificationDestination;\n}\n\nexport interface PutBucketNotificationInput {\n  bucket: string;\n  Rules: NotificationRule[];\n  Version?: string;\n}\n\nexport interface PutBucketNotificationOutput {}\n\nexport async function putBucketNotificationType2(\n  this: TOSBase,\n  input: PutBucketNotificationInput\n) {\n  const { bucket, ...otherProps } = input;\n\n  const body = convertNormalCamelCase2Upper(otherProps);\n  return this.fetchBucket<PutBucketNotificationOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      ...body,\n    }\n  );\n}\n\nexport interface GetBucketNotificationInput {\n  bucket: string;\n}\n\nexport interface GetBucketNotificationOutput {\n  Rules: NotificationRule[];\n  Version?: string;\n}\n\nexport async function getBucketNotificationType2(\n  this: TOSBase,\n  input: GetBucketNotificationInput\n) {\n  const { bucket } = input;\n  try {\n    return await this.fetchBucket<GetBucketNotificationOutput>(\n      bucket,\n      'GET',\n      { [CommonQueryKey]: '' },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketNotificationOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketNotificationType2',\n      defaultResponse: {\n        Rules: [],\n      },\n    });\n  }\n}\n","import TOSBase, { TosResponse } from '../base';\nimport { fillRequestHeaders, normalizeHeadersKey } from '../../utils';\nimport { Acl } from '../../interface';\nimport { StorageClassType } from '../../TosExportEnum';\n\nexport interface PutSymInput {\n  bucket?: string;\n  key: string;\n  symLinkTargetKey: string;\n  symLinkTargetBucket?: string;\n  forbidOverwrite?: boolean;\n  acl?: Acl;\n  meta?: Record<string, string>;\n  storageClass?: StorageClassType;\n\n  headers?: {\n    'x-tos-symlink-target': string;\n    'x-tos-symlink-bucket'?: string;\n    'x-tos-forbid-overwrite'?: string;\n    'x-tos-acl'?: Acl;\n    'x-tos-storage-class'?: string;\n    [key: string]: string | undefined;\n  };\n}\n\nexport interface PutSymOutput {\n  VersionID?: string;\n}\n/**\n * @private unstable method\n */\nexport async function putSymlink(this: TOSBase, input: PutSymInput) {\n  return _putSymlink.call(this, input);\n}\n\nexport async function _putSymlink(\n  this: TOSBase,\n  input: PutSymInput\n): Promise<TosResponse<PutSymOutput>> {\n  const headers = (input.headers = normalizeHeadersKey(input.headers));\n  fillRequestHeaders(input, [\n    'symLinkTargetKey',\n    'symLinkTargetBucket',\n    'forbidOverwrite',\n    'acl',\n    'storageClass',\n    'meta',\n  ]);\n  return this._fetchObject<PutSymOutput>(\n    input,\n    'PUT',\n    { symlink: '' },\n    headers,\n    undefined,\n    {\n      handleResponse(response) {\n        const { headers } = response;\n        return {\n          VersionID: headers['x-tos-version-id'],\n        };\n      },\n    }\n  );\n}\n\nexport default putSymlink;\n","import TOSBase, { TosResponse } from '../base';\n\nexport interface GetSymInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n}\n\nexport interface PutSymOutput {\n  VersionID?: string;\n  SymlinkTargetKey: string;\n  SymlinkTargetBucket: string;\n  LastModified: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function getSymlink(this: TOSBase, input: GetSymInput) {\n  return _getSymlink.call(this, input);\n}\n\nexport async function _getSymlink(\n  this: TOSBase,\n  input: GetSymInput\n): Promise<TosResponse<PutSymOutput>> {\n  const query: Record<string, any> = { symlink: '' };\n  if (input.versionId) {\n    query.versionId = input.versionId;\n  }\n  return this._fetchObject<PutSymOutput>(input, 'GET', query, {}, undefined, {\n    handleResponse: (res) => {\n      const { headers } = res;\n      return {\n        VersionID: headers['x-tos-version-id'],\n        SymlinkTargetKey: headers['x-tos-symlink-target'],\n        SymlinkTargetBucket: headers['x-tos-symlink-bucket'],\n        LastModified: headers['last-modified'],\n      };\n    },\n  });\n}\n\nexport default getSymlink;\n","import { handleEmptyServerError } from '../../handleEmptyServerError';\nimport { TransferAccelerationStatusType } from '../../TosExportEnum';\nimport { convertNormalCamelCase2Upper } from '../../utils';\nimport { Headers } from '../../interface';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'transferAcceleration';\n\nexport interface PutBucketTransferAccelerationInput {\n  bucket?: string;\n  transferAccelerationConfiguration: {\n    Enabled: 'true' | 'false';\n  };\n}\n\nexport interface PutBucketTransferAccelerationOutput {}\n\n/**\n * @private unstable\n */\nexport async function putBucketTransferAcceleration(\n  this: TOSBase,\n  input: PutBucketTransferAccelerationInput\n) {\n  const { bucket, ...otherProps } = input;\n\n  const body = convertNormalCamelCase2Upper(otherProps);\n  return this.fetchBucket<PutBucketTransferAccelerationOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      ...body,\n    }\n  );\n}\n\nexport interface GetBucketTransferAccelerationInput {\n  bucket?: string;\n  getStatus?: boolean;\n}\n\nexport interface GetBucketTransferAccelerationOutput {\n  TransferAccelerationConfiguration: {\n    Enabled: 'true' | 'false';\n    Status: TransferAccelerationStatusType;\n  };\n}\n\n/**\n * @private unstable\n */\nexport async function getBucketTransferAcceleration(\n  this: TOSBase,\n  input: GetBucketTransferAccelerationInput\n) {\n  try {\n    const { bucket } = input;\n    const headers: Headers = {};\n    if (input.getStatus) {\n      headers['x-tos-get-bucket-acceleration-status'] = 'true';\n    }\n    const res = await this.fetchBucket<GetBucketTransferAccelerationOutput>(\n      bucket,\n      'GET',\n      { [CommonQueryKey]: '' },\n      headers\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetBucketTransferAccelerationOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketTransferAcceleration',\n      defaultResponse: {\n        TransferAccelerationConfiguration: {\n          Enabled: 'false',\n          Status: TransferAccelerationStatusType.Terminated,\n        },\n      },\n    });\n  }\n}\n","import TOSBase from '../base';\nimport { GetBucketLifecycleInput } from './lifecycle';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\nexport interface PutBucketAccessMonitorInput {\n  bucket: string;\n  status: 'Enabled' | 'Disabled';\n}\n\nexport interface PutBucketAccessMonitorOutput {}\n\n/**\n * @private unstable method\n */\nexport async function putBucketAccessMonitor(\n  this: TOSBase,\n  input: PutBucketAccessMonitorInput\n) {\n  const { bucket, status } = input;\n\n  return this.fetchBucket<PutBucketAccessMonitorOutput>(\n    bucket,\n    'PUT',\n    { accessmonitor: '' },\n    {},\n    {\n      Status: status,\n    }\n  );\n}\n\nexport interface GetBucketAccessMonitorInput {\n  bucket: string;\n}\n\nexport interface GetBucketAccessMonitorOutput {\n  Status?: 'Enabled' | 'Disabled';\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketAccessMonitor(\n  this: TOSBase,\n  input: GetBucketLifecycleInput\n) {\n  try {\n    const { bucket } = input;\n\n    return await this.fetchBucket<GetBucketAccessMonitorOutput>(\n      bucket,\n      'GET',\n      { accessmonitor: '' },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketAccessMonitorOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketAccessMonitor',\n      defaultResponse: {},\n    });\n  }\n}\n","import TOSBase from '../base';\nimport { AccessPointStatusType } from '../../TosExportEnum';\n\nexport interface AccessPoint {\n  Name: string; //\n  Alias?: string; //\n  Status: AccessPointStatusType; //;\n  CreatedAt: number;\n  Regions: Array<{\n    Bucket: string;\n    BucketAccountId: number;\n    Region: string;\n  }>;\n}\n\nexport interface CreateMultiRegionAccessPointInput {\n  name: string;\n  regions: Array<{\n    Bucket: string;\n    BucketAccountId: string;\n  }>;\n  accountId: string;\n}\n\nexport interface CreateMultiRegionAccessPointOutput {}\n\n/**\n * @private unstable method\n */\nexport async function createMultiRegionAccessPoint(\n  this: TOSBase,\n  input: CreateMultiRegionAccessPointInput\n) {\n  const { accountId, name, regions } = input;\n\n  const res = await this.fetch<CreateMultiRegionAccessPointOutput>(\n    'POST',\n    '/mrap',\n    {\n      name,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {\n      Name: name,\n      Regions: regions,\n    },\n    {}\n  );\n\n  return res;\n}\n\nexport interface GetMultiRegionAccessPointInput {\n  name: string;\n  accountId: string;\n}\n\nexport interface GetMultiRegionAccessPointOutput extends AccessPoint {}\n\n/**\n * @private unstable method\n */\nexport async function getMultiRegionAccessPoint(\n  this: TOSBase,\n  input: GetMultiRegionAccessPointInput\n) {\n  const { name, accountId } = input;\n  const res = await this.fetch<GetMultiRegionAccessPointOutput>(\n    'GET',\n    '/mrap',\n    {\n      name,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\nexport interface ListMultiRegionAccessPointsInput {\n  accountId: string;\n  maxResults?: number;\n  nextToken?: string;\n}\n\nexport interface ListMultiRegionAccessPointsOutput {\n  AccessPoints: Array<AccessPoint>;\n  NextToken?: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function listMultiRegionAccessPoints(\n  this: TOSBase,\n  input: ListMultiRegionAccessPointsInput\n) {\n  const { accountId, ...nextQuery } = input;\n  const res = await this.fetch<ListMultiRegionAccessPointsOutput>(\n    'GET',\n    '/mrap',\n    { ...nextQuery },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\nexport interface GetMultiRegionAccessPointRoutesInput {\n  accountId: string;\n  alias: string;\n}\n\nexport interface AccessPointRoute {\n  Bucket: string;\n  Region: string;\n  TrafficDialPercentage: number;\n}\n\nexport interface GetMultiRegionAccessPointRoutesOutput {\n  Routes?: AccessPointRoute[];\n  Alias?: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function getMultiRegionAccessPointRoutes(\n  this: TOSBase,\n  input: GetMultiRegionAccessPointRoutesInput\n) {\n  const { accountId, alias } = input;\n  const res = await this.fetch<GetMultiRegionAccessPointRoutesOutput>(\n    'GET',\n    '/mrap/routes',\n    {\n      alias,\n    },\n    {\n      'x-tos-account-id': accountId,\n    }\n  );\n  return res;\n}\n\nexport interface DeleteMultiRegionAccessPointInput {\n  accountId: string;\n  name: string;\n}\n\nexport interface DeleteMultiRegionAccessPointOutput {}\n\nexport async function deleteMultiRegionAccessPoint(\n  this: TOSBase,\n  input: DeleteMultiRegionAccessPointInput\n) {\n  const { name, accountId } = input;\n  const res = await this.fetch<DeleteMultiRegionAccessPointOutput>(\n    'DELETE',\n    '/mrap',\n    {\n      name,\n    },\n    {\n      'x-tos-account-id': accountId,\n    }\n  );\n  return res;\n}\n\nexport interface SubmitMultiRegionAccessPointRoutesInput {\n  accountId: string;\n  alias: string;\n  routes: AccessPointRoute[];\n}\n\nexport interface SubmitMultiRegionAccessPointRoutesOutput {}\n\nexport async function submitMultiRegionAccessPointRoutes(\n  this: TOSBase,\n  input: SubmitMultiRegionAccessPointRoutesInput\n) {\n  const { routes, accountId, alias } = input;\n  const res = await this.fetch<SubmitMultiRegionAccessPointRoutesOutput>(\n    'PATCH',\n    '/mrap/routes',\n    {\n      alias,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {\n      Routes: routes,\n    }\n  );\n  return res;\n}\n\n\nexport interface BindAcceleratorWithMultiRegionAccessPointInput {\n  AccountId: string;\n  MultiRegionAccessPointAlias: string;\n  AcceleratorId: string;\n}\n\nexport interface BindAcceleratorWithMultiRegionAccessPointOutput {}\n\n/**\n * @private unstable method\n */\nexport async function bindAcceleratorWithMultiRegionAccessPoint(\n  this: TOSBase,\n  input: BindAcceleratorWithMultiRegionAccessPointInput\n) {\n  const { AccountId, MultiRegionAccessPointAlias, AcceleratorId } = input;\n\n  const res = await this.fetch<BindAcceleratorWithMultiRegionAccessPointOutput>(\n    'PUT',\n    `/accelerator/${AcceleratorId}/mrap/${MultiRegionAccessPointAlias}`,\n    {\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {},\n    {}\n  );\n  return res;\n}\n\nexport interface UnbindAcceleratorWithMultiRegionAccessPointInput {\n  AccountId: string;\n  MultiRegionAccessPointAlias: string;\n  AcceleratorId: string;\n}\n\nexport interface UnbindAcceleratorWithMultiRegionAccessPointOutput {}\n\n/**\n * @private unstable method\n */\nexport async function unbindAcceleratorWithMultiRegionAccessPoint(\n  this: TOSBase,\n  input: UnbindAcceleratorWithMultiRegionAccessPointInput\n) {\n  const { AccountId, MultiRegionAccessPointAlias, AcceleratorId } = input;\n\n  const res = await this.fetch<UnbindAcceleratorWithMultiRegionAccessPointOutput>(\n    'DELETE',\n    `/accelerator/${AcceleratorId}/mrap/${MultiRegionAccessPointAlias}`,\n    {\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {\n    },\n    {}\n  );\n\n  return res;\n}\n\nexport interface ListBindAccessPointForMultiRegionAcceleratorInput {\n  AccountId: string;\n  AcceleratorId: string;\n}\n\nexport interface ListBindAccessPointForMultiRegionAcceleratorOutput {\n  AccessPoints: Array<{ Alias: string; Endpoint: string }>\n}\n\n/**\n * @private unstable method\n */\nexport async function listBindAccessPointForMultiRegionAccelerator(\n  this: TOSBase,\n  input: ListBindAccessPointForMultiRegionAcceleratorInput\n) {\n  const { AccountId, AcceleratorId } = input;\n\n  const res = await this.fetch<ListBindAccessPointForMultiRegionAcceleratorOutput>(\n    'GET',\n    `/accelerator/${AcceleratorId}/mrap`,\n    {\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {\n    },\n    {}\n  );\n\n  return res;\n}","import TOSBase from '../base';\nimport {\n  CreateAccessPointInput,\n  CreateAccessPointOutput,\n  GetAccessPointInput,\n  GetAccessPointOutput,\n  DeleteAccessPointInput,\n  DeleteAccessPointOutput,\n  ListAccessPointsInput,\n  ListAccessPointsOutput,\n  BindAcceleratorWithAccessPointInput,\n  BindAcceleratorWithAccessPointOutput,\n  UnbindAcceleratorWithAccessPointInput,\n  UnbindAcceleratorWithAccessPointOutput,\n  ListBindAccessPointForAcceleratorInput,\n  ListBindAccessPointForAcceleratorOutput,\n} from './interface';\n\n/**\n * @private unstable method\n */\nexport async function createAccessPoint(\n  this: TOSBase,\n  input: CreateAccessPointInput\n) {\n  const { BucketAccountId, Name, AccountId, Bucket, NetworkOrigin, VpcId } = input;\n\n  const res = await this.fetch<CreateAccessPointOutput>(\n    'PUT',\n    `/accesspoint/${Name}`,\n    {\n      name: '',\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {\n      BucketAccountId,\n      Bucket,\n      NetworkOrigin,\n      VpcId,\n    },\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function getAccessPoint(\n  this: TOSBase,\n  input: GetAccessPointInput\n) {\n  const { Name, AccountId } = input;\n  const res = await this.fetch<GetAccessPointOutput>(\n    'GET',\n    `/accesspoint/${Name}`,\n    {\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function listAccessPoints(\n  this: TOSBase,\n  input: ListAccessPointsInput\n) {\n  const { AccountId, ...nextQuery } = input;\n  const res = await this.fetch<ListAccessPointsOutput>(\n    'GET',\n    '/accesspoint',\n    { ...nextQuery },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function deleteAccessPoint(\n  this: TOSBase,\n  input: DeleteAccessPointInput\n) {\n  const { Name, AccountId } = input;\n  const res = await this.fetch<DeleteAccessPointOutput>(\n    'DELETE',\n    `/accesspoint/${Name}`,\n    {\n    },\n    {\n      'x-tos-account-id': AccountId,\n    }\n  );\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function bindAcceleratorWithAccessPoint(\n  this: TOSBase,\n  input: BindAcceleratorWithAccessPointInput\n) {\n  const { AccountId, AcceleratorAccountId, AccessPointName, AcceleratorId } = input;\n\n  const res = await this.fetch<BindAcceleratorWithAccessPointOutput>(\n    'PUT',\n    `/accesspoint/${AccessPointName}/accelerator/${AcceleratorId}`,\n    {\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {\n      AcceleratorAccountId,\n    },\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function unbindAcceleratorWithAccessPoint(\n  this: TOSBase,\n  input: UnbindAcceleratorWithAccessPointInput\n) {\n  const { AccountId, AccessPointName, AcceleratorId } = input;\n\n  const res = await this.fetch<UnbindAcceleratorWithAccessPointOutput>(\n    'DELETE',\n    `/accesspoint/${AccessPointName}/accelerator/${AcceleratorId}`,\n    {\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {\n    },\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function listBindAccessPointForAccelerator(\n  this: TOSBase,\n  input: ListBindAccessPointForAcceleratorInput\n) {\n  const { AccountId, AcceleratorId, ...restQuery } = input;\n\n  const res = await this.fetch<ListBindAccessPointForAcceleratorOutput>(\n    'GET',\n    `/accelerator/${AcceleratorId}/accesspoint`,\n    {\n      ...restQuery,\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {\n    },\n    {}\n  );\n\n  return res;\n}\n\nexport * from './interface';\n","import TOSBase from '../base';\nimport {\n  PutAcceleratorInput,\n  PutAcceleratorOutput,\n  GetAcceleratorInput,\n  GetAcceleratorOutput,\n  DeleteAcceleratorInput,\n  DeleteAcceleratorOutput,\n  ListAcceleratorsInput,\n  ListAcceleratorsOutput,\n  ListAcceleratorAzsInput,\n  ListAcceleratorAzsOutput,\n  PutAcceleratorPrefetchJobInput,\n  PutAcceleratorPrefetchJobOutput,\n  GetAcceleratorPrefetchJobInput,\n  GetAcceleratorPrefetchJobOutput,\n  DeleteAcceleratorPrefetchJobInput,\n  DeleteAcceleratorPrefetchJobOutput,\n  ListAcceleratorPrefetchJobsInput,\n  ListAcceleratorPrefetchJobsOutput,\n  ListAcceleratorPrefetchJobRecordsInput,\n  ListAcceleratorPrefetchJobRecordsOutput\n} from './interface';\n\n/**\n * @private unstable method\n */\nexport async function putAccelerator(\n  this: TOSBase,\n  input: PutAcceleratorInput\n) {\n  const { AccountId, ...Accelerator } = input;\n\n  const res = await this.fetch<PutAcceleratorOutput>(\n    'POST',\n    '/accelerator',\n    {\n      name: '',\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {\n      ...Accelerator\n    },\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function getAccelerator(\n  this: TOSBase,\n  input: GetAcceleratorInput\n) {\n  const { Id, AccountId } = input;\n  const res = await this.fetch<GetAcceleratorOutput>(\n    'GET',\n    '/accelerator',\n    {\n      id: Id,\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function listAccelerators(\n  this: TOSBase,\n  input: ListAcceleratorsInput\n) {\n  const { AccountId, ...restQuery } = input;\n  const res = await this.fetch<ListAcceleratorsOutput>(\n    'GET',\n    '/accelerator',\n    { ...restQuery },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function deleteAccelerator(\n  this: TOSBase,\n  input: DeleteAcceleratorInput\n) {\n  const { Id, AccountId } = input;\n  const res = await this.fetch<DeleteAcceleratorOutput>(\n    'DELETE',\n    '/accelerator',\n    {\n      id: Id,\n    },\n    {\n      'x-tos-account-id': AccountId,\n    }\n  );\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function listAcceleratorAzs(\n  this: TOSBase,\n  input: ListAcceleratorAzsInput\n) {\n  const { AccountId, ...restQuery } = input;\n  const res = await this.fetch<ListAcceleratorAzsOutput>(\n    'GET',\n    '/accelerator/az',\n    { ...restQuery },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function putAcceleratorPrefetchJob(\n  this: TOSBase,\n  input: PutAcceleratorPrefetchJobInput\n) {\n  const { AccountId, ...restParams } = input;\n\n  const res = await this.fetch<PutAcceleratorPrefetchJobOutput>(\n    'POST',\n    '/accelerator/prefetchJob',\n    {\n      acceleratorId: restParams.AcceleratorId,\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {\n      ...restParams\n    },\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function getAcceleratorPrefetchJob(\n  this: TOSBase,\n  input: GetAcceleratorPrefetchJobInput\n) {\n  const { AccountId, JobId } = input;\n  const res = await this.fetch<GetAcceleratorPrefetchJobOutput>(\n    'GET',\n    '/accelerator/prefetchJob',\n    {\n      jobId: JobId,\n    },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function deleteAcceleratorPrefetchJob(\n  this: TOSBase,\n  input: DeleteAcceleratorPrefetchJobInput\n) {\n  const { JobId, AccountId } = input;\n  const res = await this.fetch<DeleteAcceleratorPrefetchJobOutput>(\n    'DELETE',\n    '/accelerator/prefetchJob',\n    {\n      jobId: JobId,\n    },\n    {\n      'x-tos-account-id': AccountId,\n    }\n  );\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function listAcceleratorPrefetchJobs(\n  this: TOSBase,\n  input: ListAcceleratorPrefetchJobsInput\n) {\n  const { AccountId, AcceleratorId, ...restQuery } = input;\n  const res = await this.fetch<ListAcceleratorPrefetchJobsOutput>(\n    'GET',\n    '/accelerator/prefetchJob',\n    { acceleratorId: AcceleratorId, ...restQuery },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n\n/**\n * @private unstable method\n */\nexport async function listAcceleratorPrefetchJobRecords(\n  this: TOSBase,\n  input: ListAcceleratorPrefetchJobRecordsInput\n) {\n  const { AccountId, JobId, ...restQuery } = input;\n  const res = await this.fetch<ListAcceleratorPrefetchJobRecordsOutput>(\n    'GET',\n    '/accelerator/prefetchRecord',\n    {  jobId: JobId, ...restQuery },\n    {\n      'x-tos-account-id': AccountId,\n    },\n    {},\n    {}\n  );\n\n  return res;\n}\n","import TOSBase from '../base';\nimport { MRAPMirrorBackRedirectPolicyType } from '../../TosExportEnum';\nimport { makeArrayProp } from '../../utils';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\nexport interface MirrorBackRule {\n  ID?: string;\n  Status: 'Enabled' | 'Disabled';\n  Condition?: {\n    HttpCode?: number[];\n    KeyPrefix?: string[];\n  };\n  Redirect?: {\n    RedirectPolicy: MRAPMirrorBackRedirectPolicyType;\n  };\n}\n\nexport interface PutMultiRegionAccessPointMirrorBackInput {\n  accountId: string;\n  alias: string;\n  rules: MirrorBackRule[];\n}\n\nexport interface PutMultiRegionAccessPointMirrorBackOutput {}\n\n/**\n * @private unstable method\n */\nexport const putMultiRegionAccessPointMirrorBack = async function (\n  this: TOSBase,\n  input: PutMultiRegionAccessPointMirrorBackInput\n) {\n  const { accountId, alias, rules } = input;\n\n  if (this.opts.enableOptimizeMethodBehavior && !rules.length) {\n    return deleteMultiRegionAccessPointMirrorBack.call(this, {\n      accountId,\n      alias,\n    });\n  }\n\n  const res = await this.fetch<PutMultiRegionAccessPointMirrorBackOutput>(\n    'PUT',\n    '/mrap/mirror',\n    {\n      alias,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {\n      Rules: rules,\n    },\n    {\n      handleResponse() {\n        return {};\n      },\n    }\n  );\n  return res;\n};\n\nexport interface GetMultiRegionAccessPointMirrorBackInput {\n  accountId: string;\n  alias: string;\n}\n\nexport interface GetMultiRegionAccessPointMirrorBackOutput {\n  Rules: MirrorBackRule[];\n}\n\n/**\n * @private unstable method\n */\nexport const getMultiRegionAccessPointMirrorBack = async function (\n  this: TOSBase,\n  input: GetMultiRegionAccessPointMirrorBackInput\n) {\n  const { accountId, alias } = input;\n  try {\n    const res = await this.fetch<GetMultiRegionAccessPointMirrorBackOutput>(\n      'GET',\n      '/mrap/mirror',\n      {\n        alias,\n      },\n      {\n        'x-tos-account-id': accountId,\n      },\n      {},\n      {}\n    );\n    const arrayProp = makeArrayProp(res.data);\n    arrayProp('Rules');\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetMultiRegionAccessPointMirrorBackOutput>(\n      error,\n      {\n        enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n        methodKey: 'getMultiRegionAccessPointMirrorBack',\n        defaultResponse: {\n          Rules: [],\n        },\n      }\n    );\n  }\n};\n\nexport interface DeleteMultiRegionAccessPointMirrorBackInput {\n  accountId: string;\n  alias: string;\n}\nexport interface DeleteMultiRegionAccessPointMirrorBackOutput {}\n\n/**\n * @private unstable method\n */\nexport const deleteMultiRegionAccessPointMirrorBack = async function (\n  this: TOSBase,\n  input: DeleteMultiRegionAccessPointMirrorBackInput\n) {\n  const { accountId, alias } = input;\n  const res = await this.fetch<DeleteMultiRegionAccessPointMirrorBackOutput>(\n    'DELETE',\n    '/mrap/mirror',\n    {\n      alias,\n    },\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {\n      handleResponse() {\n        return {};\n      },\n    }\n  );\n  return res;\n};\n","import TOSBase from '../base';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\nexport interface PutBucketPrivateM3U8Input {\n  bucket: string;\n  enable: boolean;\n}\n\nexport interface PutPrivateM3U8Output {}\n\n/**\n * @private unstable\n */\nexport async function putBucketPrivateM3U8(\n  this: TOSBase,\n  input: PutBucketPrivateM3U8Input\n) {\n  const { bucket, enable } = input;\n  return await this.fetchBucket(\n    bucket,\n    'PUT',\n    {\n      privateM3U8: '',\n    },\n    {},\n    {\n      Enable: enable,\n    }\n  );\n}\n\nexport interface GetBucketPrivateM3U8Input {\n  bucket: string;\n}\n\nexport interface GetBucketPrivateM3U8Output {\n  Enable: boolean;\n}\n\n/**\n * @private unstable\n */\nexport async function getBucketPrivateM3U8(\n  this: TOSBase,\n  input: GetBucketPrivateM3U8Input\n) {\n  const { bucket } = input;\n  try {\n    return await this.fetchBucket<GetBucketPrivateM3U8Output>(\n      bucket,\n      'GET',\n      {\n        privateM3U8: '',\n      },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketPrivateM3U8',\n      defaultResponse: {\n        Enable: false,\n      },\n    });\n  }\n}\n\ninterface PutBucketBlindWatermarkInput {\n  bucket: string;\n  enable: boolean;\n}\n\n/**\n * @private unstable\n */\nexport async function putBucketBlindWatermark(\n  this: TOSBase,\n  input: PutBucketBlindWatermarkInput\n) {\n  const { bucket, enable } = input;\n  return await this.fetchBucket(\n    bucket,\n    'PUT',\n    {\n      blindWatermark: '',\n    },\n    {},\n    {\n      Enable: enable,\n    }\n  );\n}\n\nexport interface GetBucketBlindWatermarkInput {\n  bucket: string;\n}\n\nexport interface GetBucketBlindWatermarkOutput {\n  Enable: boolean;\n}\n\n/**\n * @private unstable\n */\nexport async function getBucketBlindWatermark(\n  this: TOSBase,\n  input: GetBucketBlindWatermarkInput\n) {\n  const { bucket } = input;\n  try {\n    return await this.fetchBucket<GetBucketBlindWatermarkOutput>(\n      bucket,\n      'GET',\n      {\n        blindWatermark: '',\n      },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketBlindWatermark',\n      defaultResponse: {\n        Enable: false,\n      },\n    });\n  }\n}\n","import { convertNormalCamelCase2Upper } from '../../utils';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'trash';\n\ninterface BucketTrash {\n  TrashPath: string;\n  CleanInterval: number;\n  Status: 'Enabled' | 'Disabled';\n  PrefixMatchRules?: Array<{\n    PrefixList: string[];\n    TrashPath: string;\n    CleanInterval: number;\n  }>\n}\n\nexport interface PutBucketTrashInput {\n  bucket?: string;\n  Trash: BucketTrash;\n}\n\nexport interface PutBucketTrashOutput {}\n\nexport async function putBucketTrash(\n  this: TOSBase,\n  input: PutBucketTrashInput\n) {\n  const { bucket, ...otherProps } = input;\n\n  const body = convertNormalCamelCase2Upper(otherProps);\n  return this.fetchBucket<PutBucketTrashOutput>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      ...body,\n    }\n  );\n}\n\nexport interface GetBucketTrashInput {\n  bucket?: string;\n}\n\nexport interface GetBucketTrashOutput {\n  Trash: BucketTrash;\n}\n\nexport async function getBucketTrash(\n  this: TOSBase,\n  input: GetBucketTrashInput\n) {\n  const { bucket } = input;\n  return await this.fetchBucket<GetBucketTrashOutput>(\n    bucket,\n    'GET',\n    { [CommonQueryKey]: '' },\n    {}\n  );\n}\n","import TOSBase from '../base';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\ninterface DefaultRetention {\n  Days?: number;\n  Years?: number;\n  Mode: 'COMPLIANCE';\n}\n\ninterface BucketObjectLockRule {\n  DefaultRetention: DefaultRetention;\n}\n\nexport interface PutBucketObjectLockConfigurationInput {\n  bucket: string;\n  objectLockEnabled: 'Enabled';\n  rule?: BucketObjectLockRule;\n}\n\nexport interface PutBucketObjectLockConfigurationOutput {}\n\n/**\n * @private unstable method\n */\n\nexport async function putBucketObjectLockConfiguration(\n  this: TOSBase,\n  input: PutBucketObjectLockConfigurationInput\n) {\n  const { bucket, objectLockEnabled, rule } = input;\n  return this.fetchBucket<PutBucketObjectLockConfigurationOutput>(\n    bucket,\n    'PUT',\n    { 'object-lock': '' },\n    {},\n    {\n      ObjectLockEnabled: objectLockEnabled,\n      Rule: rule,\n    }\n  );\n}\n\nexport interface GetBucketObjectLockConfigurationInput {\n  bucket: string;\n}\n\nexport interface GetBucketObjectLockConfigurationOutput {\n  ObjectLockEnabled?: 'Enabled';\n  Rule?: BucketObjectLockRule;\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketObjectLockConfiguration(\n  this: TOSBase,\n  input: GetBucketObjectLockConfigurationInput\n) {\n  const { bucket } = input;\n  try {\n    const res = await this.fetchBucket<GetBucketObjectLockConfigurationOutput>(\n      bucket,\n      'GET',\n      { 'object-lock': '' },\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetBucketObjectLockConfigurationOutput>(\n      error,\n      {\n        enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n        methodKey: 'getBucketObjectLockConfiguration',\n        defaultResponse: {},\n      }\n    );\n  }\n}\n","import TOSBase from '../base';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\nexport interface PutObjectRetentionInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n  mode: 'COMPLIANCE';\n  retainUntilDate: string;\n}\n\nexport interface PutObjectRetentionOutput {}\n\n/**\n * @private unstable method\n */\nexport async function putObjectRetention(\n  this: TOSBase,\n  input: PutObjectRetentionInput\n) {\n  const { versionId, mode, retainUntilDate } = input;\n  const query: Record<string, any> = { retention: '' };\n  if (versionId) {\n    query.versionId = versionId;\n  }\n  return this._fetchObject<PutObjectRetentionOutput>(\n    input,\n    'PUT',\n    query,\n    {},\n    {\n      Mode: mode,\n      RetainUntilDate: retainUntilDate,\n    }\n  );\n}\n\nexport interface GetObjectRetentionInput {\n  bucket?: string;\n  key: string;\n  versionId?: string;\n}\n\nexport interface GetObjectRetentionOutput {\n  Mode?: string;\n  RetainUntilDate?: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function getObjectRetention(\n  this: TOSBase,\n  input: GetObjectRetentionInput\n) {\n  const { versionId } = input;\n  const query: Record<string, any> = { retention: '' };\n  if (versionId) {\n    query.versionId = versionId;\n  }\n  try {\n    const res = await this._fetchObject<GetObjectRetentionOutput>(\n      input,\n      'GET',\n      query,\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetObjectRetentionOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getObjectRetention',\n      defaultResponse: {},\n    });\n  }\n}\n","import TOSBase from '../base';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\ninterface FilterRule {\n  Name?: string;\n  Value?: string;\n}\n\nexport interface CdnNotificationRule {\n  RuleId?: string;\n  CustomDomain: string;\n  Events: string[];\n  Filter?: {\n    TOSKey?: {\n      FilterRules: FilterRule[];\n    };\n  };\n}\n\nexport interface PutBucketCdnNotificationInput {\n  role: string;\n  bucket: string;\n  rules: CdnNotificationRule[];\n}\n\nexport interface PutBucketCdnNotificationOutput {}\n\n/**\n * @private unstable method\n */\nexport async function putBucketCdnNotification(\n  this: TOSBase,\n  input: PutBucketCdnNotificationInput\n) {\n  const { bucket, role, rules } = input;\n\n  if (this.opts.enableOptimizeMethodBehavior && !rules.length) {\n    return deleteBucketCdnNotification.call(this, {\n      bucket,\n    });\n  }\n\n  return this.fetchBucket<PutBucketCdnNotificationOutput>(\n    bucket,\n    'PUT',\n    {\n      cdn_notification: '',\n    },\n    {},\n    {\n      Role: role,\n      Rules: rules,\n    }\n  );\n}\n\nexport interface GetBucketCdnNotificationInput {\n  bucket: string;\n}\n\nexport interface GetBucketCdnNotificationOutput {\n  Role: string;\n  Rules: CdnNotificationRule[];\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketCdnNotification(\n  this: TOSBase,\n  input: GetBucketCdnNotificationInput\n) {\n  const { bucket } = input;\n  try {\n    return await this.fetchBucket<GetBucketCdnNotificationOutput>(\n      bucket,\n      'GET',\n      {\n        cdn_notification: '',\n      },\n      {}\n    );\n  } catch (error) {\n    return handleEmptyServerError<GetBucketCdnNotificationOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketCdnNotification',\n      defaultResponse: {\n        Rules: [],\n        Role: '',\n      },\n    });\n  }\n}\n\nexport interface DeleteBucketCdnNotificationInput {\n  bucket: string;\n}\n\nexport interface DeleteBucketCdnNotificationOutput {}\n\n/**\n * @private unstable method\n */\nexport async function deleteBucketCdnNotification(\n  this: TOSBase,\n  input: DeleteBucketCdnNotificationInput\n) {\n  const { bucket } = input;\n  return await this.fetchBucket<DeleteBucketCdnNotificationOutput>(\n    bucket,\n    'DELETE',\n    {\n      cdn_notification: '',\n    },\n    {}\n  );\n}\n","import TOSBase from '../base';\nimport { WorkflowExecutionStateType } from '../../TosExportEnum';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\nexport interface ObjectExtFilter {\n  AudioExts?: string[];\n}\n\nexport interface Output {\n  Region: string;\n  Bucket: string;\n  Object: string;\n}\n\nexport interface AudioTranscode {\n  OperationID: string;\n  Format: string;\n  Bitrate?: number;\n  Output: Output;\n}\n\nexport interface Operations {\n  AudioTranscode?: AudioTranscode[];\n}\n\nexport interface PutBucketWorkflowInput {\n  bucket?: string;\n  role: string;\n  rules: WorkflowItem[];\n}\n\nexport interface PutBucketWorkflowOutput {}\n\n/**\n * @private unstable method\n */\nexport async function putBucketWorkflow(\n  this: TOSBase,\n  input: PutBucketWorkflowInput\n) {\n  const { bucket, role, rules } = input;\n\n  if (this.opts.enableOptimizeMethodBehavior && !rules.length) {\n    return deleteBucketWorkflow.call(this, { bucket });\n  }\n\n  return this.fetchBucket<PutBucketWorkflowOutput>(\n    bucket,\n    'PUT',\n    {\n      workflow: '',\n    },\n    {},\n    {\n      Role: role,\n      Rules: rules,\n    }\n  );\n}\n\nexport interface WorkflowItem {\n  ID: string;\n  Enabled: boolean;\n  Prefix?: string;\n  ExtFilter?: ObjectExtFilter;\n  Topology: string[][];\n  Operations: Operations;\n}\n\nexport interface GetBucketWorkflowInput {\n  bucket?: string;\n}\n\nexport interface GetBucketWorkflowOutput {\n  Rules: WorkflowItem[];\n}\n\n/**\n * @private unstable method\n */\nexport async function getBucketWorkflow(\n  this: TOSBase,\n  input: GetBucketWorkflowInput\n) {\n  const { bucket } = input;\n  try {\n    const res = await this.fetchBucket<GetBucketWorkflowOutput>(\n      bucket,\n      'GET',\n      {\n        workflow: '',\n      },\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetBucketWorkflowOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketWorkflow',\n      defaultResponse: {\n        Rules: [],\n      },\n    });\n  }\n}\n\nexport interface ListBucketWorkflowInput {\n  bucket?: string;\n  pageSize: number;\n  pageToken?: string;\n}\n\nexport interface ListBucketWorkflowOutput {\n  WorkflowItems: WorkflowItem[];\n  NextPageToken?: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function listBucketWorkflow(\n  this: TOSBase,\n  input: ListBucketWorkflowInput\n) {\n  const { bucket, pageSize, pageToken } = input;\n\n  try {\n    const res = await this.fetchBucket<ListBucketWorkflowOutput>(\n      bucket,\n      'GET',\n      {\n        workflow: '',\n        page_size: pageSize,\n        page_token: pageToken,\n      },\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<ListBucketWorkflowOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'listBucketWorkflow',\n      defaultResponse: { WorkflowItems: [] },\n    });\n  }\n}\n\nexport interface DeleteBucketWorkflowInput {\n  bucket?: string;\n}\nexport interface DeleteBucketWorkflowOutput {}\n\n/**\n * @private unstable method\n */\nexport async function deleteBucketWorkflow(\n  this: TOSBase,\n  input: DeleteBucketWorkflowInput\n) {\n  const { bucket } = input;\n  const res = await this.fetchBucket<DeleteBucketWorkflowOutput>(\n    bucket,\n    'DELETE',\n    {\n      workflow: '',\n    },\n    {}\n  );\n  if (!res.data) {\n    res.data = {};\n  }\n  return res;\n}\n\nexport interface WorkflowExecutionTaskItem {\n  Type: string;\n  JobID: string;\n  OperationID: string;\n  State?: WorkflowExecutionStateType;\n  CreateTime: string;\n  StartTime: string;\n  EndTime: string;\n  Code: number;\n  Message?: string;\n}\n\nexport interface WorkflowExecutionItem {\n  ExecutionID: string;\n  RequestID: string;\n  Object: string[];\n  State?: WorkflowExecutionStateType;\n  Workflow: WorkflowItem;\n  Tasks: WorkflowExecutionTaskItem[];\n  StartTime: string;\n  CreateTime: string;\n  EndTime: string;\n}\n\nexport interface GetBucketWorkflowExecutionInput {\n  bucket?: string;\n  executionId: string;\n}\n\nexport type GetBucketWorkflowExecutionOutput = WorkflowExecutionItem | null\n\n/**\n * @private unstable method\n */\n\nexport async function getBucketWorkflowExecution(\n  this: TOSBase,\n  input: GetBucketWorkflowExecutionInput\n) {\n  const { bucket, executionId } = input;\n  try {\n    const res = await this.fetchBucket<WorkflowExecutionItem>(\n      bucket,\n      'GET',\n      {\n        workflow_execution: '',\n        id: executionId,\n      },\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetBucketWorkflowExecutionOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketWorkflowExecution',\n      defaultResponse: null,\n    });\n  }\n}\n\nexport interface ListBucketWorkflowExecutionInput {\n  bucket?: string;\n  workflowId?: string;\n  startTime?: number;\n  endTime?: number;\n  states?: WorkflowExecutionStateType;\n  orderByTime?: 'asc' | 'desc';\n  pageSize?: number;\n  pageToken?: string;\n}\n\nexport interface ListBucketWorkflowExecutionOutput {\n  Items: WorkflowExecutionItem[];\n  NextPageToken?: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function listBucketWorkflowExecution(\n  this: TOSBase,\n  input: ListBucketWorkflowExecutionInput\n) {\n  const {\n    bucket,\n    workflowId,\n    startTime,\n    endTime,\n    states,\n    orderByTime,\n    pageSize,\n    pageToken,\n  } = input;\n  try {\n    const query: Record<string, string> = {\n      workflow_execution: '',\n    };\n\n    if (workflowId) {\n      query['workflow_id'] = workflowId;\n    }\n\n    if (startTime !== undefined) {\n      query['start_time'] = startTime.toString();\n    }\n\n    if (endTime !== undefined) {\n      query['end_time'] = endTime.toString();\n    }\n\n    if (states) {\n      query['states'] = states;\n    }\n\n    if (orderByTime) {\n      query['order_by_time'] = orderByTime;\n    }\n\n    if (pageSize !== undefined) {\n      query['page_size'] = pageSize.toString();\n    }\n\n    if (pageToken) {\n      query['page_token'] = pageToken;\n    }\n\n    const res = await this.fetchBucket<ListBucketWorkflowExecutionOutput>(\n      bucket,\n      'GET',\n      query,\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<ListBucketWorkflowExecutionOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'listBucketWorkflowExecution',\n      defaultResponse: {\n        Items: [],\n      },\n    });\n  }\n}\n","import TOSBase, { TosResponse } from '../base';\nimport { FileCompressFlatten } from '../../TosExportEnum'; // \n\nexport interface CreateFileCompressInput {\n  bucket: string;\n  Input: {\n    Prefix?: string;\n    KeyConfig?: { Key: string }[];\n  };\n  FileCompressConfig: {\n    //only support zip\n    Format: string;\n    Flatten: FileCompressFlatten | number;\n  };\n  Output: {\n    Region: string;\n    Bucket: string;\n    Object: string;\n  };\n}\n\nexport interface CreateFileCompressOutput {\n  Code: string;\n  Message: string;\n  JobId: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function createFileCompress(\n  this: TOSBase,\n  req: CreateFileCompressInput\n): Promise<TosResponse<CreateFileCompressOutput>> {\n  const { bucket, Input, FileCompressConfig, Output } = req;\n  const res = await this.fetchBucket<CreateFileCompressOutput>(\n    bucket,\n    'POST',\n    {\n      file_jobs: '',\n      job_type: 'FileCompress',\n    },\n    {},\n    { Input, FileCompressConfig, Output }\n  );\n  return res;\n}\n","import TosServerError from '../../TosServerError';\nimport TOSBase, { TosResponse } from '../base';\nimport { FileUncompressPrefixReplaced } from '../../TosExportEnum'; // \n\nexport interface CreateFileUncompressInput {\n  bucket: string;\n  Input: {\n    Object: string;\n  };\n  FileUncompressConfig: {\n    Prefix: string;\n    /**\n     * @default 0 FileUncompressPrefixReplaced.NoExtraPrefix\n     */\n    PrefixReplaced?: FileUncompressPrefixReplaced | number;\n  };\n  Output: {\n    Region: string;\n    Bucket: string;\n  };\n}\n\nexport interface CreateFileUncompressOutput {\n  Code: string;\n  Message: string;\n  JobId: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function createFileUncompress(\n  this: TOSBase,\n  req: CreateFileUncompressInput\n): Promise<TosResponse<CreateFileUncompressOutput>> {\n  const { bucket, Input, FileUncompressConfig, Output } = req;\n  const res = await this.fetchBucket<CreateFileUncompressOutput>(\n    bucket,\n    'POST',\n    {\n      file_jobs: '',\n      job_type: 'FileUncompress',\n    },\n    {},\n    { Input, FileUncompressConfig, Output }\n  );\n  return res;\n}\n","import { handleEmptyServerError } from '../../handleEmptyServerError';\nimport TOSBase, { TosResponse } from '../base';\n\nexport interface BucketLoggingData {\n  targetBucket: string;\n  targetPrefix?: string;\n  role?: string;\n}\n\nexport interface PutBucketLoggingInput {\n  bucket: string;\n  data: BucketLoggingData;\n}\n\nexport interface PutBucketLoggingOutput {}\n\nexport interface GetBucketLoggingInput {\n  bucket: string;\n}\nexport type GetBucketLoggingOutput =\n  | {\n      LoggingEnabled: {\n        TargetBucket: string;\n        TargetPrefix?: string;\n        Role?: string;\n      } | null;\n    }\n  | undefined;\n\n/**\n * @private unstable method\n * \n */\nexport async function getBucketLogging(\n  this: TOSBase,\n  req: GetBucketLoggingInput\n): Promise<TosResponse<GetBucketLoggingOutput>> {\n  try {\n    const res = await this.fetchBucket<GetBucketLoggingOutput>(\n      req.bucket,\n      'GET',\n      {\n        logging: '',\n      },\n      {}\n    );\n\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetBucketLoggingOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketLogging',\n      defaultResponse: undefined,\n    });\n  }\n}\n\n/**\n * @private unstable method\n */\nexport function putBucketLogging(\n  this: TOSBase,\n  req: PutBucketLoggingInput\n): Promise<TosResponse<PutBucketLoggingOutput>> {\n  return this.fetchBucket(\n    req.bucket,\n    'PUT',\n    { logging: '' },\n    {},\n    {\n      LoggingEnabled: {\n        TargetBucket: req.data.targetBucket,\n        TargetPrefix: req.data.targetPrefix,\n        Role: req.data.role,\n      },\n    }\n  );\n}\n\n/**\n * @private unstable method\n */\nexport function deleteBucketLogging(\n  this: TOSBase,\n  req: GetBucketLoggingInput\n): Promise<TosResponse<PutBucketLoggingOutput>> {\n  return this.fetchBucket(req.bucket, 'PUT', { logging: '' }, {}, {});\n}\n","import TOSBase, { TosResponse } from '../base';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\nexport interface StatementItem {\n  Sid: string;\n  Effect: 'Allow' | 'Deny';\n  Action?: string | string[];\n  NotAction?: string | string[];\n  Condition?: {\n    [key in string]: {\n      [key in string]: string[];\n    };\n  };\n  Principal?: string[];\n  NotPrincipal?: string[];\n  Resource?: string | string[];\n  NotResource?: string | string[];\n}\n\nexport interface Policy {\n  Version?: string;\n  Statement: StatementItem[];\n}\n\nexport interface PutAccessPointPolicyInput {\n  accountId: string;\n  name: string;\n  policy: Policy;\n}\n\nexport interface PutAccessPointPolicyOutput {}\n\n/**\n * @private unstable method\n */\n\nexport async function putAccessPointPolicy(\n  this: TOSBase,\n  input: PutAccessPointPolicyInput\n) {\n  const { accountId, name, policy } = input;\n  if (this.opts.enableOptimizeMethodBehavior && !policy.Statement?.length) {\n    return deleteAccessPointPolicy.call(this, {\n      accountId,\n      name,\n    });\n  }\n\n  return this.fetch<PutAccessPointPolicyOutput>(\n    'PUT',\n    `/accesspoint/${name}/policy`,\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    policy\n  );\n}\n\nexport interface GetAccessPointPolicyInput {\n  accountId: string;\n  name: string;\n}\n\nexport interface GetAccessPointPolicyOutput {\n  Policy: Policy;\n}\n\n/**\n * @private unstable method\n */\n\nexport async function getAccessPointPolicy(\n  this: TOSBase,\n  input: GetAccessPointPolicyInput\n): Promise<TosResponse<GetAccessPointPolicyOutput>> {\n  const { accountId, name } = input;\n  try {\n    const res = await this.fetch(\n      'GET',\n      `/accesspoint/${name}/policy`,\n      {},\n      {\n        'x-tos-account-id': accountId,\n      },\n      undefined,\n      {\n        handleResponse(response) {\n          return {\n            Policy: response.data,\n          };\n        },\n      }\n    );\n    return res as TosResponse<GetAccessPointPolicyOutput>;\n  } catch (error) {\n    return handleEmptyServerError<GetAccessPointPolicyOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getAccessPointPolicy',\n      defaultResponse: {\n        Policy: {\n          Version: '2012-10-17',\n          Statement: [],\n        },\n      },\n    });\n  }\n}\n\nexport interface DeleteAccessPointPolicyInput {\n  accountId: string;\n  name: string;\n}\n\nexport interface DeleteAccessPointPolicyOutput {}\n\n/**\n * @private unstable method\n */\n\nexport async function deleteAccessPointPolicy(\n  this: TOSBase,\n  input: DeleteAccessPointPolicyInput\n) {\n  const { accountId, name } = input;\n  return this.fetch<DeleteAccessPointPolicyOutput>(\n    'DELETE',\n    `/accesspoint/${name}/policy`,\n    {},\n    {\n      'x-tos-account-id': accountId,\n    }\n  );\n}\n\nexport interface PutMultiRegionAccessPointPolicyInput {\n  accountId: string;\n  name: string;\n  policy: Policy;\n}\n\nexport interface PutMultiRegionAccessPointPolicyOutput {}\n\n/**\n * @private unstable method\n */\n\nexport async function putMultiRegionAccessPointPolicy(\n  this: TOSBase,\n  input: PutMultiRegionAccessPointPolicyInput\n) {\n  const { accountId, name, policy } = input;\n  if (this.opts.enableOptimizeMethodBehavior && !policy.Statement?.length) {\n    return deleteMultiRegionAccessPointPolicy.call(this, {\n      accountId,\n      name,\n    });\n  }\n\n  const res = await this.fetch<PutMultiRegionAccessPointPolicyOutput>(\n    'PUT',\n    `/mrap/${name}/policy`,\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    policy,\n    {}\n  );\n\n  return res;\n}\n\nexport interface GetMultiRegionAccessPointPolicyInput {\n  accountId: string;\n  name: string;\n}\n\nexport interface GetMultiRegionAccessPointPolicyOutput {\n  Policy: Policy;\n}\n\n/**\n * @private unstable method\n */\n\nexport async function getMultiRegionAccessPointPolicy(\n  this: TOSBase,\n  input: GetMultiRegionAccessPointPolicyInput\n): Promise<TosResponse<GetMultiRegionAccessPointPolicyOutput>> {\n  const { accountId, name } = input;\n  try {\n    const res = await this.fetch(\n      'GET',\n      `/mrap/${name}/policy`,\n      {},\n      {\n        'x-tos-account-id': accountId,\n      },\n      undefined,\n      {\n        handleResponse(response) {\n          return {\n            Policy: response.data,\n          };\n        },\n      }\n    );\n    return res as TosResponse<GetMultiRegionAccessPointPolicyOutput>;\n  } catch (error) {\n    return handleEmptyServerError<GetMultiRegionAccessPointPolicyOutput>(\n      error,\n      {\n        enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n        methodKey: 'getMultiRegionAccessPointMirrorBack',\n        defaultResponse: {\n          Policy: {\n            Version: '2012-10-17',\n            Statement: [],\n          },\n        },\n      }\n    );\n  }\n}\n\nexport interface DeleteMultiRegionAccessPointPolicyInput {\n  accountId: string;\n  name: string;\n}\n\nexport interface DeleteMultiRegionAccessPointPolicyOutput {}\n\n/**\n * @private unstable method\n */\n\nexport async function deleteMultiRegionAccessPointPolicy(\n  this: TOSBase,\n  input: DeleteMultiRegionAccessPointPolicyInput\n) {\n  const { accountId, name } = input;\n  const res = await this.fetch<DeleteMultiRegionAccessPointPolicyOutput>(\n    'DELETE',\n    `/mrap/${name}/policy`,\n    {},\n    {\n      'x-tos-account-id': accountId,\n    },\n    {},\n    {\n      handleResponse() {\n        return {};\n      },\n    }\n  );\n  return res;\n}\n","import { handleEmptyServerError } from '../../handleEmptyServerError';\nimport { AuditJobStateType, AuditScanType } from '../../TosExportEnum';\nimport TOSBase from '../base';\n\nexport interface GetBucketAuditInput {\n  bucket: string;\n}\n\nexport interface GetBucketAuditOutputBody {\n  TosAuditConfig: {\n    /**  */\n    Enable: boolean;\n    /** bucket  APP Name */\n    AppName: string;\n    /** bucket  APP ID */\n    AppId: number;\n    /** bucket  APP  */\n    AppNameZh: string;\n    AppType: string;\n    /**  */\n    Description: string;\n  };\n  /** 0  Inactive 1  Activating2  ActivationFailed3  Active */\n  ServiceAppStatus: number;\n  /**  */\n  ServiceAppStatusMessage: string;\n}\n\nexport type GetBucketAuditOutput = GetBucketAuditOutputBody | null;\n\n/**\n * @private unstable method\n */\nexport async function getBucketAudit(\n  this: TOSBase,\n  input: GetBucketAuditInput\n) {\n  const { bucket } = input;\n  try {\n    return await this.fetchBucket<GetBucketAuditOutput>(\n      bucket,\n      'GET',\n      {\n        audit: '',\n      },\n      {}\n    );\n  } catch (err) {\n    return handleEmptyServerError<GetBucketAuditOutput>(err, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketAudit',\n      defaultResponse: null,\n    });\n  }\n}\n\nexport interface PutBucketAuditInput {\n  bucket: string;\n  action: 'create' | 'enable' | 'disable' | 'retry';\n}\nexport interface PutBucketAuditOutput {}\n\n/**\n * @private unstable method\n */\nexport async function putBucketAudit(\n  this: TOSBase,\n  input: PutBucketAuditInput\n) {\n  const { bucket, action } = input;\n  return await this.fetchBucket<GetBucketAuditOutput>(\n    bucket,\n    'PUT',\n    {\n      action,\n      audit: '',\n    },\n    {}\n  );\n}\n\nexport interface ImageAudit {\n  Suffix?: string[];\n  BizType: string;\n  PerDayLimit?: number;\n}\n\nexport interface VideoAudit {\n  Suffix?: string[];\n  BizType: string;\n  Interval?: number;\n  PerDayLimit?: number;\n  ResultType?: number;\n}\n\nexport interface AudioAudit {\n  Suffix?: string[];\n  BizType: string;\n  PerDayLimit?: number;\n  ResultType?: number;\n}\n\nexport interface ScanConf {\n  Objects?: string[];\n  Type: AuditScanType;\n  ManifestURL?: string[];\n  ObjectPrefixAllowed?: string[];\n  ObjectPrefixDenied?: string[];\n  TimestampStart?: number;\n  TimestampEnd?: number;\n}\n\nexport interface AuditItem {\n  JobID: string;\n  State: AuditJobStateType;\n  CreateTime: string;\n  StartTime: string;\n  EndTime: string;\n  Error?: string;\n  Code?: number;\n  Message?: string;\n  ImageAudit?: ImageAudit;\n  VideoAudit?: VideoAudit;\n  AudioAudit?: AudioAudit;\n  ScanConf: ScanConf;\n}\n\nexport interface ListBucketAuditJobInput {\n  bucket: string;\n  /**\n   * Used to filter the start time of the job, unix timestamp.\n   */\n  startTime?: number;\n  /**\n   * Used to filter the end time of the job, unix timestamp.\n   */\n  endTime?: number;\n  /**\n   * The size of pagination, maximum 100? TODO\n   */\n  pageSize: number;\n  /**\n   * The starting token for pagination.\n   */\n  pageToken?: string;\n}\n\nexport interface ListBucketAuditJobOutput {\n  Items: AuditItem[];\n  NextPageToken?: string;\n  JobType: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function listBucketAuditJob(\n  this: TOSBase,\n  input: ListBucketAuditJobInput\n) {\n  const { bucket, startTime, endTime, pageSize, pageToken } = input;\n  const query: Record<string, string> = {\n    job_type: 'AuditStock',\n  };\n\n  if (startTime !== undefined) {\n    query['start_time'] = startTime.toString();\n  }\n  if (endTime !== undefined) {\n    query['end_time'] = endTime.toString();\n  }\n  if (pageSize !== undefined) {\n    query['page_size'] = pageSize.toString();\n  }\n  if (pageToken !== undefined) {\n    query['page_token'] = pageToken;\n  }\n\n  const res = await this.fetchBucket<ListBucketAuditJobOutput>(\n    bucket,\n    'GET',\n    query,\n    {}\n  );\n  return res;\n}\n\nexport interface GetBucketAuditJobInput {\n  bucket: string;\n  jobId: string;\n}\nexport type GetBucketAuditJobOutput = AuditItem | null;\n\n/**\n * @private unstable method\n */\nexport async function getBucketAuditJob(\n  this: TOSBase,\n  input: GetBucketAuditJobInput\n) {\n  const { bucket, jobId } = input;\n  try {\n    const res = await this.fetchBucket<GetBucketAuditJobOutput>(\n      bucket,\n      'GET',\n      {\n        job_type: 'AuditStock',\n        job_id: jobId,\n      },\n      {}\n    );\n    return res;\n  } catch (e) {\n    return handleEmptyServerError<GetBucketAuditJobOutput>(e, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketAuditJob',\n      defaultResponse: null,\n    });\n  }\n}\n\nexport interface PostBucketAuditJobInput {\n  bucket: string;\n  job: {\n    ImageAudit?: ImageAudit;\n    VideoAudit?: VideoAudit;\n    AudioAudit?: AudioAudit;\n    ScanConf: ScanConf;\n  };\n}\n\nexport interface PostBucketAuditJobOutput {}\n/**\n * @private unstable method\n */\nexport async function postBucketAuditJob(\n  this: TOSBase,\n  input: PostBucketAuditJobInput\n) {\n  const { bucket, job } = input;\n  const res = await this.fetchBucket<PostBucketAuditJobOutput>(\n    bucket,\n    'POST',\n    {\n      job_type: 'AuditStock',\n      audit_jobs: '',\n    },\n    {},\n    job\n  );\n  return res;\n}\n\ninterface ConfigItem {\n  Name: string;\n  BizType: number;\n  Scene: string;\n  SceneText: string;\n  LabelTexts: string[];\n  Labels: string;\n}\n\nexport interface ListBucketAuditBizTypeOutput {\n  BizType: string;\n  Configs: ConfigItem[];\n}\n\nexport interface ListBucketAuditBizTypeInput {\n  bucket: string;\n  audit_type: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function listBucketAuditBizType(\n  this: TOSBase,\n  input: ListBucketAuditBizTypeInput\n) {\n  const { bucket, audit_type } = input;\n  return this.fetchBucket<ListBucketAuditBizTypeOutput>(\n    bucket,\n    'GET',\n    {\n      type: audit_type,\n      audits: '',\n    },\n    {}\n  );\n}\n","import {\n  FileCompressFlatten,\n  FileUncompressPrefixReplaced,\n} from '../../TosExportEnum';\nimport { TOSBase } from '../base';\nimport { UnionToIntersection, MergeExclusive } from 'type-fest';\nimport { handleEmptyServerError } from '../../handleEmptyServerError';\n\nexport interface ListBucketJobInput {\n  bucket?: string;\n  jobType: string;\n  startTime?: number;\n  endTime?: number;\n  pageSize?: number;\n  pageToken?: string;\n}\n\nexport interface AudioConvertConfig {\n  ContainerFormat?: string;\n  BitRate?: number;\n}\n\nexport interface AudioJobItem {\n  JobID: string;\n  CreateTime: string;\n  StartTime: string;\n  EndTime: string;\n  State: string;\n  Code: number;\n  Message?: string;\n  Tag: string;\n  Input: {\n    BucketId: string;\n    Object: string;\n    Region: string;\n  };\n  Operation: {\n    Output: {\n      // \n      Bucket: string;\n      Object: string;\n      Region: string;\n    };\n  };\n  AudioConvertConfig?: AudioConvertConfig;\n  Output: {\n    // \n    Bucket: string;\n    Object: string;\n    Region: string;\n  };\n}\n\nexport interface FileCompressJobItem {\n  JobID: string;\n  CreateTime: string;\n  StartTime: string;\n  EndTime: string;\n  State: string;\n  Code: number;\n  Error: string;\n  Message: string;\n  Input: MergeExclusive<\n    {\n      Prefix: string;\n    },\n    {\n      KeyConfig: Array<{ Key: string }>;\n    }\n  >;\n  Operation: {\n    FileCompressConfig: {\n      Flatten: FileCompressFlatten | number;\n      Format: string;\n    };\n    FileCompressResult: {\n      Bucket: string;\n      CompressFileCount: number;\n      ErrorCount: number;\n      ErrorDetail?: {\n        ErrorFile: any[];\n      };\n      Object: string;\n      Region: string;\n    };\n    Output: {\n      Bucket: string;\n      Object: string;\n      Region: string;\n    };\n  };\n  Tag: string;\n}\n\nexport interface FileUncompressJobItem {\n  JobID: string;\n  CreateTime: string;\n  StartTime: string;\n  EndTime: string;\n  State: string;\n  Code: number;\n  Message: string;\n  Error: string;\n  Input: {\n    Object: string;\n  };\n  Operation: {\n    FileUncompressConfig: {\n      Prefix: string;\n      /**\n       * @default 0 FileUncompressPrefixReplaced.NoExtraPrefix\n       */\n      PrefixReplaced?: FileUncompressPrefixReplaced | number;\n    };\n    FileUncompressResult: {\n      Bucket: string;\n      FileCount: number;\n      FileList: {\n        Contents: any[];\n        IsTruncated: boolean;\n      };\n      Region: string;\n    };\n    Output: {\n      Bucket: string;\n      Object: string;\n      Region: string;\n    };\n  };\n  Tag: string;\n}\n\nexport type BucketJobItem = UnionToIntersection<\n  AudioJobItem | FileCompressJobItem | FileUncompressJobItem\n>;\n\nexport interface ListBucketJobOutput {\n  Items: BucketJobItem[];\n  NextPageToken?: string;\n  JobType: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function listBucketJob(this: TOSBase, input: ListBucketJobInput) {\n  const { bucket, jobType, startTime, endTime, pageSize, pageToken } = input;\n  const query: Record<string, string> = {\n    job_type: jobType,\n  };\n  if (startTime !== undefined) {\n    query['start_time'] = startTime.toString();\n  }\n\n  if (endTime !== undefined) {\n    query['end_time'] = endTime.toString();\n  }\n\n  if (pageSize !== undefined) {\n    query['page_size'] = pageSize.toString();\n  }\n\n  if (pageToken !== undefined) {\n    query['page_token'] = pageToken;\n  }\n\n  const res = await this.fetchBucket<ListBucketJobOutput>(\n    bucket,\n    'GET',\n    query,\n    {}\n  );\n  return res;\n}\n\nexport interface GetBucketJobInput {\n  bucket?: string;\n  jobType: string;\n  jobId: string;\n}\n\nexport type GetBucketJobOutput = BucketJobItem | null;\n\n/**\n * @private unstable method\n */\nexport async function getBucketJob(this: TOSBase, input: GetBucketJobInput) {\n  const { bucket, jobType, jobId } = input;\n  try {\n    const res = await this.fetchBucket<GetBucketJobOutput>(\n      bucket,\n      'GET',\n      {\n        job_type: jobType,\n        job_id: jobId,\n      },\n      {}\n    );\n    return res;\n  } catch (error) {\n    return handleEmptyServerError<GetBucketJobOutput>(error, {\n      enableCatchEmptyServerError: this.opts.enableOptimizeMethodBehavior,\n      methodKey: 'getBucketJob',\n      defaultResponse: null,\n    });\n  }\n}\n","import TOSBase from '../base';\n\nexport interface createBucketAudioConvertInput {\n  bucket: string;\n  Input: {\n    Object: string;\n  };\n  AudioConvertConfig: {\n    ContainerFormat: string; // \n    BitRate: number;\n  };\n  Output: {\n    Region: string;\n    Bucket: string;\n    Object: string;\n  };\n}\n\nexport interface createBucketAudioConvertOutput {}\n\n/**\n * @private unstable method\n */\nexport async function createBucketAudioConvert(\n  this: TOSBase,\n  input: createBucketAudioConvertInput\n) {\n  const { bucket, Input, Output, AudioConvertConfig } = input;\n  const res = await this.fetchBucket<createBucketAudioConvertOutput>(\n    bucket,\n    'POST',\n    { job_type: 'AudioConvert', media_jobs: '' },\n    {},\n    { Input, AudioConvertConfig, Output }\n  );\n\n  if (!res.data) {\n    res.data = {};\n  }\n\n  return res;\n}\n","import { makeArrayProp, normalizeHeadersKey } from \"../../utils\";\nimport TOSBase, { TosResponse } from \"../base\";\n\nexport interface GetObjectAITagInput {\n  bucket: string;\n  key: string;\n  versionId?: string;\n}\n\nexport interface GetObjectAITagOutput {\n  Confidence: number;\n  FirstCategory: string;\n  I18nFirstCategory: string;\n  SecondCategory: string;\n  I18nSecondCategory: string;\n  Tag: string;\n  I18nTag: string;\n  TagDescription: string;\n}\n\n/**\n * @private unstable method\n */\nexport async function getObjectAITag(\n  this: TOSBase,\n  input: GetObjectAITagInput\n): Promise<TosResponse<GetObjectAITagOutput[]>> {\n  const { versionId } = input;\n  const headers = normalizeHeadersKey({\n    versionId,\n  });\n  const res = await this._fetchObject<any>(\n    input,\n    'GET',\n    { ['x-tos-process']: 'image/aitag', ...headers },\n    {}\n  );\n  makeArrayProp(res.data);\n  return res;\n}\n","import { convertNormalCamelCase2Upper } from '../../utils';\nimport TOSBase from '../base';\n\nconst CommonQueryKey = 'requestPayment';\n\nexport interface PutBucketRequestPayment {\n  bucket?: string;\n  Payer: 'BucketOwner' | 'Requester';\n}\n\nexport interface PutBucketRequestPaymentOutput {}\n\n/**\n * @private unstable\n */\nexport async function putBucketRequestPayment(\n  this: TOSBase,\n  input: PutBucketRequestPayment\n) {\n  const { bucket, ...otherProps } = input;\n\n  const body = convertNormalCamelCase2Upper(otherProps);\n  return this.fetchBucket<PutBucketRequestPayment>(\n    bucket,\n    'PUT',\n    { [CommonQueryKey]: '' },\n    {},\n    {\n      ...body,\n    }\n  );\n}\n\nexport interface GetBucketRequestPaymentInput {\n  bucket?: string;\n}\n\nexport interface GetBucketRequestPaymentOutput {\n  Payer: 'BucketOwner' | 'Requester';\n}\n\n/**\n * @private unstable\n */\nexport async function getBucketRequestPayment(\n  this: TOSBase,\n  input: GetBucketRequestPaymentInput\n) {\n  const { bucket } = input;\n  return await this.fetchBucket<GetBucketRequestPaymentOutput>(\n    bucket,\n    'GET',\n    { [CommonQueryKey]: '' },\n    {}\n  );\n}\n","import TOSBase from './methods/base';\nimport {\n  listBuckets,\n  createBucket,\n  deleteBucket,\n  headBucket,\n  putBucketStorageClass,\n} from './methods/bucket/base';\nimport { getBucketAcl, putBucketAcl } from './methods/bucket/acl';\nimport {\n  getBucketHttpsConfig,\n  putBucketHttpsConfig,\n} from './methods/bucket/httpsConfig';\nimport {\n  getObject,\n  getObjectV2,\n  getObjectToFile,\n} from './methods/object/getObject';\nimport putObject, { putObjectFromFile } from './methods/object/putObject';\nimport { fetchObject, putFetchTask } from './methods/object/fetch';\nimport { listObjectVersions, listObjects } from './methods/object/listObjects';\nimport getPreSignedUrl from './methods/object/getPreSignedUrl';\nimport headObject from './methods/object/headObject';\nimport deleteObject from './methods/object/deleteObject';\nimport renameObject from './methods/object/renameObject';\nimport deleteMultiObjects from './methods/object/deleteMultiObjects';\nimport copyObject from './methods/object/copyObject';\nimport { getObjectAcl, putObjectAcl } from './methods/object/acl';\nimport {\n  abortMultipartUpload,\n  completeMultipartUpload,\n  createMultipartUpload,\n  listParts,\n  uploadPart,\n  listMultipartUploads,\n  uploadPartFromFile,\n} from './methods/object/multipart';\nimport appendObject from './methods/object/appendObject';\nimport setObjectMeta from './methods/object/setObjectMeta';\nimport { uploadPartCopy } from './methods/object/multipart/uploadPartCopy';\nimport uploadFile from './methods/object/multipart/uploadFile';\nimport { calculatePostSignature } from './methods/object/calculatePostSignature';\n\nimport { resumableCopyObject } from './methods/object/multipart/resumableCopyObject';\nimport {\n  deleteBucketPolicy,\n  getBucketPolicy,\n  putBucketPolicy,\n} from './methods/bucket/policy';\nimport {\n  getBucketVersioning,\n  putBucketVersioning,\n} from './methods/bucket/versioning';\nimport { preSignedPolicyURL } from './methods/object/preSignedPolicyURL';\nimport downloadFile from './methods/object/downloadFile';\nimport { getBucketLocation } from './methods/bucket/getBucketLocation';\nimport {\n  deleteBucketCORS,\n  getBucketCORS,\n  putBucketCORS,\n} from './methods/bucket/cors';\nimport { listObjectsType2 } from './methods/object/listObjectsType2';\nimport {\n  deleteBucketLifecycle,\n  getBucketLifecycle,\n  putBucketLifecycle,\n} from './methods/bucket/lifecycle';\nimport {\n  putBucketEncryption,\n  getBucketEncryption,\n  deleteBucketEncryption,\n} from './methods/bucket/encryption';\nimport {\n  deleteBucketMirrorBack,\n  getBucketMirrorBack,\n  putBucketMirrorBack,\n} from './methods/bucket/mirrorback';\nimport {\n  deleteObjectTagging,\n  getObjectTagging,\n  putObjectTagging,\n} from './methods/object/tagging';\nimport {\n  deleteBucketReplication,\n  getBucketReplication,\n  putBucketReplication,\n} from './methods/bucket/replication';\nimport {\n  deleteBucketWebsite,\n  getBucketWebsite,\n  putBucketWebsite,\n} from './methods/bucket/website';\nimport {\n  getBucketNotification,\n  putBucketNotification,\n} from './methods/bucket/notification';\nimport {\n  deleteBucketCustomDomain,\n  getBucketCustomDomain,\n  putBucketCustomDomain,\n} from './methods/bucket/customDomain';\nimport {\n  deleteBucketRealTimeLog,\n  getBucketRealTimeLog,\n  putBucketRealTimeLog,\n} from './methods/bucket/realTimeLog';\nimport {\n  deleteBucketInventory,\n  getBucketInventory,\n  listBucketInventory,\n  putBucketInventory,\n} from './methods/bucket/inventory';\nimport {\n  createJob,\n  deleteJob,\n  describeJob,\n  updateJobStatus,\n  updateJobPriority,\n  listJobs,\n} from './methods/batch';\nimport {\n  deleteBucketTagging,\n  getBucketTagging,\n  putBucketTagging,\n} from './methods/bucket/tag';\nimport {\n  getBucketPayByTraffic,\n  putBucketPayByTraffic,\n} from './methods/bucket/payByTraffic';\nimport {\n  getBucketImageStyle,\n  getBucketImageStyleList,\n  getBucketImageStyleListByName,\n  getImageStyleBriefInfo,\n  deleteBucketImageStyle,\n  putBucketImageStyle,\n  putBucketImageStyleSeparator,\n  putBucketImageProtect,\n  getBucketImageProtect,\n  getBucketImageStyleSeparator,\n} from './methods/bucket/img';\nimport { getBucketIntelligenttiering } from './methods/bucket/intelligenttiering';\nimport {\n  putBucketRename,\n  getBucketRename,\n  deleteBucketRename,\n} from './methods/bucket/rename';\nimport restoreObject from './methods/object/restoreObject';\nimport {\n  deleteStorageLens,\n  getStorageLens,\n  listStorageLens,\n  putStorageLens,\n} from './methods/storageLens';\nimport {\n  putBucketNotificationType2,\n  getBucketNotificationType2,\n} from './methods/bucket/notificationType2';\n\nimport putSymlink from './methods/object/putSymlink';\nimport getSymlink from './methods/object/getSymlink';\nimport {\n  getBucketTransferAcceleration,\n  putBucketTransferAcceleration,\n} from './methods/bucket/acceleration';\nimport {\n  getBucketAccessMonitor,\n  putBucketAccessMonitor,\n} from './methods/bucket/accessMonitor';\nimport {\n  getQosPolicy,\n  putQosPolicy,\n  deleteQosPolicy,\n} from './methods/qosPolicy';\nimport {\n  createMultiRegionAccessPoint,\n  getMultiRegionAccessPoint,\n  listMultiRegionAccessPoints,\n  getMultiRegionAccessPointRoutes,\n  deleteMultiRegionAccessPoint,\n  submitMultiRegionAccessPointRoutes,\n  listBindAccessPointForMultiRegionAccelerator,\n  bindAcceleratorWithMultiRegionAccessPoint,\n  unbindAcceleratorWithMultiRegionAccessPoint,\n} from './methods/mrap';\nimport {\n  createAccessPoint,\n  getAccessPoint,\n  listAccessPoints,\n  deleteAccessPoint,\n  listBindAccessPointForAccelerator,\n  bindAcceleratorWithAccessPoint,\n  unbindAcceleratorWithAccessPoint,\n} from './methods/accesspoint';\nimport {\n  putAccelerator,\n  getAccelerator,\n  deleteAccelerator,\n  listAccelerators,\n  listAcceleratorAzs,\n  putAcceleratorPrefetchJob,\n  getAcceleratorPrefetchJob,\n  deleteAcceleratorPrefetchJob,\n  listAcceleratorPrefetchJobs,\n  listAcceleratorPrefetchJobRecords,\n} from './methods/accelerator';\nimport {\n  putMultiRegionAccessPointMirrorBack,\n  getMultiRegionAccessPointMirrorBack,\n  deleteMultiRegionAccessPointMirrorBack,\n} from './methods/mrap/mirror';\nimport {\n  putBucketPrivateM3U8,\n  getBucketPrivateM3U8,\n  putBucketBlindWatermark,\n  getBucketBlindWatermark,\n} from './methods/bucket/media';\nimport { getBucketTrash, putBucketTrash } from './methods/bucket/trash';\nimport {\n  putBucketObjectLockConfiguration,\n  getBucketObjectLockConfiguration,\n} from './methods/bucket/lock';\nimport {\n  putObjectRetention,\n  getObjectRetention,\n} from './methods/object/retention';\nimport {\n  putBucketCdnNotification,\n  getBucketCdnNotification,\n  deleteBucketCdnNotification,\n} from './methods/bucket/cdnNotification';\nimport {\n  getBucketWorkflow,\n  putBucketWorkflow,\n  deleteBucketWorkflow,\n  getBucketWorkflowExecution,\n  listBucketWorkflowExecution,\n} from './methods/bucket/workflow';\nimport { createFileCompress } from './methods/fileCompress';\nimport { createFileUncompress } from './methods/fileUncompress';\nimport {\n  deleteBucketLogging,\n  getBucketLogging,\n  putBucketLogging,\n} from './methods/bucket/logging';\nimport {\n  putAccessPointPolicy,\n  getAccessPointPolicy,\n  deleteAccessPointPolicy,\n  putMultiRegionAccessPointPolicy,\n  getMultiRegionAccessPointPolicy,\n  deleteMultiRegionAccessPointPolicy,\n} from './methods/mrap/policy';\nimport {\n  putBucketAudit,\n  getBucketAudit,\n  listBucketAuditJob,\n  getBucketAuditJob,\n  postBucketAuditJob,\n  listBucketAuditBizType,\n} from './methods/bucket/audit';\nimport { listBucketJob, getBucketJob } from './methods/bucket/listJob';\nimport { createBucketAudioConvert } from './methods/bucket/audioConvert';\nimport { getObjectAITag } from './methods/object/getObjectAITag';\nimport {\n  getBucketRequestPayment,\n  putBucketRequestPayment,\n} from './methods/bucket/requestPayment';\n\n// refer https://stackoverflow.com/questions/23876782/how-do-i-split-a-typescript-class-into-multiple-files\nexport class InnerClient extends TOSBase {\n  // bucket base\n  createBucket = createBucket;\n  headBucket = headBucket;\n  deleteBucket = deleteBucket;\n  listBuckets = listBuckets;\n  getBucketLocation = getBucketLocation;\n  putBucketStorageClass = putBucketStorageClass;\n\n  // bucket acl\n  getBucketAcl = getBucketAcl;\n  putBucketAcl = putBucketAcl;\n\n  // bucket https config\n  putBucketHttpsConfig = putBucketHttpsConfig;\n  getBucketHttpsConfig = getBucketHttpsConfig;\n\n  // bucket policy\n  getBucketPolicy = getBucketPolicy;\n  putBucketPolicy = putBucketPolicy;\n  deleteBucketPolicy = deleteBucketPolicy;\n\n  // bucket versioning\n  getBucketVersioning = getBucketVersioning;\n  putBucketVersioning = putBucketVersioning;\n\n  // bucket cors\n  getBucketCORS = getBucketCORS;\n  putBucketCORS = putBucketCORS;\n  deleteBucketCORS = deleteBucketCORS;\n\n  // bucket lifecycle\n  putBucketLifecycle = putBucketLifecycle;\n  getBucketLifecycle = getBucketLifecycle;\n  deleteBucketLifecycle = deleteBucketLifecycle;\n\n  //bucket encryption\n  putBucketEncryption = putBucketEncryption;\n  getBucketEncryption = getBucketEncryption;\n  deleteBucketEncryption = deleteBucketEncryption;\n\n  // bucket mirror back\n  putBucketMirrorBack = putBucketMirrorBack;\n  getBucketMirrorBack = getBucketMirrorBack;\n  deleteBucketMirrorBack = deleteBucketMirrorBack;\n\n  // bucket replication\n  putBucketReplication = putBucketReplication;\n  getBucketReplication = getBucketReplication;\n  deleteBucketReplication = deleteBucketReplication;\n\n  // bucket website\n  putBucketWebsite = putBucketWebsite;\n  getBucketWebsite = getBucketWebsite;\n  deleteBucketWebsite = deleteBucketWebsite;\n\n  // bucket notification\n  putBucketNotification = putBucketNotification;\n  getBucketNotification = getBucketNotification;\n\n  // bucket customdomain\n  putBucketCustomDomain = putBucketCustomDomain;\n  getBucketCustomDomain = getBucketCustomDomain;\n  deleteBucketCustomDomain = deleteBucketCustomDomain;\n\n  // bucket timelog\n  putBucketRealTimeLog = putBucketRealTimeLog;\n  getBucketRealTimeLog = getBucketRealTimeLog;\n  deleteBucketRealTimeLog = deleteBucketRealTimeLog;\n\n  // bucket Inventory\n  getBucketInventory = getBucketInventory;\n  listBucketInventory = listBucketInventory;\n  putBucketInventory = putBucketInventory;\n  deleteBucketInventory = deleteBucketInventory;\n\n  // bucket tag\n  putBucketTagging = putBucketTagging;\n  getBucketTagging = getBucketTagging;\n  deleteBucketTagging = deleteBucketTagging;\n\n  // bucket pay by traffic\n  putBucketPayByTraffic = putBucketPayByTraffic;\n  getBucketPayByTraffic = getBucketPayByTraffic;\n\n  // bucket imgStyle\n  getBucketImageStyle = getBucketImageStyle;\n  getBucketImageStyleList = getBucketImageStyleList;\n  getBucketImageStyleListByName = getBucketImageStyleListByName;\n  getImageStyleBriefInfo = getImageStyleBriefInfo;\n  deleteBucketImageStyle = deleteBucketImageStyle;\n  putBucketImageStyle = putBucketImageStyle;\n  putBucketImageStyleSeparator = putBucketImageStyleSeparator;\n  putBucketImageProtect = putBucketImageProtect;\n  getBucketImageProtect = getBucketImageProtect;\n  getBucketImageStyleSeparator = getBucketImageStyleSeparator;\n\n  // bucket tag\n  putBucketRename = putBucketRename;\n  getBucketRename = getBucketRename;\n  deleteBucketRename = deleteBucketRename;\n\n  // bucket acceleration\n  putBucketTransferAcceleration = putBucketTransferAcceleration;\n  getBucketTransferAcceleration = getBucketTransferAcceleration;\n\n  // object base\n  copyObject = copyObject;\n  resumableCopyObject = resumableCopyObject;\n  deleteObject = deleteObject;\n  deleteMultiObjects = deleteMultiObjects;\n  getObject = getObject;\n  getObjectV2 = getObjectV2;\n  getObjectToFile = getObjectToFile;\n  getObjectAcl = getObjectAcl;\n  headObject = headObject;\n  appendObject = appendObject;\n  listObjects = listObjects;\n  renameObject = renameObject;\n  fetchObject = fetchObject;\n  putFetchTask = putFetchTask;\n\n  listObjectsType2 = listObjectsType2;\n\n  listObjectVersions = listObjectVersions;\n  putObject = putObject;\n  putObjectFromFile = putObjectFromFile;\n  putObjectAcl = putObjectAcl;\n  setObjectMeta = setObjectMeta;\n\n  // object multipart\n  createMultipartUpload = createMultipartUpload;\n  uploadPart = uploadPart;\n  uploadPartFromFile = uploadPartFromFile;\n  completeMultipartUpload = completeMultipartUpload;\n  abortMultipartUpload = abortMultipartUpload;\n  uploadPartCopy = uploadPartCopy;\n  listMultipartUploads = listMultipartUploads;\n  listParts = listParts;\n  downloadFile = downloadFile;\n\n  // object tagging\n  putObjectTagging = putObjectTagging;\n  getObjectTagging = getObjectTagging;\n  deleteObjectTagging = deleteObjectTagging;\n\n  // batch job\n  listJobs = listJobs;\n  createJob = createJob;\n  deleteJob = deleteJob;\n  describeJob = describeJob;\n  updateJobStatus = updateJobStatus;\n  updateJobPriority = updateJobPriority;\n\n  // restore object\n  restoreObject = restoreObject;\n  // object others\n  uploadFile = uploadFile;\n  getPreSignedUrl = getPreSignedUrl;\n  /**\n   * alias to preSignedPostSignature\n   */\n  calculatePostSignature = calculatePostSignature;\n  preSignedPostSignature = calculatePostSignature;\n  preSignedPolicyURL = preSignedPolicyURL;\n  // object intelligenttiering\n  getBucketIntelligenttiering = getBucketIntelligenttiering;\n\n  // storageLens\n  listStorageLens = listStorageLens;\n  deleteStorageLens = deleteStorageLens;\n  getStorageLens = getStorageLens;\n  putStorageLens = putStorageLens;\n\n  // bucket notificationV2\n  putBucketNotificationType2 = putBucketNotificationType2;\n  getBucketNotificationType2 = getBucketNotificationType2;\n\n  // symlink\n  putSymlink = putSymlink;\n  getSymlink = getSymlink;\n\n  // bucket accessMonitor\n  putBucketAccessMonitor = putBucketAccessMonitor;\n  getBucketAccessMonitor = getBucketAccessMonitor;\n\n  // qospolicy\n  putQosPolicy = putQosPolicy;\n  getQosPolicy = getQosPolicy;\n  deleteQosPolicy = deleteQosPolicy;\n\n  // mrap\n  createMultiRegionAccessPoint = createMultiRegionAccessPoint;\n  getMultiRegionAccessPoint = getMultiRegionAccessPoint;\n  listMultiRegionAccessPoints = listMultiRegionAccessPoints;\n  getMultiRegionAccessPointRoutes = getMultiRegionAccessPointRoutes;\n  deleteMultiRegionAccessPoint = deleteMultiRegionAccessPoint;\n  submitMultiRegionAccessPointRoutes = submitMultiRegionAccessPointRoutes;\n\n  // mrap-accelerator\n  bindAcceleratorWithMultiRegionAccessPoint =\n    bindAcceleratorWithMultiRegionAccessPoint;\n  unbindAcceleratorWithMultiRegionAccessPoint =\n    unbindAcceleratorWithMultiRegionAccessPoint;\n  listBindAccessPointForMultiRegionAccelerator =\n    listBindAccessPointForMultiRegionAccelerator;\n\n  // mrap mirror back\n  putMultiRegionAccessPointMirrorBack = putMultiRegionAccessPointMirrorBack;\n  getMultiRegionAccessPointMirrorBack = getMultiRegionAccessPointMirrorBack;\n  deleteMultiRegionAccessPointMirrorBack =\n    deleteMultiRegionAccessPointMirrorBack;\n\n  // mrap policy\n  putMultiRegionAccessPointPolicy = putMultiRegionAccessPointPolicy;\n  getMultiRegionAccessPointPolicy = getMultiRegionAccessPointPolicy;\n  deleteMultiRegionAccessPointPolicy = deleteMultiRegionAccessPointPolicy;\n\n  putAccessPointPolicy = putAccessPointPolicy;\n  getAccessPointPolicy = getAccessPointPolicy;\n  deleteAccessPointPolicy = deleteAccessPointPolicy;\n  // accesspoint\n  createAccessPoint = createAccessPoint;\n  getAccessPoint = getAccessPoint;\n  listAccessPoints = listAccessPoints;\n  deleteAccessPoint = deleteAccessPoint;\n  bindAcceleratorWithAccessPoint = bindAcceleratorWithAccessPoint;\n  unbindAcceleratorWithAccessPoint = unbindAcceleratorWithAccessPoint;\n  listBindAccessPointForAccelerator = listBindAccessPointForAccelerator;\n\n  // accelerator\n  listAcceleratorAzs = listAcceleratorAzs;\n  putAccelerator = putAccelerator;\n  getAccelerator = getAccelerator;\n  listAccelerators = listAccelerators;\n  deleteAccelerator = deleteAccelerator;\n  putAcceleratorPrefetchJob = putAcceleratorPrefetchJob;\n  getAcceleratorPrefetchJob = getAcceleratorPrefetchJob;\n  deleteAcceleratorPrefetchJob = deleteAcceleratorPrefetchJob;\n  listAcceleratorPrefetchJobs = listAcceleratorPrefetchJobs;\n  listAcceleratorPrefetchJobRecords = listAcceleratorPrefetchJobRecords;\n\n  // pm3u8\n  putBucketPrivateM3U8 = putBucketPrivateM3U8;\n  getBucketPrivateM3U8 = getBucketPrivateM3U8;\n  // \n  putBucketBlindWatermark = putBucketBlindWatermark;\n  getBucketBlindWatermark = getBucketBlindWatermark;\n  // hns trash\n  putBucketTrash = putBucketTrash;\n  getBucketTrash = getBucketTrash;\n\n  // bucket lock\n  putBucketObjectLockConfiguration = putBucketObjectLockConfiguration;\n  getBucketObjectLockConfiguration = getBucketObjectLockConfiguration;\n\n  // object retention\n  putObjectRetention = putObjectRetention;\n  getObjectRetention = getObjectRetention;\n  // cdn notification\n  putBucketCdnNotification = putBucketCdnNotification;\n  getBucketCdnNotification = getBucketCdnNotification;\n  deleteBucketCdnNotification = deleteBucketCdnNotification;\n\n  // workflow\n  putBucketWorkflow = putBucketWorkflow;\n  getBucketWorkflow = getBucketWorkflow;\n  deleteBucketWorkflow = deleteBucketWorkflow;\n  getBucketWorkflowExecution = getBucketWorkflowExecution;\n  listBucketWorkflowExecution = listBucketWorkflowExecution;\n\n  // audit\n  putBucketAudit = putBucketAudit;\n  getBucketAudit = getBucketAudit;\n  listBucketAuditJob = listBucketAuditJob;\n  getBucketAuditJob = getBucketAuditJob;\n  postBucketAuditJob = postBucketAuditJob;\n  listBucketAuditBizType = listBucketAuditBizType;\n\n  // bucket file compress\n  createFileCompress = createFileCompress;\n  // bucket file uncompress\n  createFileUncompress = createFileUncompress;\n  createBucketAudioConvert = createBucketAudioConvert;\n  listBucketJob = listBucketJob;\n  getBucketJob = getBucketJob;\n  // logging\n  putBucketLogging = putBucketLogging;\n  getBucketLogging = getBucketLogging;\n  deleteBucketLogging = deleteBucketLogging;\n  getObjectAITag = getObjectAITag;\n  // requestPayment\n  putBucketRequestPayment = putBucketRequestPayment;\n  getBucketRequestPayment = getBucketRequestPayment;\n}\n","import axios from 'axios';\nimport { TosServerError, TosServerCode } from './TosServerError';\nimport { TosClientError } from './TosClientError';\nimport { isCancelError as isCancel } from './utils';\nimport { UploadEventType } from './methods/object/multipart/uploadFile';\nimport {\n  ACLType,\n  StorageClassType,\n  MetadataDirectiveType,\n  AzRedundancyType,\n  PermissionType,\n  GranteeType,\n  CannedType,\n  HttpMethodType,\n  LifecycleStatusType,\n  StatusType,\n  RedirectType,\n  StorageClassInheritDirectiveType,\n  TierType,\n  VersioningStatusType,\n  ReplicationStatusType,\n  AccessPointStatusType,\n  TransferAccelerationStatusType,\n  MRAPMirrorBackRedirectPolicyType,\n  WorkflowExecutionStateType,\n  FileUncompressPrefixReplaced,\n  FileCompressFlatten,\n  AccessPointStatus,\n  AcceleratorPrefetchJobStatus,\n  AuditJobStateType,\n  AuditScanType,\n} from './TosExportEnum';\nimport { CancelError } from './CancelError';\nimport { ResumableCopyEventType } from './methods/object/multipart/resumableCopyObject';\nimport { DownloadEventType } from './methods/object/downloadFile';\nimport { DataTransferType } from './interface';\nimport { ShareLinkClient } from './ShareLinkClient';\nimport { InnerClient } from './InnerClient';\nimport { createDefaultRateLimiter } from './universal/rate-limiter';\n\nconst CancelToken = axios.CancelToken;\n// for export\nclass TosClient extends InnerClient {\n  // for umd bundle\n  static TosServerError = TosServerError;\n  static isCancel = isCancel;\n  static CancelError = CancelError;\n  static TosServerCode = TosServerCode;\n  static TosClientError = TosClientError;\n  static CancelToken = CancelToken;\n  static ACLType = ACLType;\n  static StorageClassType = StorageClassType;\n  static MetadataDirectiveType = MetadataDirectiveType;\n  static AzRedundancyType = AzRedundancyType;\n  static PermissionType = PermissionType;\n  static GranteeType = GranteeType;\n  static CannedType = CannedType;\n  static HttpMethodType = HttpMethodType;\n  static LifecycleStatusType = LifecycleStatusType;\n  static StatusType = StatusType;\n  static RedirectType = RedirectType;\n  static StorageClassInheritDirectiveType = StorageClassInheritDirectiveType;\n  static TierType = TierType;\n  /** @private unstable */\n  static FileUncompressPrefixReplaced = FileUncompressPrefixReplaced;\n  /** @private unstable */\n  static FileCompressFlatten = FileCompressFlatten;\n  static VersioningStatusType = VersioningStatusType;\n  static createDefaultRateLimiter = createDefaultRateLimiter;\n  static DataTransferType = DataTransferType;\n  static UploadEventType = UploadEventType;\n  static DownloadEventType = DownloadEventType;\n  static ResumableCopyEventType = ResumableCopyEventType;\n  static ReplicationStatusType = ReplicationStatusType;\n  /** @private unstable */\n  static AccessPointStatusType = AccessPointStatusType;\n  /** @private unstable */\n  static AccessPointStatus = AccessPointStatus;\n  /** @private unstable */\n  static AcceleratorPrefetchJobStatus = AcceleratorPrefetchJobStatus;\n  /** @private unstable */\n  static TransferAccelerationStatusType = TransferAccelerationStatusType;\n  /** @private unstable */\n  static MRAPMirrorBackRedirectPolicyType = MRAPMirrorBackRedirectPolicyType;\n  /** @private unstable */\n  static WorkflowExecutionStateType = WorkflowExecutionStateType;\n  /** @private unstable */\n  static ShareLinkClient = ShareLinkClient;\n  /** @private unstable */\n  static AuditJobStateType = AuditJobStateType;\n  /** @private unstable */\n  static AuditScanType = AuditScanType;\n}\n\nexport default TosClient;\n\nexport { TosClient as TOS, TosClient };\nexport {\n  TosServerError,\n  TosClientError,\n  isCancel,\n  CancelError,\n  TosServerCode,\n  CancelToken,\n  ACLType,\n  StorageClassType,\n  MetadataDirectiveType,\n  AzRedundancyType,\n  PermissionType,\n  GranteeType,\n  CannedType,\n  HttpMethodType,\n  LifecycleStatusType,\n  RedirectType,\n  StatusType,\n  StorageClassInheritDirectiveType,\n  TierType,\n  VersioningStatusType,\n  createDefaultRateLimiter,\n  DataTransferType,\n  UploadEventType,\n  DownloadEventType,\n  ResumableCopyEventType,\n  ReplicationStatusType,\n  AccessPointStatusType,\n  AccessPointStatus,\n  AcceleratorPrefetchJobStatus,\n  TransferAccelerationStatusType,\n  ShareLinkClient,\n  MRAPMirrorBackRedirectPolicyType,\n  WorkflowExecutionStateType,\n  FileUncompressPrefixReplaced,\n  FileCompressFlatten,\n  AuditJobStateType,\n  AuditScanType,\n};\n\n// TODO: hack for umd\nif (\n  process.env.TARGET_ENVIRONMENT === 'browser' &&\n  process.env.BUILD_FORMAT === 'umd'\n) {\n  // @ts-ignore\n  if (typeof window !== 'undefined') {\n    // @ts-ignore\n    window.TOS = TosClient;\n    // @ts-ignore\n    window.TosClient = TosClient;\n  }\n  if (typeof global !== 'undefined') {\n    // @ts-ignore\n    global.TOS = TosClient;\n    // @ts-ignore\n    global.TosClient = TosClient;\n  }\n  if (typeof globalThis !== 'undefined') {\n    // @ts-ignore\n    globalThis.TOS = TosClient;\n    // @ts-ignore\n    globalThis.TosClient = TosClient;\n  }\n}\n"],"names":["TosServerCode","TosServerError","Error","constructor","response","data","super","Message","code","statusCode","headers","requestId","id2","Object","setPrototypeOf","this","prototype","Code","status","TosClientError","message","CancelError","createWriteStream","fs","createReadStream","rename","promisify","stat","writeFile","rm","unlink","readFile","safeMkdirRecursive","async","fsPromises","access","dirName","e","mkdir","recursive","TOS","createDebug","makeArrayProp","obj","key","value","get","Array","isArray","set","makeConvertProp","convertMethod","finalMethod","target","map","it","keys","reduce","acc","covertCamelCase2Kebab","camelCase","replace","toLowerCase","convertNormalCamelCase2Upper","normalCamelCase","toUpperCase","slice","getSortedQueryString","query","searchParts","sort","forEach","push","encodeURIComponent","join","normalizeHeadersKey","headers1","headers2","headers3","newKey","normalizeProxy","proxy","url","safeAwait","p","err","isBlob","Blob","isBuffer","Buffer","isReadable","Readable","obj2QueryStr","v","vStr","isCancelError","gmtDateOrStr","toUTCString","requestHeadersMap","projectName","encodingType","cacheControl","contentDisposition","contentLength","contentMD5","contentSHA256","contentEncoding","contentLanguage","contentType","expires","range","ifMatch","ifModifiedSince","ifNoneMatch","ifUnmodifiedSince","acl","grantFullControl","grantRead","grantReadAcp","grantWrite","grantWriteAcp","serverSideEncryption","serverSideDataEncryption","ssecAlgorithm","ssecKey","ssecKeyMD5","copySourceRange","copySourceIfMatch","copySourceIfModifiedSince","copySourceIfNoneMatch","copySourceIfUnmodifiedSince","copySourceSSECAlgorithm","copySourceSSECKey","copySourceSSECKeyMD5","metadataDirective","meta","prev","websiteRedirectLocation","storageClass","azRedundancy","trafficLimit","callback","callbackVar","allowSameActionOverlap","String","symLinkTargetKey","symLinkTargetBucket","forbidOverwrite","bucketType","recursiveMkdir","requestQueryMap","versionId","process","saveBucket","saveObject","responseCacheControl","responseContentDisposition","responseContentEncoding","responseContentLanguage","responseContentType","responseExpires","fillRequestHeaders","length","setOneHeader","k","confV","oriValue","entries","paramsSerializer","params","qs","stringify","getNormalDataFromError","checkCRC64WithHeaders","crc","serverCRC64","crcStr","getCrc64","bindStreamErrorHandler","stream","prefix","on","log","HttpHeader","makeSerialAsyncTask","makeTask","lastTask","Promise","resolve","then","safeParseCheckpointFile","JSON","parse","fsp","filePath","console","warn","makeRetryStreamAutoClose","makeStream","lastStream","getLastStream","make","tryDestroy","destroy","destroyed","pipeStreamWithErrorHandle","src","dest","label","pipe","isValidBucketName","bucket","isCustomDomain","test","createMultipartUpload","input","normalizeObjectInput","setObjectContentTypeHeader","_fetchObject","uploads","calculateSafePartSize","totalSize","expectPartSize","showWarning","partSize","minSize","Math","ceil","listParts","uploadId","nextQuery","ret","arrayProp","mimeTypes","3gp","7z","abw","ai","aif","aifc","aiff","alc","amr","anx","apk","appcache","art","asc","asf","aso","asx","atom","atomcat","atomsrv","au","avi","awb","axa","axv","b","bak","bat","bcpio","bib","bin","bmp","boo","book","brf","bsd","c","c++","c3d","cab","cac","cache","cap","cascii","cat","cbin","cbr","cbz","cc","cda","cdf","cdr","cdt","cdx","cdy","cef","cer","chm","chrt","cif","class","cls","cmdf","cml","cod","com","cpa","cpio","cpp","cpt","cr2","crl","crt","crw","csd","csf","csh","csm","csml","css","csv","ctab","ctx","cu","cub","cxf","cxx","d","davmount","dcm","dcr","ddeb","dif","diff","dir","djv","djvu","dl","dll","dmg","dms","doc","docm","docx","dot","dotm","dotx","dv","dvi","dx","dxr","emb","embl","eml","eot","eps","eps2","eps3","epsf","epsi","erf","es","etx","exe","ez","fb","fbdoc","fch","fchk","fig","flac","fli","flv","fm","frame","frm","gal","gam","gamin","gan","gau","gcd","gcf","gcg","gen","gf","gif","gjc","gjf","gl","gnumeric","gpt","gsf","gsm","gtar","gz","h","h++","hdf","hh","hin","hpp","hqx","hs","hta","htc","htm","html","hwp","hxx","ica","ice","ico","ics","icz","ief","iges","igs","iii","info","inp","ins","iso","isp","ist","istr","jad","jam","jar","java","jdx","jmz","jng","jnlp","jp2","jpe","jpeg","jpf","jpg","jpg2","jpm","jpx","js","json","kar","kil","kin","kml","kmz","kpr","kpt","ksp","kwd","kwt","latex","lha","lhs","lin","lsf","lsx","ltx","ly","lyx","lzh","lzx","m3g","m3u","m3u8","m4a","maker","man","mbox","mcif","mcm","mdb","me","mesh","mid","midi","mif","mkv","mm","mmd","mmf","mml","mmod","mng","moc","mol","mol2","moo","mop","mopcrt","mov","movie","mp2","mp3","mp4","mpc","mpe","mpeg","mpega","mpg","mpga","mph","mpv","ms","msh","msi","mvb","mxf","mxu","nb","nbp","nc","nef","nwc","o","oda","odb","odc","odf","odg","odi","odm","odp","ods","odt","oga","ogg","ogv","ogx","old","one","onepkg","onetmp","onetoc2","opf","opus","orc","orf","otf","otg","oth","otp","ots","ott","oza","p7r","pac","pas","pat","patch","pbm","pcap","pcf","pcf.Z","pcx","pdb","pdf","pfa","pfb","pfr","pgm","pgn","pgp","php","php3","php3p","php4","php5","phps","pht","phtml","pk","pl","pls","pm","png","pnm","pot","potm","potx","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","prf","prt","ps","psd","py","pyc","pyo","qgs","qt","qtl","ra","ram","rar","ras","rb","rd","rdf","rdp","rgb","rhtml","roff","ros","rpm","rss","rtf","rtx","rxn","scala","sce","sci","sco","scr","sct","sd","sd2","sda","sdc","sdd","sds","sdw","ser","sfd","sfv","sgf","sgl","sh","shar","shp","shtml","shx","sid","sig","sik","silo","sis","sisx","sit","sitx","skd","skm","skp","skt","sldm","sldx","smi","smil","snd","spc","spl","spx","sql","srt","stc","std","sti","stw","sty","sv4cpio","sv4crc","svg","svgz","sw","swf","swfl","sxc","sxd","sxg","sxi","sxm","sxw","t","tar","taz","tcl","tex","texi","texinfo","text","tgf","tgz","thmx","tif","tiff","tk","tm","torrent","tr","ts","tsp","tsv","ttf","ttl","txt","uls","ustar","val","vcard","vcd","vcf","vcs","vmd","vms","vrm","vrml","vsd","vss","vst","vsw","wad","wasm","wav","wax","wbmp","wbxml","webm","wk","wm","wma","wmd","wml","wmlc","wmls","wmlsc","wmv","wmx","wmz","woff","wp5","wpd","wrl","wsc","wvx","wz","x3d","x3db","x3dv","xbm","xcf","xcos","xht","xhtml","xlam","xlb","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xml","xpi","xpm","xsd","xsl","xslt","xspf","xtel","xul","xwd","xyz","xz","zip","createReadNCbTransformer","readCb","Transform","[object Object]","chunk","_encoding","createReadNReadStream","readCbTransformer","crcModule","reset","update","crc64","CRC","combineCrc64","createRateLimiterTransform","rateLimiter","chunkSize","finished","ok","timeToWait","Acquire","wait","error","milliseconds","r","setTimeout","capacity","rate","realCapacity","max","currentAmount","lastConsumeTime","Date","now","want","increment","floor","pipeRateLimit","moduleNode","createDefaultRateLimiter","createRateLimiterStream","Buffer2Stream","buf","lastPos","_read","n","actualN","min","createReadCbTransformer","createCrcReadStream","TosHeader","validateObjectName","getSize","body","size","getNewBodyConfig","config1","dataTransferCallback","makeRetryStream","newBody","bodyBuf","isValidRateLimiter","oriMakeRetryStream","undefined","getEmitReadBodyConfig","beforeRetry","enableCRC","getCRCBodyConfig","getCopySourceHeaderValue","srcBucket","srcKey","Function","validateCheckpoint","cp","getRestoreInfoFromHeaders","headerStoreValue","HeaderRestore","ExpiryDate","split","_split$","_split$$split","OngoingRequest","trim","restoreInfo","RestoreStatus","RestoreParam","ExpiryDays","HeaderRestoreExpiryDays","Number","RequestDate","HeaderRestoreRequestDate","Tier","HeaderRestoreTier","DataTransferType","hashMd5","decoding","toString","coding","cryptoEncUtf8","cryptoEncBase64","cryptoEncHex","getEnc","decode","cryptoHashMd5","digest","crypto","createHmac","createHash","str","encoding","from","hmacSha256","hashSha256","_uploadPart","partNumber","enableContentMD5","toFixed","newStream","allContent","concat","md5","totalSizeValid","dataTransferStatusChange","progress","consumedBytes","triggerDataTransfer","type","rwOnceBytes","totalBytes","progressValue","Succeed","bodyConfig","Rw","opts","Started","res","handleResponse","ETag","etag","serverSideEncryptionKeyId","hashCrc64ecma","axiosOpts","__retryConfig__","onUploadProgress","event","loaded","task","Failed","uploadPart","call","uploadPartFromFile","stats","start","offset","end","content-length","completeMultipartUpload","result","VersionID","Bucket","Location","HashCrc64ecma","Key","CallbackResult","completeAll","parts","x-tos-complete-all","Parts","eTag","PartNumber","EmptyReadStream","UploadEventType","ABORT_ERROR_STATUS_CODE","uploadFile","cancelToken","isCancel","reason","checkpoint","fileStats","file","fileSize","checkpointRichInfo","checkpointStat","_err","isDirectory","endsWith","path","dirPath","dirname","filePathIsPlaceholder","record","_checkpointRichInfo$r","file_info","last_modified","file_size","_checkpointRichInfo$r2","mtimeMs","_checkpointRichInfo$r3","part_size","tasks","allTasks","i","currPartSize","getAllTasks","initConsumedBytes","parts_info","filter","is_completed","consumedBytesForProgress","recordedTasks","recordedTaskMap","Map","part_number","getCheckpointContent","checkpointContent","upload_id","triggerUploadEvent","uploadEventChange","checkpointFile","TriggerProgressEventType","triggerProgressEvent","uploadPartSucceed","writeCheckpointFile","content","updateAfterUploadPart","uploadPartRes","existRecordTask","hash_crc64ecma","uploadPartInfo","UploadPartFailed","includes","UploadPartAborted","UploadPartSucceed","uploadedPartSet","Set","has","multipartRes","UploadId","_checkpointRichInfo$f","getDefaultCheckpointFilePath","CreateMultipartUploadSucceed","CreateMultipartUploadFailed","firstErr","index","all","taskNum","consumedBytesThisTask","curTask","curErr","currentIndex","getBody","getMakeRetryStream","_makeRetryStream","x-tos-server-side-encryption-customer-algorithm","x-tos-server-side-encryption-customer-key","x-tos-server-side-encryption-customer-key-md5","_makeRetryStream2","CompleteMultipartUploadFailed","CompleteMultipartUploadSucceed","completeMultipartUploadSucceed","catch","rmCheckpointFile","sortedPartsInfo","_cp$parts_info","a","part","combineCRCInParts","handleTasks","ACLType","StorageClassType","MetadataDirectiveType","AzRedundancyType","PermissionType","GranteeType","CannedType","HttpMethodType","StorageClassInheritDirectiveType","ReplicationStatusType","LifecycleStatusType","RedirectType","StatusType","TierType","VersioningStatusType","AccessPointStatusType","TransferAccelerationStatusType","MRAPMirrorBackRedirectPolicyType","WorkflowExecutionStateType","FileCompressFlatten","FileUncompressPrefixReplaced","AccessPointStatus","AcceleratorPrefetchJobStatus","AuditJobStateType","AuditScanType","ResumableCopyEventType","headObject","normalizedInput","ReplicationStatus","HeaderReplicationStatus","RestoreInfo","uploadPartCopy","copySource","srcVersionID","copySourceRangeStart","copySourceRangeEnd","copyRange","SSECAlgorithm","SSECKeyMD5","copyObject","resumableCopyObject","objectStats","srcVersionId","objectSize","copy_source_object_info","object_size","copy_source_range_end","copy_source_range_start","copyEventListener","rangeStart","rangeEnd","copyPartInfo","UploadPartCopyFailed","UploadPartCopyAborted","UploadPartCopySucceed","cloneDeep","Boolean","x-tos-copy-source","x-tos-copy-source-if-match","secure","endpoint","handleEmptyObj","x-tos-copy-source-range","sourceCRC64","actualCrc64","getObject","responseType","NODEJS_DATATYPE","getObjectV2","dataType","environment","supportDataTypes","checkSupportDataType","setOneKey","fillRequestQuery","onDownloadProgress","total","resHeaders","newData","reject","streamToBuf","actualRes","lastModified","getObjectToFile","getObjectRes","fsWriteStream","DownloadEventType","downloadFile","headObjectRes","symlinkTargetSize","object_info","filePathStats","tempFilePath","isExist","range_end","range_start","nextEnsureCloseFd","version_id","file_path","temp_file_path","triggerDownloadEvent","downloadEventChange","downloadPartSucceed","updateAfterDownloadPart","downloadPartRes","rangeHashCrc64ecma","downloadPartInfo","DownloadPartFailed","DownloadPartAborted","DownloadPartSucceed","flag","CreateTempFileFailed","CreateTempFileSucceed","if-match","dataStream","crcInst","writeStream","flags","isErr","handleOnceCancel","unpipe","off","customRenameFileAfterDownloadCompleted","RenameTempFileFailed","RenameTempFileSucceed","renameTempFileSucceed","isDefaultPort","port","v4Identifier","SignersV4","opt","credentials","options","signature","expiredAt","credString","credentialString","datetime","algorithm","GetAccessKey","signedHeaders","authorization","signatureHeader","getDateTime","header","host","endpoints","hexEncodedBodyHash","securityToken","startsWith","getEncodePath","sign","gnrCopySig","getSignature","getSignatureQuery","X-Tos-Algorithm","X-Tos-Content-Sha256","X-Tos-Credential","X-Tos-Date","X-Tos-Expires","X-Tos-SignedHeaders","getSignaturePolicyQuery","X-Tos-Policy","policy","signingKey","getSigningKey","substr","stringToSign","toISOString","createScope","region","serviceName","date","kDate","GetSecretKey","kRegion","kService","canonicalString","canonicalStringPolicy","hexEncodedHash","string","method","canonicalHeaders","needSignHeaders","getNeedSignedHeaders","canonicalHeaderValues","values","encodeAll","tmpPath","ISigV4Credentials","secretAccessKey","accessKeyId","TosAgent","tosOpts","agentOpts","agent","isHttps","https","Agent","http","keepAlive","rejectUnauthorized","enableVerifySSL","timeout","idleConnectionTime","maxFreeSockets","Infinity","maxTotalSockets","maxConnections","oriCreateConnection","createConnection","args","socket","isTimeout","isConnected","connectTimer","nextTick","connectionTimeout","clearTimeout","TOSBase","_opts","axiosInst","userAgent","httpAgent","httpsAgent","getObjectPath","actualBucket","actualKey","mimeType","getObjectInputKey","autoRecognizeContentType","lastDotIndex","lastIndexOf","extName","lookupMimeType","normalizeOpts","proxyHost","getUserAgent","maxRetryCount","axios","create","defaults","auth","withCredentials","maxContentLength","maxBodyLength","maxRedirects","validateStatus","decompress","transitional","silentJSONParsing","forcedJSONParsing","clarifyTimeoutError","ensureHeaders","_v$response","handleResponseHeader","decodedValue","func","decodeURI","safeSync","sArr","valueArr","match","decodedValueArr","j","ch","encodedCh","charCodeAt","interceptors","use","isAxiosError","_error$response","config","retryConfig","retryCount","canRetryData","_error$response$heade","isNetworkError","isCanRetryStatusCode","retrySignature","signOpt","sigInst","nextConfig","makeAxiosInst","mustKeysErrorStr","_default","defaultValue","requestTimeout","requestAdapter","getAdapter","osType","oriType","os","Linux","Darwin","Windows_NT","nodeVersion","version","arch","userAgentProductName","userAgentSoftName","userAgentSoftVersion","customStr","userAgentCustomizedKeyValues","needMd5","md5String","newPath","subdomainBucket","forcePathStyle","header2","encodeHeadersValue","signv4","stsToken","accessKeySecret","signatureHeaders","reqHeaders","reqOpts","baseURL","normalizedProxy","needProxyParams","proxyPort","protocol","logReqOpts","adapter","__retrySignature__","_err$response","_err$response$headers","fetch","subdomain","normalizeBucketInput","listObjects","fetchBucket","listObjectVersions","versions","listObjectsType2","listOnlyOnce","output","maxKeys","listObjectsType2Once","KeyCount","IsTruncated","NextContinuationToken","Contents","CommonPrefixes","continuationToken","list-type","ShareLinkClient","modifyAxiosInst","request","parsedPolicyUrlVal","origin","addQueryStr","search","shareLinkClientOpts","initParsedPolicyUrlVal","matched","policyUrl","listBuckets","createBucket","deleteBucket","headBucket","ProjectName","HeaderProjectName","putBucketStorageClass","x-tos-storage-class","putBucketAcl","aclBody","getBucketAcl","putBucketHttpsConfig","TLS","httpsConfig","getBucketHttpsConfig","putObject","_putObject","putObjectFromFile","normalizedHeaders","fetchObject","URL","IgnoreSameKey","ignoreSameKey","ContentMD5","putFetchTask","fetchTask","getPreSignedUrl","alternativeEndpoint","newHost","signingPath","encodedKey","objectKeyPath","setOneQuery","_key","kebabKey","deleteObject","skipTrash","renameObject","name","deleteMultiObjects","Quiet","quiet","Objects","objects","VersionId","delete","getObjectAcl","putObjectAcl","abortMultipartUpload","listMultipartUploads","appendObject","preHashCrc64ecma","append","nextAppendOffset","setObjectMeta","metadata","calculatePostSignature","expiresIn","fields","conditions","expirationDateStr","getDateTimeStr","valueOf","dateStr","date8Str","substring","service","requestStr","addedInForm","x-tos-algorithm","x-tos-date","x-tos-credential","policyStr","expiration","policyBase64","defaultEmptyMethodMap","getBucketCustomDomain","getBucketIntelligenttiering","getBucketInventory","listBucketInventory","getBucketMirrorBack","getBucketNotification","getBucketPolicy","getBucketRealTimeLog","getBucketReplication","getBucketTagging","getBucketWebsite","handleEmptyServerError","enableCatchEmptyServerError","methodKey","defaultResponse","putBucketPolicy","enableOptimizeMethodBehavior","Statement","deleteBucketPolicy","Condition","key2","Version","getBucketVersioning","versioning","putBucketVersioning","Status","preSignedPolicyURL","normalizeInput","validateConditions","queryStr","getSignedURLForList","additionalQuery","str2","q","getSignedURLForGetOrHead","keyPath","signedQuery","normalizedConditions","operator","getBucketLocation","location","getBucketCORS","cors","CORSRules","putBucketCORS","deleteBucketCORS","putBucketLifecycle","rules","deleteBucketLifecycle","lifecycle","Rules","getBucketLifecycle","AllowSameActionOverlap","putBucketEncryption","rule","encryption","Content-MD5","Rule","getBucketEncryption","deleteBucketEncryption","putBucketMirrorBack","deleteBucketMirrorBack","mirror","putObjectTagging","tagSet","tagging","TagSet","getObjectTagging","deleteObjectTagging","putBucketReplication","role","deleteBucketReplication","replication","Role","ruleId","putBucketWebsite","otherProps","website","RoutingRules","deleteBucketWebsite","putBucketNotification","notification","CloudFunctionConfigurations","RocketMQConfigurations","putBucketCustomDomain","customdomain","CustomDomainRules","deleteBucketCustomDomain","customDomain","putBucketRealTimeLog","realtimeLog","deleteBucketRealTimeLog","ScheduleFrequency","IncludedObjectVersions","InventoryOptionalFields","StringOp","DateOp","IpOp","QuotaType","req","inventory","id","continuation-token","InventoryConfigurations","deleteBucketInventory","putBucketInventory","inventoryConfiguration","Id","createJob","accountId","x-tos-account-id","listJobs","maxResults","others","updateJobPriority","jobId","JobId","priority","updateJobStatus","requestedJobStatus","statusUpdateReason","deleteJob","describeJob","putBucketTagging","Tags","deleteBucketTagging","putBucketPayByTraffic","payByTraffic","getBucketPayByTraffic","getImageStyleBriefInfo","imageStyleBriefInfo","BucketName","ImageStyleBriefInfo","getBucketImageStyleList","imageStyle","ImageStyles","getBucketImageStyleListByName","styleName","imageStyleContent","getBucketImageStyle","putBucketImageStyle","styleObjectPrefix","Content","deleteBucketImageStyle","putBucketImageProtect","originalImageProtect","getBucketImageProtect","putBucketImageStyleSeparator","Separator","SeparatorSuffix","imageStyleSeparator","getBucketImageStyleSeparator","intelligenttiering","putBucketRename","getBucketRename","deleteBucketRename","restoreObject","restore","listStorageLens","deleteStorageLens","getStorageLens","putStorageLens","rest","putBucketNotificationType2","notification_v2","getBucketNotificationType2","putSymlink","_putSymlink","symlink","getSymlink","_getSymlink","SymlinkTargetKey","SymlinkTargetBucket","LastModified","putBucketTransferAcceleration","transferAcceleration","getBucketTransferAcceleration","getStatus","TransferAccelerationConfiguration","Enabled","Terminated","putBucketAccessMonitor","accessmonitor","getBucketAccessMonitor","getQosPolicy","putQosPolicy","restParams","deleteQosPolicy","createMultiRegionAccessPoint","regions","Name","Regions","getMultiRegionAccessPoint","listMultiRegionAccessPoints","getMultiRegionAccessPointRoutes","alias","deleteMultiRegionAccessPoint","submitMultiRegionAccessPointRoutes","routes","Routes","bindAcceleratorWithMultiRegionAccessPoint","AccountId","MultiRegionAccessPointAlias","AcceleratorId","unbindAcceleratorWithMultiRegionAccessPoint","listBindAccessPointForMultiRegionAccelerator","createAccessPoint","BucketAccountId","NetworkOrigin","VpcId","getAccessPoint","listAccessPoints","deleteAccessPoint","bindAcceleratorWithAccessPoint","AcceleratorAccountId","AccessPointName","unbindAcceleratorWithAccessPoint","listBindAccessPointForAccelerator","restQuery","putAccelerator","Accelerator","getAccelerator","listAccelerators","deleteAccelerator","listAcceleratorAzs","putAcceleratorPrefetchJob","acceleratorId","getAcceleratorPrefetchJob","deleteAcceleratorPrefetchJob","listAcceleratorPrefetchJobs","listAcceleratorPrefetchJobRecords","putMultiRegionAccessPointMirrorBack","deleteMultiRegionAccessPointMirrorBack","getMultiRegionAccessPointMirrorBack","putBucketPrivateM3U8","enable","privateM3U8","Enable","getBucketPrivateM3U8","putBucketBlindWatermark","blindWatermark","getBucketBlindWatermark","putBucketTrash","trash","getBucketTrash","putBucketObjectLockConfiguration","objectLockEnabled","object-lock","ObjectLockEnabled","getBucketObjectLockConfiguration","putObjectRetention","mode","retainUntilDate","retention","Mode","RetainUntilDate","getObjectRetention","putBucketCdnNotification","deleteBucketCdnNotification","cdn_notification","getBucketCdnNotification","putBucketWorkflow","deleteBucketWorkflow","workflow","getBucketWorkflow","getBucketWorkflowExecution","executionId","workflow_execution","listBucketWorkflowExecution","workflowId","startTime","endTime","states","orderByTime","pageSize","pageToken","Items","createFileCompress","Input","FileCompressConfig","Output","file_jobs","job_type","createFileUncompress","FileUncompressConfig","getBucketLogging","logging","putBucketLogging","LoggingEnabled","TargetBucket","targetBucket","TargetPrefix","targetPrefix","deleteBucketLogging","putAccessPointPolicy","_policy$Statement","deleteAccessPointPolicy","getAccessPointPolicy","Policy","putMultiRegionAccessPointPolicy","_policy$Statement2","deleteMultiRegionAccessPointPolicy","getMultiRegionAccessPointPolicy","getBucketAudit","audit","putBucketAudit","action","listBucketAuditJob","getBucketAuditJob","job_id","postBucketAuditJob","job","audit_jobs","listBucketAuditBizType","audit_type","audits","listBucketJob","jobType","getBucketJob","createBucketAudioConvert","AudioConvertConfig","media_jobs","getObjectAITag","x-tos-process","putBucketRequestPayment","requestPayment","getBucketRequestPayment","InnerClient","preSignedPostSignature","CancelToken","TosClient"],"mappings":"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"}